var documenterSearchIndex = {"docs":
[{"location":"visualizations/#visualizations","page":"Animations, GUIs, Visuals","title":"Interactive GUIs, animations, visualizations","text":"","category":"section"},{"location":"visualizations/","page":"Animations, GUIs, Visuals","title":"Animations, GUIs, Visuals","text":"Using the functionality of package extensions in Julia v1.9+, DynamicalSystems.jl provides various visualization tools as soon as the Makie package comes into scope (i.e., when using Makie or any of its backends like GLMakie).","category":"page"},{"location":"visualizations/","page":"Animations, GUIs, Visuals","title":"Animations, GUIs, Visuals","text":"The main functionality is interactive_trajectory that allows building custom GUI apps for visualizing the time evolution of dynamical systems. The remaining GUI applications in this page are dedicated to more specialized scenarios.","category":"page"},{"location":"visualizations/#Interactive-or-animated-trajectory-evolution","page":"Animations, GUIs, Visuals","title":"Interactive- or animated trajectory evolution","text":"","category":"section"},{"location":"visualizations/","page":"Animations, GUIs, Visuals","title":"Animations, GUIs, Visuals","text":"<video width=\"100%\" height=\"auto\" controls autoplay loop>\n<source src=\"https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/interact/interactive_trajectory.mp4?raw=true\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"visualizations/","page":"Animations, GUIs, Visuals","title":"Animations, GUIs, Visuals","text":"interactive_trajectory","category":"page"},{"location":"visualizations/#DynamicalSystems.interactive_trajectory","page":"Animations, GUIs, Visuals","title":"DynamicalSystems.interactive_trajectory","text":"interactive_trajectory(ds::DynamicalSystem [, u0s]; kwargs...) → fig, dsobs\n\nCreate a panel (a new Makie figure) that contains an axis showing the evolving trajectories of ds while optionally allowing for interactively starting/stopping the time evolution and/or changing the system parameters via sliders. Return the newly created figure fig that may include interactivity-related buttons, and a dsobs::DynamicalSystemObservable that facilities the creation of custom animations and/or interactive applications, see the custom animations section below.\n\nThe given dynamical system is always cast into a ParallelDynamicalSystem. The trajectories from the initial conditions in u0s (a vector of vectors) are all evolved and visualized in parallel. By default only the current state of the system is used.\n\nSee also interactive_trajectory_timeseries.\n\nInteractivity and time stepping keywords\n\nadd_controls = true: If true, below the main axis containing the trajectories some controls for animating the trajectories live are added: run, pause, and how many steps to evolve for per animation step. The plotted trajectories can always be evolved manually using the custom animations etup that we describe below; add_controls only concerns the buttons and interactivity added to the created panel.\nparameter_sliders = nothing: If given, it must be a dictionary, mapping parameter indices (of the parameter container of ds) into ranges. Each combination of index and range becomes a slider that can be interactively controlled to alter a system parameter on the fly during time evolution. Note that all parameter systems can always be altered on the fly using the custom animation setup that we describe below; parameter_sliders only conserns the buttons and interactivity added to the created panel.\nparameter_names = Dict(keys(ps) .=> keys(ps)): Dictionary mapping parameter keys to labels. Only valid if parameter_sliders is given.\nΔt: Time step of time evolution. Defaults to 1 for discrete time, 0.01 for continuous time systems.\npause = nothing: If given, it must be a real number. This number is given to the sleep function, which is called between each plot update.\n\nVisualization keywords\n\ncolors: The color for each initial condition (and resulting trajectory).\nidxs = 1:min(length(transform(u0s[1])), 3): Which variables to plot (up to three can be chosen).\ntail = 1000: Length of plotted trajectory (in units of Δt).\nfade = true: The trajectories in state space are faded to full transparency if true.\nmarkersize = 15: Size of markers of trajectory endpoints. For discrete systems half of that is used for the trajectory tail.\nplotkwargs = NamedTuple(): A named tuple of keyword arguments propagated to the state space plot (lines for continuous, scatter for discrete systems). plotkwargs can also be a vector of named tuples, in which case each initial condition gets different arguments.\n\nLayouting keywords\n\nidxs = 1:min(dimension(ds), 3): Which variables of ds should be plotted. If three indices are given, the trajectory plot is also 3D, otherwise 2D. Note that no transformation of the dynamical system is done, you can use a ProjectedDynamicalSystem if you want to visualize an arbitrary transformation of ds.\nlims: A tuple of tuples (min, max) for the axis limits. If not given, they are automatically deduced by evolving each of u0s 100 units and picking most extreme values (limits are not adjusted by default during the live animations)\nfigure, axis: both can be named tuples with arbitrary keywords propagated to the generation of the Figure and state space Axis instances.\n\nCustom animations\n\nThe second return argument dsobs is a DynamicalSystemObservable. The trajectories plotted in the main panel are linked to observables that are fields of the dsobs. Specifically, the field dsobs.state_obserable is an observable containing the final state of each of the trajectories, i.e., a vector of vectors like u0s. dsobs.param_observable is an observable of the system parameters. These observables are triggered by the interactive GUI buttons (the first two when the system is stepped in time, the last one when the parameters are updated). However, these observables, and hence the corresponding plotted trajectories that are maped from these observables, can be updated via the formal API of DynamicalSystem:\n\nstep!(dsobs, n::Int = 1)\n\nwill step the system for n steps of Δt time, and only update the plot on the last step. set_parameter!(dsobs, index, value) will update the system parameter and then trigger the parameter observable. Lastly, set_state!(dsobs, new_u [, i]) will set the i-th system state and clear the trajectory plot to the new initial condition.\n\nThis information can be used to create custom animations and/or interactive apps. In principle, the only thing a user has to do is create new observables from the existing ones using e.g. the on function and plot these new observables. Various examples are provided in the online documentation.\n\n\n\n\n\n","category":"function"},{"location":"visualizations/#Example-1:-interactive-trajectory-animation","page":"Animations, GUIs, Visuals","title":"Example 1: interactive trajectory animation","text":"","category":"section"},{"location":"visualizations/","page":"Animations, GUIs, Visuals","title":"Animations, GUIs, Visuals","text":"using DynamicalSystems, CairoMakie\nF, G, a, b = 6.886, 1.347, 0.255, 4.0\nds = PredefinedDynamicalSystems.lorenz84(; F, G, a, b)\n\nu1 = [0.1, 0.1, 0.1] # periodic\nu2 = u1 .+ 1e-3     # fixed point\nu3 = [-1.5, 1.2, 1.3] .+ 1e-9 # chaotic\nu4 = [-1.5, 1.2, 1.3] .+ 21e-9 # chaotic 2\nu0s = [u1, u2, u3, u4]\n\nfig, dsobs = interactive_trajectory(\n    ds, u0s; tail = 1000, fade = true,\n    idxs = [1,3],\n)\n\nfig","category":"page"},{"location":"visualizations/","page":"Animations, GUIs, Visuals","title":"Animations, GUIs, Visuals","text":"We could interact with this plot live, like in the example video above. We can also progress the visuals via code as instructed by interactive_trajectory utilizing the second returned argument dsobs:","category":"page"},{"location":"visualizations/","page":"Animations, GUIs, Visuals","title":"Animations, GUIs, Visuals","text":"step!(dsobs, 2000)\nfig","category":"page"},{"location":"visualizations/","page":"Animations, GUIs, Visuals","title":"Animations, GUIs, Visuals","text":"(if you progress the visuals via code you probably want to give add_controls = false as a keyword to interactive_trajectory)","category":"page"},{"location":"visualizations/#Example-2:-Adding-parameter-dependent-elements-to-a-plot","page":"Animations, GUIs, Visuals","title":"Example 2: Adding parameter-dependent elements to a plot","text":"","category":"section"},{"location":"visualizations/","page":"Animations, GUIs, Visuals","title":"Animations, GUIs, Visuals","text":"In this advanced example we add plot elements to the provided figure, and also utilize the parameter observable in dsobs to add animated plot elements that update whenever a parameter updates. The final product of this snippet is in fact the animation at the top of the docstring of interactive_trajectory_panel.","category":"page"},{"location":"visualizations/","page":"Animations, GUIs, Visuals","title":"Animations, GUIs, Visuals","text":"We start with an interactive trajectory panel of the Lorenz63 system, in which we also add sliders for interactively changing parameter values","category":"page"},{"location":"visualizations/","page":"Animations, GUIs, Visuals","title":"Animations, GUIs, Visuals","text":"using DynamicalSystems, CairoMakie\n\nps = Dict(\n    1 => 1:0.1:30,\n    2 => 10:0.1:50,\n    3 => 1:0.01:10.0,\n)\npnames = Dict(1 => \"σ\", 2 => \"ρ\", 3 => \"β\")\n\nlims = ((-30, 30), (-30, 30), (0, 100))\n\nds = PredefinedDynamicalSystems.lorenz()\n\nu1 = [10,20,40.0]\nu3 = [20,10,40.0]\nu0s = [u1, u3]\n\nfig, dsobs = interactive_trajectory(\n    ds, u0s; parameter_sliders = ps, pnames, lims\n)\n\nfig","category":"page"},{"location":"visualizations/","page":"Animations, GUIs, Visuals","title":"Animations, GUIs, Visuals","text":"If now one interactively clicked (if using GLMakie) the parameter sliders and then update, the system parameters would be updated accordingly. We can also add new plot elements that depend on the parameter values using the dsobs:","category":"page"},{"location":"visualizations/","page":"Animations, GUIs, Visuals","title":"Animations, GUIs, Visuals","text":"# Fixed points of the lorenz system (without the origin)\nlorenz_fixedpoints(ρ,β) = [\n    Point3f(sqrt(β*(ρ-1)), sqrt(β*(ρ-1)), ρ-1),\n    Point3f(-sqrt(β*(ρ-1)), -sqrt(β*(ρ-1)), ρ-1),\n]\n\n# add an observable trigger to the system parameters\nfpobs = map(dsobs.param_observable) do params\n    σ, ρ, β = params\n    return lorenz_fixedpoints(ρ, β)\nend\n\n# If we want to plot directly on the trajectory axis, we need to\n# extract it from the figure. The first entry of the figure is a grid layout\n# containing the axis and the GUI controls. The [1,1] entry of the layout\n# is the axis containing the trajectory plot\n\nax = content(fig[1,1][1,1])\nscatter!(ax, fpobs; markersize = 10, marker = :diamond, color = :red)\n\nfig","category":"page"},{"location":"visualizations/","page":"Animations, GUIs, Visuals","title":"Animations, GUIs, Visuals","text":"Now, after the live animation \"run\" button is pressed, we can interactively change the parameter ρ and click update, in which case both the dynamical system's ρ parameter will change, but also the location of the red diamonds.","category":"page"},{"location":"visualizations/","page":"Animations, GUIs, Visuals","title":"Animations, GUIs, Visuals","text":"We can also change the parameters non-interactively using set_parameter!","category":"page"},{"location":"visualizations/","page":"Animations, GUIs, Visuals","title":"Animations, GUIs, Visuals","text":"set_parameter!(dsobs, 2, 50.0)\n\nfig","category":"page"},{"location":"visualizations/","page":"Animations, GUIs, Visuals","title":"Animations, GUIs, Visuals","text":"set_parameter!(dsobs, 2, 10.0)\n\nfig","category":"page"},{"location":"visualizations/","page":"Animations, GUIs, Visuals","title":"Animations, GUIs, Visuals","text":"Note that the sliders themselves did not change, as this functionality is for \"offline\" creation of animations where one doesn't interact with sliders. The keyword add_controls should be given as false in such scenarios.","category":"page"},{"location":"visualizations/#Example-3:-Observed-timeseries-of-the-system","page":"Animations, GUIs, Visuals","title":"Example 3: Observed timeseries of the system","text":"","category":"section"},{"location":"visualizations/","page":"Animations, GUIs, Visuals","title":"Animations, GUIs, Visuals","text":"using DynamicalSystems, CairoMakie\nusing LinearAlgebra: norm, dot\n\n# Dynamical system and initial conditions\nds = Systems.thomas_cyclical(b = 0.2)\nu0s = ([3, 1, 1.], [1, 3, 1.], [1, 1, 3.])\n\n# Observables we get timeseries of:\nf1 = 3\nf2 = function distance_from_symmetry(u)\n    v = SVector{3}(1/√3, 1/√3, 1/√3)\n    t = dot(v, u)\n    return norm(u - t*v)\nend\nfs = [f1, f2]\n\nfig, dsobs = interactive_trajectory_timeseries(ds, fs, u0s;\n    idxs = [1, 2], timeseries_names = [\"x3\", \"dist. symm.\"],\n    timeseries_ylims = [(-2, 4), (0, 5)],\n    lims = ((-2, 4), (-2, 4)),\n    Δt = 0.05, tail = 500,\n    add_controls = false\n)\n\nfig","category":"page"},{"location":"visualizations/","page":"Animations, GUIs, Visuals","title":"Animations, GUIs, Visuals","text":"we can progress the simulation:","category":"page"},{"location":"visualizations/","page":"Animations, GUIs, Visuals","title":"Animations, GUIs, Visuals","text":"step!(dsobs, 200)\nfig","category":"page"},{"location":"visualizations/","page":"Animations, GUIs, Visuals","title":"Animations, GUIs, Visuals","text":"or we can even make a nice video out of it:","category":"page"},{"location":"visualizations/","page":"Animations, GUIs, Visuals","title":"Animations, GUIs, Visuals","text":"\nrecord(fig, \"thomas_cycl.mp4\", 1:100) do i\n    step!(dsobs, 10)\nend","category":"page"},{"location":"visualizations/","page":"Animations, GUIs, Visuals","title":"Animations, GUIs, Visuals","text":"<video width=\"auto\" controls autoplay loop>\n<source src=\"../thomas_cycl.mp4\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"visualizations/#Cobweb-Diagrams","page":"Animations, GUIs, Visuals","title":"Cobweb Diagrams","text":"","category":"section"},{"location":"visualizations/","page":"Animations, GUIs, Visuals","title":"Animations, GUIs, Visuals","text":"<video width=\"100%\" height=\"auto\" controls autoplay loop>\n<source src=\"https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/interact/cobweb.mp4?raw=true\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"visualizations/","page":"Animations, GUIs, Visuals","title":"Animations, GUIs, Visuals","text":"interactive_cobweb","category":"page"},{"location":"visualizations/#DynamicalSystems.interactive_cobweb","page":"Animations, GUIs, Visuals","title":"DynamicalSystems.interactive_cobweb","text":"interactive_cobweb(ds::DiscreteDynamicalSystem, prange, O::Int = 3; kwargs...)\n\nLaunch an interactive application for exploring cobweb diagrams of 1D discrete dynamical systems. Two slides control the length of the plotted trajectory and the current parameter value. The parameter values are obtained from the given prange.\n\nIn the cobweb plot, higher order iterates of the dynamic rule f are plotted as well, starting from order 1 all the way to the given order O. Both the trajectory in the cobweb, as well as any iterate f can be turned off by using some of the buttons.\n\nKeywords\n\nfkwargs = [(linewidth = 4.0, color = randomcolor()) for i in 1:O]: plotting keywords for each of the plotted iterates of f\ntrajcolor = :black: color of the trajectory\npname = \"p\": name of the parameter slider\npindex = 1: parameter index\nxmin = 0, xmax = 1: limits the state of the dynamical system can take\nTmax = 1000: maximum trajectory length\nx0s = range(xmin, xmax; length = 101): Possible values for the x0 slider.\n\n\n\n\n\n","category":"function"},{"location":"visualizations/","page":"Animations, GUIs, Visuals","title":"Animations, GUIs, Visuals","text":"The animation at the top of this section was done with","category":"page"},{"location":"visualizations/","page":"Animations, GUIs, Visuals","title":"Animations, GUIs, Visuals","text":"using DynamicalSystems, GLMakie\n\n# the second range is a convenience for intermittency example of logistic\nrrange = 1:0.001:4.0\n# rrange = (rc = 1 + sqrt(8); [rc, rc - 1e-5, rc - 1e-3])\n\nlo = Systems.logistic(0.4; r = rrange[1])\ninteractive_cobweb(lo, rrange, 5)","category":"page"},{"location":"visualizations/#Orbit-Diagrams","page":"Animations, GUIs, Visuals","title":"Orbit Diagrams","text":"","category":"section"},{"location":"visualizations/","page":"Animations, GUIs, Visuals","title":"Animations, GUIs, Visuals","text":"Notice that orbit diagrams and bifurcation diagrams are different things in DynamicalSystems.jl","category":"page"},{"location":"visualizations/","page":"Animations, GUIs, Visuals","title":"Animations, GUIs, Visuals","text":"<video width=\"100%\" height=\"auto\" controls autoplay loop>\n<source src=\"https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/interact/odhenon.mp4?raw=true\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"visualizations/","page":"Animations, GUIs, Visuals","title":"Animations, GUIs, Visuals","text":"interactive_orbitdiagram\nscaleod","category":"page"},{"location":"visualizations/#DynamicalSystems.interactive_orbitdiagram","page":"Animations, GUIs, Visuals","title":"DynamicalSystems.interactive_orbitdiagram","text":"interactive_orbitdiagram(\n    ds::DynamicalSystem, p_index, pmin, pmax, i::Int = 1;\n    u0 = nothing, parname = \"p\", title = \"\"\n)\n\nOpen an interactive application for exploring orbit diagrams (ODs) of discrete time dynamical systems. Requires DynamicalSystems.\n\nIn essense, the function presents the output of orbitdiagram of the ith variable of the ds, and allows interactively zooming into it.\n\nKeywords control the name of the parameter, the initial state (used for any parameter) or whether to add a title above the orbit diagram.\n\nInteraction\n\nThe application is separated in the \"OD plot\" (left) and the \"control panel\" (right). On the OD plot you can interactively click and drag with the left mouse button to select a region in the OD. This region is then re-computed at a higher resolution.\n\nThe options at the control panel are straight-forward, with\n\nn amount of steps recorded for the orbit diagram (not all are in the zoomed region!)\nt transient steps before starting to record steps\nd density of x-axis (the parameter axis)\nα alpha value for the plotted points.\n\nNotice that at each update n*t*d steps are taken. You have to press update after changing these parameters. Press reset to bring the OD in the original state (and variable). Pressing back will go back through the history of your exploration History is stored when the \"update\" button is pressed or a region is zoomed in.\n\nYou can even decide which variable to get the OD for by choosing one of the variables from the wheel! Because the y-axis limits can't be known when changing variable, they reset to the size of the selected variable.\n\nAccessing the data\n\nWhat is plotted on the application window is a true orbit diagram, not a plotting shorthand. This means that all data are obtainable and usable directly. Internally we always scale the orbit diagram to [0,1]² (to allow Float64 precision even though plotting is Float32-based). This however means that it is necessary to transform the data in real scale. This is done through the function scaleod which accepts the 5 arguments returned from the current function:\n\nfigure, oddata = interactive_orbitdiagram(...)\nps, us = scaleod(oddata)\n\n\n\n\n\n","category":"function"},{"location":"visualizations/#DynamicalSystems.scaleod","page":"Animations, GUIs, Visuals","title":"DynamicalSystems.scaleod","text":"scaleod(oddata) -> ps, us\n\nGiven the return values of interactive_orbitdiagram, produce orbit diagram data scaled correctly in data units. Return the data as a vector of parameter values and a vector of corresponding variable values.\n\n\n\n\n\n","category":"function"},{"location":"visualizations/","page":"Animations, GUIs, Visuals","title":"Animations, GUIs, Visuals","text":"The animation at the top of this section was done with","category":"page"},{"location":"visualizations/","page":"Animations, GUIs, Visuals","title":"Animations, GUIs, Visuals","text":"i = p_index = 1\nds, p_min, p_max, parname = Systems.henon(), 0.8, 1.4, \"a\"\nt = \"orbit diagram for the Hénon map\"\n\noddata = interactive_orbitdiagram(ds, p_index, p_min, p_max, i;\n                                  parname = parname, title = t)\n\nps, us = scaleod(oddata)","category":"page"},{"location":"visualizations/#Interactive-Poincaré-Surface-of-Section","page":"Animations, GUIs, Visuals","title":"Interactive Poincaré Surface of Section","text":"","category":"section"},{"location":"visualizations/","page":"Animations, GUIs, Visuals","title":"Animations, GUIs, Visuals","text":"<video width=\"100%\" height=\"auto\" controls autoplay loop>\n<source src=\"https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/interact/interactive_psos.mp4?raw=true\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"visualizations/","page":"Animations, GUIs, Visuals","title":"Animations, GUIs, Visuals","text":"interactive_poincaresos","category":"page"},{"location":"visualizations/#DynamicalSystems.interactive_poincaresos","page":"Animations, GUIs, Visuals","title":"DynamicalSystems.interactive_poincaresos","text":"interactive_poincaresos(cds, plane, idxs, complete; kwargs...)\n\nLaunch an interactive application for exploring a Poincaré surface of section (PSOS) of the continuous dynamical system cds. Requires DynamicalSystems.\n\nThe plane can only be the Tuple type accepted by DynamicalSystems.poincaresos, i.e. (i, r) for the ith variable crossing the value r. idxs gives the two indices of the variables to be displayed, since the PSOS plot is always a 2D scatterplot. I.e. idxs = (1, 2) will plot the 1st versus 2nd variable of the PSOS. It follows that plane[1] ∉ idxs must be true.\n\ncomplete is a three-argument function that completes the new initial state during interactive use, see below.\n\nThe function returns: figure, laststate with the latter being an observable containing the latest initial state.\n\nKeyword Arguments\n\ndirection, rootkw : Same use as in DynamicalSystems.poincaresos.\ntfinal = (1000.0, 10.0^4) : A 2-element tuple for the range of values for the total integration time (chosen interactively).\ncolor : A function of the system's initial condition, that returns a color to plot the new points with. The color must be RGBf/RGBAf.  A random color is chosen by default.\nlabels = (\"u₁\" , \"u₂\") : Scatter plot labels.\nscatterkwargs = (): Named tuple of keywords passed to scatter.\ndiffeq = NamedTuple() : Any extra keyword arguments are passed into init of DiffEq.\n\nInteraction\n\nThe application is a standard scatterplot, which shows the PSOS of the system, initially using the system's u0. Two sliders control the total evolution time and the size of the marker points (which is always in pixels).\n\nUpon clicking within the bounds of the scatter plot your click is transformed into a new initial condition, which is further evolved and its PSOS is computed and then plotted into the scatter plot.\n\nYour click is transformed into a full D-dimensional initial condition through the function complete. The first two arguments of the function are the positions of the click on the PSOS. The third argument is the value of the variable the PSOS is defined on. To be more exact, this is how the function is called:\n\nx, y = mouseclick; z = plane[2]\nnewstate = complete(x, y, z)\n\nThe complete function can throw an error for ill-conditioned x, y, z. This will be properly handled instead of breaking the application. This newstate is also given to the function color that gets a new color for the new points.\n\n\n\n\n\n","category":"function"},{"location":"visualizations/","page":"Animations, GUIs, Visuals","title":"Animations, GUIs, Visuals","text":"To generate the animation at the start of this section you can run","category":"page"},{"location":"visualizations/","page":"Animations, GUIs, Visuals","title":"Animations, GUIs, Visuals","text":"using InteractiveDynamics, GLMakie, OrdinaryDiffEq, DynamicalSystems\ndiffeq = (alg = Vern9(), abstol = 1e-9, reltol = 1e-9)\n\nhh = Systems.henonheiles()\n\npotential(x, y) = 0.5(x^2 + y^2) + (x^2*y - (y^3)/3)\nenergy(x,y,px,py) = 0.5(px^2 + py^2) + potential(x,y)\nconst E = energy(get_state(hh)...)\n\nfunction complete(y, py, x)\n    V = potential(x, y)\n    Ky = 0.5*(py^2)\n    Ky + V ≥ E && error(\"Point has more energy!\")\n    px = sqrt(2(E - V - Ky))\n    ic = [x, y, px, py]\n    return ic\nend\n\nplane = (1, 0.0) # first variable crossing 0\n\n# Coloring points using the Lyapunov exponent\nfunction λcolor(u)\n    λ = lyapunovs(hh, 4000; u0 = u)[1]\n    λmax = 0.1\n    return RGBf(0, 0, clamp(λ/λmax, 0, 1))\nend\n\nstate, scene = interactive_poincaresos(hh, plane, (2, 4), complete;\nlabels = (\"q₂\" , \"p₂\"),  color = λcolor, diffeq...)","category":"page"},{"location":"visualizations/#Scanning-a-Poincaré-Surface-of-Section","page":"Animations, GUIs, Visuals","title":"Scanning a Poincaré Surface of Section","text":"","category":"section"},{"location":"visualizations/","page":"Animations, GUIs, Visuals","title":"Animations, GUIs, Visuals","text":"<video width=\"100%\" height=\"auto\" controls autoplay loop>\n<source src=\"https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/interact/psos_brainscan.mp4?raw=true\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"visualizations/","page":"Animations, GUIs, Visuals","title":"Animations, GUIs, Visuals","text":"interactive_poincaresos_scan","category":"page"},{"location":"visualizations/#DynamicalSystems.interactive_poincaresos_scan","page":"Animations, GUIs, Visuals","title":"DynamicalSystems.interactive_poincaresos_scan","text":"interactive_poincaresos_scan(A::StateSpaceSet, j::Int; kwargs...)\ninteractive_poincaresos_scan(As::Vector{StateSpaceSet}, j::Int; kwargs...)\n\nLaunch an interactive application for scanning a Poincare surface of section of A like a \"brain scan\", where the plane that defines the section can be arbitrarily moved around via a slider. Return figure, ax3D, ax2D.\n\nThe input dataset must be 3 dimensional, and here the crossing plane is always chosen to be when the j-th variable of the dataset crosses a predefined value. The slider automatically gets all possible values the j-th variable can obtain.\n\nIf given multiple datasets, the keyword colors attributes a color to each one, e.g. colors = [JULIADYNAMICS_COLORS[mod1(i, 6)] for i in 1:length(As)].\n\nThe keywords linekw, scatterkw are named tuples that are propagated as keyword arguments to the line and scatter plot respectively, while the keyword direction = -1 is propagated to the function DyamicalSystems.poincaresos.\n\n\n\n\n\n","category":"function"},{"location":"visualizations/","page":"Animations, GUIs, Visuals","title":"Animations, GUIs, Visuals","text":"The animation at the top of this page was done with","category":"page"},{"location":"visualizations/","page":"Animations, GUIs, Visuals","title":"Animations, GUIs, Visuals","text":"using GLMakie, DynamicalSystems\nusing OrdinaryDiffEq: Vern9\n\ndiffeq = (alg = Vern9(), abstol = 1e-9, reltol = 1e-9)\nds = PredefinedDynamicalSystems.henonheiles()\nds = CoupledODEs(ds, diffeq)\n\nu0s = [\n    [0.0, -0.25, 0.42081, 0.0],\n    [0.0, 0.1, 0.5, 0.0],\n    [0.0, -0.31596, 0.354461, 0.0591255]\n]\n# inputs\ntrs = [trajectory(ds, 10000, u0)[1][:, SVector(1,2,3)] for u0 ∈ u0s]\nj = 2 # the dimension of the plane\n\ninteractive_poincaresos_scan(trs, j; linekw = (transparency = true,))","category":"page"},{"location":"contributors_guide/#Contributor-Guide","page":"Contributor Guide","title":"Contributor Guide","text":"","category":"section"},{"location":"contributors_guide/","page":"Contributor Guide","title":"Contributor Guide","text":"TL;DR: To contribute via pull requests you can check issues that have labels \"wanted feature\" or \"good first issue\" in the GitHub repositories of the subpackages of DynamicalSystems.jl","category":"page"},{"location":"contributors_guide/","page":"Contributor Guide","title":"Contributor Guide","text":"","category":"page"},{"location":"contributors_guide/","page":"Contributor Guide","title":"Contributor Guide","text":"The ultimate goal for DynamicalSystems.jl is to be a useful library for scientists working on nonlinear dynamics and to make nonlinear dynamics accessible and reproducible.","category":"page"},{"location":"contributors_guide/","page":"Contributor Guide","title":"Contributor Guide","text":"Of course, for such an ambitious goal to be achieved, many of us should try to work together to improve the library! If you want to help the cause, there are many ways to contribute to the DynamicalSystems.jl library:","category":"page"},{"location":"contributors_guide/","page":"Contributor Guide","title":"Contributor Guide","text":"Just use it. If you encountered unexpected behavior simply report it either on our gitter chatroom or using the DynamicalSystems.jl Issues page.\nSuggest methods that you think should be included in our library. This should be done by opening a new issue that describes the method, gives references to papers using the method and also justifies why the method should be included.\nContribute code by solving issues. The easiest issues to tackle are the ones with label \"good first issue\".\nContribute code by implementing new methods! That is the most awesome way to contribute! The individual packages that compose DynamicalSystems.jl have plenty of issues with the tag \"wanted feature\", which can get you started on a big contribution!\nContribute code by defining a new pre-defined dynamical system that you found useful.","category":"page"},{"location":"contributors_guide/#Contributing-Code","page":"Contributor Guide","title":"Contributing Code","text":"","category":"section"},{"location":"contributors_guide/","page":"Contributor Guide","title":"Contributor Guide","text":"When contributing code, you should keep these things in mind:","category":"page"},{"location":"contributors_guide/","page":"Contributor Guide","title":"Contributor Guide","text":"In general, the speed of the implementation is important, but not as important as the clarity of the implementation. One of cornerstones of all of DynamicalSystems.jl is to have clear and readable source code. Fortunately, Julia allows you to have perfectly readable code but also super fast ;) If necessary add comments to the code, so that somebody that knows the method, can also understand the code immediately.\nTry to design general, extendable functions instead of unnecessarily specialized to the case at hand.\nFor the documentation strings of new methods and systems please follow the convention of the documentation strings of DynamicalSystems.jl. Specifically, the first section should describe the function in a couple of sentences, its positional arguments and its return value. The next section ## Keyword Arguments describes the keywords. The next section ## Description describes the algorithm in detail if need be. Lastly, papers that are relevant to the method must be cited. Have a look at the documentation strings of lyapunov and lyapunovspectrum to get an idea.","category":"page"},{"location":"contributors_guide/#Documentation-string-style","page":"Contributor Guide","title":"Documentation string style","text":"","category":"section"},{"location":"contributors_guide/","page":"Contributor Guide","title":"Contributor Guide","text":"Documentation strings are the most important thing in your pull request/code. The number 1 priority of DynamicalSystems.jl is highest possible quality of documentation and utmost transparency, and the best way to achieve this is with good documentation strings. In DynamicalSystems.jl we recommend that documentation strings are structured in the following way (and this is also the recommendation we give in the Good Scientific Code Workshop).","category":"page"},{"location":"contributors_guide/","page":"Contributor Guide","title":"Contributor Guide","text":"Clear call signature in code syntax, including expected input types if necessary. The call signature should ONLY include only the most important information, not list out in detail every keyword!\nBrief summary of the function\n[Optional] Return value and type if not obvious\n[Optional] References to related functions if sensible\n[Optional] Keyword arguments list if the function has some\n[Optional] Detailed discussion of functionality if function behavior is scientifically involved\n[Optional] Citations to relevant scientific papers!","category":"page"},{"location":"contributors_guide/","page":"Contributor Guide","title":"Contributor Guide","text":"The syntax of the documentation strings follows Documenter.jl protocol. Please see the documentation string of the lyapunov function and use the same structure.","category":"page"},{"location":"contents/#contents","page":"Contents","title":"Contents","text":"","category":"section"},{"location":"contents/","page":"Contents","title":"Contents","text":"When you do using DynamicalSystems in your Julia session, the module re-exports and brings into scope all submodules (Julia packages) that compose DynamicalSystems.jl. These are listed in this page. Of course, you could be using these packages directly instead of adding DynamicalSystems. However, doing using DynamicalSystems provides the environment all these packages were designed to work together in, and so we recommend to simply install DynamicalSystems and use that.","category":"page"},{"location":"contents/#Exported-submodules","page":"Contents","title":"Exported submodules","text":"","category":"section"},{"location":"contents/","page":"Contents","title":"Contents","text":"The submodules that compose DynamicalSystems.jl are the following packages, which are re-exported by DynamicalSystems:","category":"page"},{"location":"contents/","page":"Contents","title":"Contents","text":"Core","category":"page"},{"location":"contents/","page":"Contents","title":"Contents","text":"StateSpaceSets\nDynamicalSystemsBase","category":"page"},{"location":"contents/","page":"Contents","title":"Contents","text":"For observed/measured data","category":"page"},{"location":"contents/","page":"Contents","title":"Contents","text":"ComplexityMeasures\nRecurrenceAnalysis\nDelayEmbeddings\nFractalDimensions\nTimeseriesSurrogates","category":"page"},{"location":"contents/","page":"Contents","title":"Contents","text":"For dynamical system instances","category":"page"},{"location":"contents/","page":"Contents","title":"Contents","text":"PredefinedDynamicalSystems\nChaosTools\nAttractors","category":"page"},{"location":"contents/","page":"Contents","title":"Contents","text":"At the very end of this page, a full list of exported names is presented.","category":"page"},{"location":"contents/#Core","page":"Contents","title":"Core","text":"","category":"section"},{"location":"contents/","page":"Contents","title":"Contents","text":"StateSpaceSets\r\nDynamicalSystemsBase","category":"page"},{"location":"contents/#StateSpaceSets.StateSpaceSets","page":"Contents","title":"StateSpaceSets.StateSpaceSets","text":"StateSpaceSets.jl\n\n(Image: ) (Image: ) (Image: ) (Image: CI) (Image: codecov) (Image: Package Downloads)\n\nA Julia package that provides functionality for state space sets. These are collections of points of fixed, and known by type, size (called dimension). It is used in several projects in the JuliaDynamics organization, such as DynamicalSystems.jl or CausalityTools.jl.\n\nThe main export of StateSpaceSets is the concrete type StateSpaceSet. The package also provides functionality for distances, neighbor searches, sampling, and normalization.\n\nTo install it you may run import Pkg; Pkg.add(\"StateSpaceSets\"), however, there is no real reason to install this package directly as it is re-exported by all downstream packages that use it.\n\npreviously StateSpaceSets.jl was part of DelayEmbeddings.jl\n\n\n\n\n\n","category":"module"},{"location":"contents/#DynamicalSystemsBase.DynamicalSystemsBase","page":"Contents","title":"DynamicalSystemsBase.DynamicalSystemsBase","text":"DynamicalSystemsBase.jl\n\n(Image: ) (Image: ) (Image: ) (Image: CI) (Image: codecov) (Image: Package Downloads)\n\nA Julia package that defines the DynamicalSystem interface and many concrete implementations used in the DynamicalSystems.jl ecosystem.\n\nTo install it, run import Pkg; Pkg.add(\"DynamicalSystemsBase\"). Typically, you do not want to use DynamicalSystemsBase directly, as downstream analysis packages re-export it.\n\nAll further information is provided in the documentation, which you can either find online or build locally by running the docs/make.jl file.\n\n\n\n\n\n","category":"module"},{"location":"contents/#For-observed/measured-data","page":"Contents","title":"For observed/measured data","text":"","category":"section"},{"location":"contents/","page":"Contents","title":"Contents","text":"ComplexityMeasures\r\nRecurrenceAnalysis\r\nDelayEmbeddings\r\nFractalDimensions\r\nTimeseriesSurrogates","category":"page"},{"location":"contents/#ComplexityMeasures.ComplexityMeasures","page":"Contents","title":"ComplexityMeasures.ComplexityMeasures","text":"ComplexityMeasures.jl\n\n(Image: Docs) (Image: CI) (Image: codecov) (Image: Package Downloads) (Image: Package Downloads) (Image: DOI)\n\nA Julia package that provides estimators for probabilities, entropies, and other complexity measures, in the context of nonlinear dynamics, nonlinear timeseries analysis, and complex systems. It can be used as a standalone package, or as part of other projects in the JuliaDynamics organization, such as DynamicalSystems.jl or CausalityTools.jl.\n\nTo install it, run import Pkg; Pkg.add(\"ComplexityMeasures\").\n\nAll further information is provided in the documentation, which you can either find online or build locally by running the docs/make.jl file.\n\nPreviously, this package was called Entropies.jl.\n\n\n\n\n\n","category":"module"},{"location":"contents/#RecurrenceAnalysis.RecurrenceAnalysis","page":"Contents","title":"RecurrenceAnalysis.RecurrenceAnalysis","text":"RecurrenceAnalysis.jl\n\n(Image: ) (Image: ) (Image: CI) (Image: codecov) (Image: Package Downloads)\n\nA Julia module that offers tools for computing Recurrence Plots and exploring them within the framework of Recurrence Quantification Analysis and Recurrence Network Analysis. It can be used as a standalone package, or as part of DynamicalSystems.jl.\n\nTo install it, run import Pkg; Pkg.add(\"RecurrenceAnalysis\").\n\nAll further information is provided in the documentation, which you can either find online or build locally by running the docs/make.jl file.\n\n\n\n\n\n","category":"module"},{"location":"contents/#DelayEmbeddings.DelayEmbeddings","page":"Contents","title":"DelayEmbeddings.DelayEmbeddings","text":"DelayEmbeddings.jl\n\n(Image: ) (Image: ) (Image: ) (Image: CI) (Image: codecov) (Image: Package Downloads)\n\nA Julia package that provides a generic interface for performing delay coordinate embeddings, as well as cutting edge algorithms for creating optimal embeddings given some data. It can be used as a standalone package, or as part of DynamicalSystems.jl.\n\nTo install it, run import Pkg; Pkg.add(\"DelayEmbeddings\").\n\nAll further information is provided in the documentation, which you can either find online or build locally by running the docs/make.jl file.\n\n\n\n\n\n","category":"module"},{"location":"contents/#FractalDimensions.FractalDimensions","page":"Contents","title":"FractalDimensions.FractalDimensions","text":"FractalDimensions.jl\n\n(Image: ) (Image: ) (Image: ) (Image: CI) (Image: codecov) (Image: Package Downloads)\n\nA Julia package that estimates various definitions of fractal dimension from data. It can be used as a standalone package, or as part of DynamicalSystems.jl.\n\nTo install it, run import Pkg; Pkg.add(\"FractalDimensions\").\n\nAll further information is provided in the documentation, which you can either find online or build locally by running the docs/make.jl file.\n\nPreviously, this package was part of ChaosTools.jl.\n\nCitation\n\nIf you use this package in a publication, please cite the paper below:\n\n@ARTICLE{FractalDimensions.jl,\n  title     = \"Estimating the fractal dimension: a comparative review and open\n               source implementations\",\n  author    = \"Datseris, George and Kottlarz, Inga and Braun, Anton P and\n               Parlitz, Ulrich\",\n  publisher = \"arXiv\",\n  year      =  2021,\n  doi = {10.48550/ARXIV.2109.05937},\n  url = {https://arxiv.org/abs/2109.05937},\n}\n\n\n\n\n\n","category":"module"},{"location":"contents/#TimeseriesSurrogates.TimeseriesSurrogates","page":"Contents","title":"TimeseriesSurrogates.TimeseriesSurrogates","text":"TimeseriesSurrogates.jl\n\n(Image: ) (Image: ) (Image: ) (Image: CI) (Image: codecov) (Image: Package Downloads)\n\nA Julia package for generating timeseries surrogates. TimeseriesSurrogates.jl is the fastest and most featureful open source code for generating timeseries surrogates. It can be used as a standalone package, or as part of DynamicalSystems.jl.\n\nTo install it, run import Pkg; Pkg.add(\"TimeseriesSurrogates\").\n\nAll further information is provided in the documentation, which you can either find online or build locally by running the docs/make.jl file.\n\nCiting\n\nPlease use the following BiBTeX entry, or DOI, to cite TimeseriesSurrogates.jl:\n\nDOI: https://doi.org/10.21105/joss.04414\n\nBiBTeX:\n\n@article{TimeseriesSurrogates.jl,\n    doi = {10.21105/joss.04414},\n    url = {https://doi.org/10.21105/joss.04414},\n    year = {2022},\n    publisher = {The Open Journal},\n    volume = {7},\n    number = {77},\n    pages = {4414},\n    author = {Kristian Agasøster Haaga and George Datseris},\n    title = {TimeseriesSurrogates.jl: a Julia package for generating surrogate data},\n    journal = {Journal of Open Source Software}\n}\n\n\n\n\n\n","category":"module"},{"location":"contents/#For-dynamical-system-instances","page":"Contents","title":"For dynamical system instances","text":"","category":"section"},{"location":"contents/","page":"Contents","title":"Contents","text":"PredefinedDynamicalSystems\r\nChaosTools\r\nAttractors","category":"page"},{"location":"contents/#PredefinedDynamicalSystems.PredefinedDynamicalSystems","page":"Contents","title":"PredefinedDynamicalSystems.PredefinedDynamicalSystems","text":"PredefinedDynamicalSystems.jl\n\n(Image: ) (Image: CI) (Image: Package Downloads)\n\nModule which contains pre-defined dynamical systems that can be used by the DynamicalSystems.jl library. To install it, run import Pkg; Pkg.add(\"PredefinedDynamicalSystems\").\n\nPredefined systems exist as functions that return a DynamicalSystem instance. They are accessed like:\n\nds = PredefinedDynamicalSystems.lorenz(u0; ρ = 32.0)\n\nThe alias Systems is also exported as a deprecation.\n\nThis module is provided purely as a convenience. It does not have any actual tests, and it is not guaranteed to be stable in future versions. It is not recommended to use this module for anything else besides on-the-spot demonstrative examples.\n\nFor some systems, a Jacobian function is also defined. The naming convention for the Jacobian function is \\$(name)_jacob. So, for the above example we have J = Systems.lorenz_jacob.\n\nAll available systems are provided in the documentation, which you can either find online or build locally by running the docs/make.jl file.\n\n\n\n\n\n","category":"module"},{"location":"contents/#ChaosTools.ChaosTools","page":"Contents","title":"ChaosTools.ChaosTools","text":"ChaosTools.jl\n\n(Image: ) (Image: ) (Image: ) (Image: CI) (Image: codecov) (Image: Package Downloads)\n\nA Julia module that offers various tools for analysing nonlinear dynamics and chaotic behaviour. It can be used as a standalone package, or as part of DynamicalSystems.jl.\n\nTo install it, run import Pkg; Pkg.add(\"ChaosTools\").\n\nAll further information is provided in the documentation, which you can either find online or build locally by running the docs/make.jl file.\n\nChaosTools.jl is the jack-of-all-trades package of the DynamicalSystems.jl library: methods that are not extensive enough to be a standalone package are added here. You should see the full DynamicalSystems.jl library for other packages that may contain functionality you are looking for but did not find in ChaosTools.jl.\n\n\n\n\n\n","category":"module"},{"location":"contents/#Attractors.Attractors","page":"Contents","title":"Attractors.Attractors","text":"Attractors.jl\n\n(Image: ) (Image: ) (Image: Paper) (Image: CI) (Image: codecov) (Image: Package Downloads)\n\nA Julia module for\n\nfinding attractors of arbitrary dynamical systems\nfinding their basins of attraction or the state space fractions of the basins\n\"continuing\" the attractors and their basins over a parameter range\nfinding the basin boundaries and analyzing their fractal properties\ntipping points related functionality for systems with known dynamic rule\nand more!\n\nIt can be used as a standalone package, or as part of DynamicalSystems.jl.\n\nTo install it, run import Pkg; Pkg.add(\"Attractors\").\n\nAll further information is provided in the documentation, which you can either find online or build locally by running the docs/make.jl file.\n\nPreviously, Attractors.jl was part of ChaosTools.jl\n\n\n\n\n\n","category":"module"},{"location":"contents/#All-exported-names","page":"Contents","title":"All exported names","text":"","category":"section"},{"location":"contents/","page":"Contents","title":"Contents","text":"This section lists all exported names of the DynamicalSystems.jl library. We do not list their documentation in any way here. This list is only meant as a quantitative listing of features, as well as perhaps helping searching via the search bar. To actually learn how to use all these exported names you need to use above-linked documentation of the respective submodules!","category":"page"},{"location":"contents/","page":"Contents","title":"Contents","text":"The total exported names are:","category":"page"},{"location":"contents/","page":"Contents","title":"Contents","text":"using DynamicalSystems\r\nall_exported_names = names(DynamicalSystems)\r\nlength(all_exported_names)","category":"page"},{"location":"contents/","page":"Contents","title":"Contents","text":"And they are:","category":"page"},{"location":"contents/","page":"Contents","title":"Contents","text":"using DisplayAs\r\nDisplayAs.unlimited(all_exported_names)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"DynamicalSystems","category":"page"},{"location":"#DynamicalSystems","page":"Introduction","title":"DynamicalSystems","text":"(Image: DynamicalSystems.jl logo: The Double Pendulum)\n\n(Image: ) (Image: DocBuild) (Image: DOI) (Image: Textbook) (Image: Package Downloads)\n\nDynamicalSystems.jl is an award-winning Julia software library for nonlinear dynamics and nonlinear timeseries analysis. The current repository holds the documentation and exports all packages composing DynamicalSystems.jl.\n\nTo install it, run import Pkg; Pkg.add(\"DynamicalSystems\").\n\nDynamicalSystems.jl is part of JuliaDynamics, an organization dedicated to creating high quality scientific software.\n\nAll further information is provided in the documentation, which you can either find online or build locally by running the docs/make.jl file.\n\n\n\n\n\n","category":"module"},{"location":"","page":"Introduction","title":"Introduction","text":"tip: Star us on GitHub!\nIf you have found this library useful, please consider starring it on GitHub. This gives us an accurate lower bound of the (satisfied) user count.","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Welcome to the documentation of DynamicalSystems.jl!","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"If you have not used the library before, and would like to get started, then please read the overarching tutorial for the library.\nThe contents page gives a summary of all packages that are part of the library.\nSee the learning resources below to find out more resources about learning the library and using it in scientific research and/or education.\nBesides the formal algorithmic/scientific content of DynamicalSystems.jl (those in the contents) page, the library also provides an extensive suite for interactive or offline animations and visualizations dynamical systems. These are found in the visualizations page.\nThe remaining of this introduction page discusses our goals with the library, how to participate as a user or developer, how to cite, and other relevant information (see the sections of the sidebar on the left).","category":"page"},{"location":"#Latest-news","page":"Introduction","title":"Latest news","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"DynamicalSystems.jl moved to Julia 1.9+, and now exports visualization and interactive applications automatically once Makie (or Makie backends such as GLMakie) come into scope, using the new package extension system.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The package InteractiveDynamics.jl is now obsolete.","category":"page"},{"location":"#learning","page":"Introduction","title":"Learning resources","text":"","category":"section"},{"location":"#Textbook-with-DynamicalSystems.jl","page":"Introduction","title":"Textbook with DynamicalSystems.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"We have written an undergraduate level textbook as an introduction to nonlinear dynamics. The text is written in an applied, hands-on manner, while still covering all fundamentals. The book pages are interlaced with real Julia code that uses DynamicalSystems.jl and is published in the Undergraduate Lecture Notes in Physics by Springer Nature:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Nonlinear Dynamics: A concise introduction interlaced with code by G. Datseris & U. Parlitz.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Additional textbooks on nonlinear dynamics worth having a look are:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Chaos in Dynamical Systems - E. Ott\nNonlinear Time series Analysis - H. Kantz & T. Schreiber","category":"page"},{"location":"#Course-on-applied-nonlinear-dynamics-and-complex-systems","page":"Introduction","title":"Course on applied nonlinear dynamics and complex systems","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"We are developing a full course (targeting a graduate or undergraduate semester long course) on applied nonlinear dynamics, nonlinear timeseries analysis, and complex systems, using the packages of JuliaDynamics. DynamicalSystems.jl is part of this course.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The materials of the course are on GitHub: https://github.com/JuliaDynamics/NonlinearDynamicsComplexSystemsCourses","category":"page"},{"location":"#goals","page":"Introduction","title":"Our Goals","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"DynamicalSystems.jl was created with three goals in mind. The first was to fill the missing gap of a high quality and general purpose software for nonlinear dynamics, which can make the field of nonlinear dynamics accessible and reproducible. The second goal was to create a useful library where students and scientists from different fields may come and learn about methods of nonlinear dynamics.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The third goal was to fundamentally change the perception of the role of code in both scientific education as well as research. It is rarely the case that real, runnable code is shown in the classroom, because it is often long and messy. This is especially hurtful for nonlinear dynamics, a field where computer-assisted exploration is critical. And published work in this field fares even worse, with the overwhelming majority of published research not sharing the code used to create the paper. This makes reproducing these papers difficult, while some times straight-out impossible.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"To achieve these goals we made DynamicalSystems.jl so that it is:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Transparent: extra care is taken so that the source code of all functions is clear and easy to follow, while remaining as small and concise as possible.\nIntuitive: a software simple to use and understand makes experimentation easier.\nEasy to extend: this makes contributions more likely, and can motivate researchers to implement their method here, instead of leaving it in a cryptic script stored in some data server, never-to-be-published with the paper.\nReliable: the algorithm implementations are tested extensively.\nWell-documented: all implemented algorithms provide a high-level scientific description of their functionality in their documentation string as well as references to scientific papers.\nGeneral: all algorithms work just as well with any system, whether it is a simple continuous chaotic system, like the Lorenz model, or a high dimensional discrete system like coupled standard maps.\nPerformant: written entirely in Julia, and taking advantage of some of the best packages within the language, DynamicalSystems.jl is really fast.","category":"page"},{"location":"#Citing","page":"Introduction","title":"Citing","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"There is a (small) paper associated with DynamicalSystems.jl. If we have helped you in research that led to a publication, please be kind enough to cite it, using the DOI 10.21105/joss.00598 or the following BiBTeX entry:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@article{Datseris2018,\n  doi = {10.21105/joss.00598},\n  url = {https://doi.org/10.21105/joss.00598},\n  year  = {2018},\n  month = {mar},\n  volume = {3},\n  number = {23},\n  pages = {598},\n  author = {George Datseris},\n  title = {DynamicalSystems.jl: A Julia software library for chaos and nonlinear dynamics},\n  journal = {Journal of Open Source Software}\n}","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"however, we would really appreciate it if you also cited the textbook we wrote that DynamicalSystems.jl accompanies:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@book{DatserisParlitz2022,\n  doi = {10.1007/978-3-030-91032-7},\n  url = {https://doi.org/10.1007/978-3-030-91032-7},\n  year = {2022},\n  publisher = {Springer Nature},\n  author = {George Datseris and Ulrich Parlitz},\n  title     = \"Nonlinear dynamics: A concise introduction interlaced with code\",\n  address   = \"Cham, Switzerland\",\n  language  = \"en\",\n}","category":"page"},{"location":"#Asking-questions","page":"Introduction","title":"Asking questions","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"There are three options for asking questions:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Join the official Julia discourse and ask a question under the category Specific Domains > Modelling & Simulations.\nJoin our channel #dynamics-bridged in the Julia Slack workplace.\nOpen an issue directly on the GitHub page of DynamicalSystems.jl while providing a Minimal Working Example.","category":"page"},{"location":"#Contributing-and-Donating","page":"Introduction","title":"Contributing & Donating","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Be sure to visit the Contributor Guide page, because you can help make this package better without having to write a single line of code! Also, if you find this package helpful please consider staring it on GitHub! This gives us an accurate lower bound of users that this package has already helped!","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Finally, you can donate for the development of DynamicalSystems.jl. You can do that by adding bounties to existing issues on the GitHub repositories (you can open new issues as well). Every issue has an automatic way to create a bounty using Bountysource, see the first comment of each issue.","category":"page"},{"location":"#Issues-with-Bounties","page":"Introduction","title":"Issues with Bounties","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Money that DynamicalSystems.jl obtains from awards, sponsors, or donators are converted into bounties for GitHub issues. The full list of issues that have a bounty is available here.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"By solving these issues you not only contribute to open source, but you also get some pocket money to boot :)","category":"page"},{"location":"#Maintainers-and-Contributors","page":"Introduction","title":"Maintainers and Contributors","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The DynamicalSystems.jl library is maintained by George Datseris, who is also curating and writing this documentation. The software code however is built from the contributions of several individuals. The list is too long to write and constantly update, so the best way to find out these contributions is to visit the GitHub page of each of the subpackages and checkout the \"contributors\" pages there.","category":"page"},{"location":"#Version-numbers","page":"Introduction","title":"Version numbers","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The version of DynamicalSystems by itself is a bit meaningless, because the module does not have any source code, besides re-exporting other modules. For transparency, the packages and versions used to build the documentation you are reading now are:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using CairoMakie, InteractiveDynamics, DynamicalSystems\ninclude(\"../style.jl\")","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using Pkg\nPkg.status([\n    \"DynamicalSystems\",\n    \"StateSpaceSets\", \"DynamicalSystemsBase\", \"RecurrenceAnalysis\", \"FractalDimensions\", \"DelayEmbeddings\", \"ComplexityMeasures\", \"TimeseriesSurrogates\", \"PredefinedDynamicalSystems\", \"Attractors\", \"ChaosTools\", \"CairoMakie\",\n    ];\n    mode = PKGMODE_MANIFEST\n)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"warn: Version numbers do not strictly follow SemVer2.0\nBecause of the nature of the DynamicalSystems.jl library, the exported API contains hundreds of algorithm implementations, most of which are independent of each other. Our development approach is that breaking changes to these individual algorithms (due to e.g., better API design or better performance implementations or better default keyword arguments) can be done without incrementing any major version numbers. We increment major version numbers only for breaking changes that have wide impact over most of the DynamicalSystems.jl library.","category":"page"},{"location":"#Other-NLD-relevant-packages","page":"Introduction","title":"Other NLD-relevant packages","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Besides DynamicalSystems.jl, the Julia programming language has a thriving ecosystem with plenty of functionality that is relevant for nonlinear dynamics. We list some useful references below:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"DifferentialEquations.jl - Besides providing solvers for standard ODE systems (infastructure already used in DynamicalSystems.jl), it also has much more features like SDE solvers or uncertainty quantification.\nDiffEqSensitivity.jl - Discrete and continuous local sensitivity analysis, i.e., derivatives of the solutions of ODEs, or functions of the solutions, versus parameters, hosting various forward and adjoint methods as well as methods tailored to chaotic systems.\nGlobalSensitivity.jl Global sensitivity analysis assessing the effect of any input variables over a larger domain on the output.\nBifurcationKit.jl - Featureful toolkit for automated bifurcation analysis.\nNetworkDynamics.jl - Package for easily simulating dynamics on networks and transforming network systems into ODEProblem (that can be made directly into a ContinuousDynamicalSystem).\nAgents.jl for agent based modelling.","category":"page"},{"location":"tutorial/#tutorial","page":"Overarching tutorial","title":"Overarching tutorial for DynamicalSystems.jl","text":"","category":"section"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"This page serves as a short, but to-the-point, introduction to the DynamicalSystems.jl library. It outlines the core components, and how they establish an interface that is used by the rest of the library. It also provides a couple of usage examples to connect the various packages of the library together.","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"Going through this tutorial should take you about 20 minutes.","category":"page"},{"location":"tutorial/#Installation","page":"Overarching tutorial","title":"Installation","text":"","category":"section"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"To install DynamicalSystems.jl, simply do:","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"using Pkg; Pkg.add(\"DynamicalSystems\")","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"As discussed in the contents page, this installs several packages for the Julia language, that are all exported under a common name. To use them, simply do:","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"using DynamicalSystems","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"in your Julia session.","category":"page"},{"location":"tutorial/#Core-components","page":"Overarching tutorial","title":"Core components","text":"","category":"section"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"The individual packages that compose DynamicalSystems interact flawlessly with each other because of the following two components:","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"The StateSpaceSet, which represents numerical data. They can be observed or measured from experiments, sampled trajectories of dynamical systems, or just unordered sets in a state space. A StateSpaceSet is a container of equally-sized points, representing multivariate timeseries or multivariate datasets. Timeseries, which are univariate sets, are represented by the AbstractVector{<:Real} Julia base type.\nThe DynamicalSystem, which is the abstract representation of a dynamical system with a known dynamic evolution rule. DynamicalSystem defines an extendable interface, but typically one uses concrete implementations such as DeterministicIteratedMap or CoupledODEs.","category":"page"},{"location":"tutorial/#Making-dynamical-systems","page":"Overarching tutorial","title":"Making dynamical systems","text":"","category":"section"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"In the majority of cases, to make a dynamical system one needs three things:","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"The dynamic rule f: A Julia function that provides the instructions of how to evolve the dynamical system in time.\nThe state u: An array-like container that contains the variables of the dynamical system and also defines the starting state of the system.\nThe parameters p: An arbitrary container that parameterizes f.","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"For most concrete implementations of DynamicalSystem there are two ways of defining f, u. The distinction is done on whether f is defined as an in-place (iip) function or out-of-place (oop) function.","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"oop : f must be in the form f(u, p, t) -> out   which means that given a state u::SVector{<:Real} and some parameter container   p it returns the output of f as an SVector{<:Real} (static vector).\niip : f must be in the form f!(out, u, p, t)   which means that given a state u::AbstractArray{<:Real} and some parameter container p,   it writes in-place the output of f in out::AbstractArray{<:Real}.   The function must return nothing as a final statement.","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"t stands for current time in both cases. iip is suggested for systems with high dimension and oop for small. The break-even point is between 10 to 100 dimensions but should be benchmarked on a case-by-case basis as it depends on the complexity of f.","category":"page"},{"location":"tutorial/#Example:-Henon-map","page":"Overarching tutorial","title":"Example: Henon map","text":"","category":"section"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"Let's make the Henon map, defined as","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"beginaligned\nx_n+1 = 1 - ax^2_n+y_n \ny_n+1  = bx_n\nendaligned","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"with parameters a = 14 b = 03.","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"First, we define the dynamic rule as a standard Julia function. Since the dynamical system is only two-dimensional, we should use the out-of-place form that returns an SVector with the next state:","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"using DynamicalSystems\n\nfunction henon_rule(u, p, n) # here `n` is \"time\", but we don't use it.\n    x, y = u # system state\n    a, b = p # system parameters\n    xn = 1.0 - a*x^2 + y\n    yn = b*x\n    return SVector(xn, yn)\nend","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"Then, we define initial state and parameters","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"u0 = [0.2, 0.3]\np0 = [1.4, 0.3]","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"Lastly, we give these three to the DeterministicIteratedMap:","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"henon = DeterministicIteratedMap(henon_rule, u0, p0)","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"henon is a DynamicalSystem, one of the two core structures of the library. They can evolved interactively, and queried, using the interface defined by DynamicalSystem. The simplest thing you can do with a DynamicalSystem is to get its trajectory:","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"total_time = 10_000\nX, t = trajectory(henon, total_time)","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"X","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"X is a StateSpaceSet, the second of the core structures of the library. We'll see below how, and where, to use a StateSpaceset, but for now let's just do a scatter plot","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"using CairoMakie\nscatter(X[:, 1], X[:, 2])","category":"page"},{"location":"tutorial/#Example:-Lorenz96","page":"Overarching tutorial","title":"Example: Lorenz96","text":"","category":"section"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"Let's also make another dynamical system, the Lorenz96 model:","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"fracdx_idt = (x_i+1-x_i-2)x_i-1 - x_i + F","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"for i in 1 ldots N and N+j=j.","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"Here, instead of a discrete time map we have N coupled ordinary differential equations. However, creating the dynamical system works out just like above, but using CoupledODEs instead of DeterministicIteratedMap.","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"First, we make the dynamic rule function. Since this dynamical system can be arbitrarily high-dimensional, we prefer to use the in-place form for f, overwriting in place the rate of change in a pre-allocated container. It is customary to append the name of functions that modify their arguments in-place with a bang (!).","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"function lorenz96_rule!(du, u, p, t)\n    F = p[1]; N = length(u)\n    # 3 edge cases\n    du[1] = (u[2] - u[N - 1]) * u[N] - u[1] + F\n    du[2] = (u[3] - u[N]) * u[1] - u[2] + F\n    du[N] = (u[1] - u[N - 2]) * u[N - 1] - u[N] + F\n    # then the general case\n    for n in 3:(N - 1)\n        du[n] = (u[n + 1] - u[n - 2]) * u[n - 1] - u[n] + F\n    end\n    return nothing # always `return nothing` for in-place form!\nend","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"then, like before, we define an initial state and parameters, and initialize the system","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"N = 6\nu0 = range(0.1, 1; length = N)\np0 = [8.0]\nlorenz96 = CoupledODEs(lorenz96_rule!, u0, p0)","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"and, again like before, we may obtain a trajectory the same way","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"total_time = 12.5\nsampling_time = 0.02\nY, t = trajectory(lorenz96, total_time; Ttr = 2.2, Δt = sampling_time)\nY","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"We can't scatterplot something 6-dimensional but we can visualize all timeseries","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"fig = Figure()\nax = Axis(fig[1, 1]; xlabel = \"time\", ylabel = \"variable\")\nfor var in columns(Y)\n    lines!(ax, t, var)\nend\nfig","category":"page"},{"location":"tutorial/#ODE-solving","page":"Overarching tutorial","title":"ODE solving","text":"","category":"section"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"Continuous time dynamical systems are evolved through DifferentialEquations.jl. When initializing a CoupledODEs you can tune the solver properties to your heart's content using any of the ODE solvers and any of the common solver options. For example:","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"using OrdinaryDiffEq # accessing the ODE solvers\ndiffeq = (alg = Vern9(), abstol = 1e-9, reltol = 1e-9)\nlorenz96_vern = ContinuousDynamicalSystem(lorenz96_rule!, u0, p0; diffeq)","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"Y, t = trajectory(lorenz96_vern, total_time; Ttr = 2.2, Δt = sampling_time)\nY[end]","category":"page"},{"location":"tutorial/#Using-dynamical-systems","page":"Overarching tutorial","title":"Using dynamical systems","text":"","category":"section"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"You may use the DynamicalSystem interface to develop algorithms that utilize dynamical systems with a known evolution rule. The two main packages of the library that do this are ChaosTools and Attractors. For example, you may want to compute the Lyapunov spectrum of the Lorenz96 system from above. This is as easy as calling the lyapunovspectrum function with lorenz96","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"steps = 10_000\nlyapunovspectrum(lorenz96, steps)","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"As expected, there is at least one positive Lyapunov exponent (before the system is chaotic) and at least one zero Lyapunov exponent, because the system is continuous time.","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"Alternatively, you may want to estimate the basins of attraction of a multistable dynamical system. The Henon map is \"multistable\" in the sense that some initial conditions diverge to infinity, and some others converge to a chaotic attractor. Computing these basins of attraction is simple with Attractors, and would work as follows:","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"# define a state space grid to compute the basins on:\nxg = yg = range(-2, 2; length = 201)\n# find attractors using recurrences in state space:\nmapper = AttractorsViaRecurrences(henon, (xg, yg); sparse = false)\n# compute the full basins of attraction:\nbasins, attractors = basins_of_attraction(mapper; show_progress = false)","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"fig, ax = heatmap(xg, yg, basins)\nx, y = columns(X) # attractor of Henon map\nscatter!(ax, x, y; color = \"black\")\nfig","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"You could also be using a DynamicalSystem instance directly to build your own algorithm if it isn't already implemented (and then later contribute it so it is implemented ;) ). A dynamical system can be evolved forwards in time using step!:","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"henon","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"Notice how the time is not 0, because henon has already been stepped when we called the function basins_of_attraction with it. We can step it more:","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"step!(henon)","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"step!(henon, 2)","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"For more information on how to directly use DynamicalSystem instances, see the documentation of DynamicalSystemsBase.","category":"page"},{"location":"tutorial/#State-space-sets","page":"Overarching tutorial","title":"State space sets","text":"","category":"section"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"Let's recall that the output of the trajectory function is a StateSpaceSet:","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"X","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"It is printed like a matrix where each column is the timeseries of each dynamic variable. In reality, it is a vector of statically sized vectors (for performance reasons). When indexed with 1 index, it behaves like a vector of vectors","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"X[1]","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"X[2:5]","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"When indexed with two indices, it behaves like a matrix","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"X[2:5, 2]","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"When iterated, it iterates over the contained points","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"for (i, point) in enumerate(X)\n    @show point\n    i > 5 && break\nend","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"map(point -> point[1] + point[2], X)","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"The columns of the set are obtained with the convenience columns function","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"x, y = columns(X)\nsummary.((x, y))","category":"page"},{"location":"tutorial/#Using-state-space-sets","page":"Overarching tutorial","title":"Using state space sets","text":"","category":"section"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"Several packages of the library deal with StateSpaceSets.","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"You could use ComplexityMeasures to obtain the entropy, or other complexity measures, of a given set. Below, we obtain the entropy of the natural density of the chaotic attractor by partitioning into a histogram of approximately 50 bins per dimension:","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"prob_est = ValueHistogram(50)\nentropy(prob_est, X)","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"Alternatively, you could use FractalDimensions to get the fractal dimensions of the chaotic attractor of the henon map using the Grassberger-Procaccia algorithm:","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"grassberger_proccacia_dim(X)","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"Or, you could obtain a recurrence matrix of a state space set with RecurrenceAnalysis","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"R = RecurrenceMatrix(Y, 8.0)\nRg = grayscale(R)\nrr = recurrencerate(R)\nheatmap(Rg; colormap = :grays,\n    axis = (title = \"recurrence rate = $(rr)\", aspect = 1,)\n)","category":"page"},{"location":"tutorial/#More-nonlinear-timeseries-analysis","page":"Overarching tutorial","title":"More nonlinear timeseries analysis","text":"","category":"section"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"A trajectory of a known dynamical system is one way to obtain a StateSpaceSet. However, another common way is via a delay coordinates embedding of a measured/observed timeseries. For example, we could use optimal_traditional_de from DelayEmbeddings to create an optimized delay coordinates embedding of a timeseries","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"w = Y[:, 1] # first variable of Lorenz96\n𝒟, τ, e = optimal_traditional_de(w)\n𝒟","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"and compare","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"fig = Figure()\naxs = [Axis3(fig[1, i]) for i in 1:2]\nfor (S, ax) in zip((Y, 𝒟), axs)\n    lines!(ax, S[:, 1], S[:, 2], S[:, 3])\nend\nfig","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"Since 𝒟 is just another state space set, we could be using any of the above analysis pipelines on it just as easily.","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"The last package to mention here is TimeseriesSurrogates, which ties with all other observed/measured data analysis by providing a framework for confidence/hypothesis testing. For example, if we had a measured timeseries but we were not sure whether it represents a deterministic system with structure in the state space, or mostly noise, we could do a surrogate test. For this, we use surrogenerator and RandomFourier from TimeseriesSurrogates, and the generalized_dim from FractalDimensions (because it performs better in noisy sets)","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"x = X[:, 1] # Henon map timeseries\n# contaminate with noise\nusing Random: Xoshiro\nrng = Xoshiro(1234)\nx .+= randn(rng, length(x))/100\n# compute noise-contaminated fractal dim.\nΔ_orig = generalized_dim(embed(x, 2, 1))","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"And we do the surrogate test","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"surrogate_method = RandomFourier()\nsgen = surrogenerator(x, surrogate_method, rng)\n\nΔ_surr = map(1:1000) do i\n    s = sgen()\n    generalized_dim(embed(s, 2, 1))\nend","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"and visualize the test result","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"fig, ax = hist(Δ_surr)\nvlines!(ax, Δ_orig)\nfig","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"since the real value is outside the distribution we have confidence the data are not pure noise.","category":"page"},{"location":"tutorial/#Core-components-reference","page":"Overarching tutorial","title":"Core components reference","text":"","category":"section"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"StateSpaceSet\nDynamicalSystem","category":"page"},{"location":"tutorial/#StateSpaceSets.StateSpaceSet","page":"Overarching tutorial","title":"StateSpaceSets.StateSpaceSet","text":"StateSpaceSet{D, T} <: AbstractStateSpaceSet{D,T}\n\nA dedicated interface for sets in a state space. It is an ordered container of equally-sized points of length D. Each point is represented by SVector{D, T}. The data are a standard Julia Vector{SVector}, and can be obtained with vec(ssset::StateSpaceSet). Typically the order of points in the set is the time direction, but it doesn't have to be.\n\nWhen indexed with 1 index, StateSpaceSet is like a vector of points. When indexed with 2 indices it behaves like a matrix that has each of the columns be the timeseries of each of the variables. When iterated over, it iterates over its contained points. See description of indexing below for more.\n\nStateSpaceSet also supports almost all sensible vector operations like append!, push!, hcat, eachrow, among others.\n\nDescription of indexing\n\nIn the following let i, j be integers, typeof(X) <: AbstractStateSpaceSet and v1, v2 be <: AbstractVector{Int} (v1, v2 could also be ranges, and for performance benefits make v2 an SVector{Int}).\n\nX[i] == X[i, :] gives the ith point (returns an SVector)\nX[v1] == X[v1, :], returns a StateSpaceSet with the points in those indices.\nX[:, j] gives the jth variable timeseries (or collection), as Vector\nX[v1, v2], X[:, v2] returns a StateSpaceSet with the appropriate entries (first indices being \"time\"/point index, while second being variables)\nX[i, j] value of the jth variable, at the ith timepoint\n\nUse Matrix(ssset) or StateSpaceSet(matrix) to convert. It is assumed that each column of the matrix is one variable. If you have various timeseries vectors x, y, z, ... pass them like StateSpaceSet(x, y, z, ...). You can use columns(dataset) to obtain the reverse, i.e. all columns of the dataset in a tuple.\n\n\n\n\n\n","category":"type"},{"location":"tutorial/#DynamicalSystemsBase.DynamicalSystem","page":"Overarching tutorial","title":"DynamicalSystemsBase.DynamicalSystem","text":"DynamicalSystem\n\nDynamicalSystem is an abstract supertype encompassing all concrete implementations of what counts as a \"dynamical system\" in the DynamicalSystems.jl library.\n\nAll concrete implementations of DynamicalSystem can be iteratively evolved in time via the step! function. Hence, most library functions that evolve the system will mutate its current state and/or parameters. See the documentation online for implications this has on for parallelization.\n\nDynamicalSystem is further separated into two abstract types: ContinuousTimeDynamicalSystem, DiscreteTimeDynamicalSystem. The simplest and most common concrete implementations of a DynamicalSystem are DeterministicIteratedMap or CoupledODEs.\n\nDescription\n\nnote: Note\nThe documentation of DynamicalSystem follows chapter 1 of Nonlinear Dynamics, Datseris & Parlitz, Springer 2022.\n\nA ds::DynamicalSystem representes a flow Φ in a state space. It mainly encapsulates three things:\n\nA state, typically referred to as u, with initial value u0. The space that u occupies is the state space of ds and the length of u is the dimension of ds (and of the state space).\nA dynamic rule, typically referred to as f, that dictates how the state evolves/changes with time when calling the step! function. f is a standard Julia function, see below.\nA parameter container p that parameterizes f. p can be anything, but in general it is recommended to be a type-stable mutable container.\n\nIn sort, any set of quantities that change in time can be considered a dynamical system, however the concrete subtypes of DynamicalSystem are much more specific in their scope. Concrete subtypes typically also contain more information than the above 3 items.\n\nIn this scope dynamical systems have a known dynamic rule f defined as a standard Julia function. Observed or measured data from a dynamical system are represented using StateSpaceSet and are finite. Such data are obtained from the trajectory function or from an experimental measurement of a dynamical system with an unknown dynamic rule.\n\nConstruction instructions on f and u\n\nMost of the concrete implementations of DynamicalSystem, with the exception of ArbitrarySteppable, have two ways of implementing the dynamic rule f, and as a consequence the type of the state u. The distinction is done on whether f is defined as an in-place (iip) function or out-of-place (oop) function.\n\noop : f must be in the form f(u, p, t) -> out   which means that given a state u::SVector{<:Real} and some parameter container   p it returns the output of f as an SVector{<:Real} (static vector).\niip : f must be in the form f!(out, u, p, t)   which means that given a state u::AbstractArray{<:Real} and some parameter container p,   it writes in-place the output of f in out::AbstractArray{<:Real}.   The function must return nothing as a final statement.\n\nt stands for current time in both cases. iip is suggested for systems with high dimension and oop for small. The break-even point is between 10 to 100 dimensions but should be benchmarked on a case-by-case basis as it depends on the complexity of f.\n\nnote: Autonomous vs non-autonomous systems\nWhether the dynamical system is autonomous (f doesn't depend on time) or not, it is still necessary to include t as an argument to f. Some algorithms utilize this information, some do not, but we prefer to keep a consistent interface either way. You can also convert any system to autonomous by making time an additional variable. If the system is non-autonomous, its effective dimensionality is dimension(ds)+1.\n\nAPI\n\nThe API that the interface of DynamicalSystem employs is the functions listed below. Once a concrete instance of a subtype of DynamicalSystem is obtained, it can quieried or altered with the following functions.\n\nThe main use of a concrete dynamical system instance is to provide it to downstream functions such as lyapunovspectrum from ChaosTools.jl or basins_of_attraction from Attractors.jl. A typical user will likely not utilize directly the following API, unless when developing new algorithm implementations that use dynamical systems.\n\nAPI - information\n\nds(t) with ds an instance of DynamicalSystem: return the state of ds at time t. For continuous time systems this interpolates and extrapolates, while for discrete time systems it only works if t is the current time.\ncurrent_state\ninitial_state\ncurrent_parameters\ninitial_parameters\nisdeterministic\nisdiscretetime\ndynamic_rule\ncurrent_time\ninitial_time\nisinplace\nsuccesful_step\n\nAPI - alter status\n\nreinit!\nset_state!\nset_parameter!\nset_parameters!\n\n\n\n\n\n","category":"type"},{"location":"tutorial/#Dynamical-system-implementations","page":"Overarching tutorial","title":"Dynamical system implementations","text":"","category":"section"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"DeterministicIteratedMap\nCoupledODEs\nStroboscopicMap\nPoincareMap\nProjectedDynamicalSystem\nArbitrarySteppable","category":"page"},{"location":"tutorial/#DynamicalSystemsBase.DeterministicIteratedMap","page":"Overarching tutorial","title":"DynamicalSystemsBase.DeterministicIteratedMap","text":"DeterministicIteratedMap <: DynamicalSystem\nDeterministicIteratedMap(f, u0, p = nothing; t0 = 0)\n\nA deterministic discrete time dynamical system defined by an iterated map as follows:\n\nvecu_n+1 = vecf(vecu_n p n)\n\nAn alias for DeterministicIteratedMap is DiscreteDynamicalSystem.\n\nOptionally configure the parameter container p and initial time t0.\n\nFor construction instructions regarding f, u0 see DynamicalSystem.\n\n\n\n\n\n","category":"type"},{"location":"tutorial/#DynamicalSystemsBase.CoupledODEs","page":"Overarching tutorial","title":"DynamicalSystemsBase.CoupledODEs","text":"CoupledODEs <: ContinuousTimeDynamicalSystem\nCoupledODEs(f, u0 [, p]; diffeq, t0 = 0.0)\n\nA deterministic continuous time dynamical system defined by a set of coupled ordinary differential equations as follows:\n\nfracdvecudt = vecf(vecu p t)\n\nAn alias for CoupledODE is ContinuousDynamicalSystem.\n\nOptionally provide the parameter container p and initial time as keyword t0.\n\nFor construction instructions regarding f, u0 see DynamicalSystem.\n\nDifferentialEquations.jl keyword arguments and interfacing\n\nThe ODEs are evolved via the solvers of DifferentialEquations.jl. When initializing a CoupledODEs, you can specify the solver that will integrate f in time, along with any other integration options, using the diffeq keyword. For example you could use diffeq = (abstol = 1e-9, reltol = 1e-9). If you want to specify a solver, do so by using the keyword alg, e.g.: diffeq = (alg = Tsit5(), reltol = 1e-6). This requires you to have been first using OrdinaryDiffEq to access the solvers. The default diffeq is:\n\n(alg = Tsit5(stagelimiter! = triviallimiter!, steplimiter! = triviallimiter!, thread = static(false)), abstol = 1.0e-6, reltol = 1.0e-6)\n\ndiffeq keywords can also include callback for event handling , however the majority of downstream functions in DynamicalSystems.jl assume that f is differentiable.\n\nThe convenience constructor CoupledODEs(prob::ODEProblem, diffeq) and CoupledODEs(ds::CoupledODEs, diffeq) are also available.\n\nDev note: CoupledODEs is a light wrapper of ODEIntegrator from DifferentialEquations.jl. The integrator is available as the field integ, and the ODEProblem is integ.sol.prob. The convenience syntax ODEProblem(ds::CoupledODEs, tspan = (t0, Inf)) is available.\n\n\n\n\n\n","category":"type"},{"location":"tutorial/#DynamicalSystemsBase.StroboscopicMap","page":"Overarching tutorial","title":"DynamicalSystemsBase.StroboscopicMap","text":"StroboscopicMap <: DiscreteTimeDynamicalSystem\nStroboscopicMap(ds::CoupledODEs, period::Real) → smap\nStroboscopicMap(period::Real, f, u0, p = nothing; kwargs...)\n\nA discrete time dynamical system that produces iterations of a time-dependent (non-autonomous) CoupledODEs system exactly over a given period. The second signature first creates a CoupledODEs and then calls the first.\n\nStroboscopicMap follows the DynamicalSystem interface. In addition, the function set_period!(smap, period) is provided, that sets the period of the system to a new value (as if it was a parameter). As this system is in discrete time, current_time and initial_time are integers. The initial time is always 0, because current_time counts elapsed periods. Call these functions on the parent of StroboscopicMap to obtain the corresponding continuous time. In contrast, reinit! expects t0 in continuous time.\n\nThe convenience constructor\n\nStroboscopicMap(T::Real, f, u0, p = nothing; diffeq, t0 = 0) → smap\n\nis also provided.\n\nSee also PoincareMap.\n\n\n\n\n\n","category":"type"},{"location":"tutorial/#DynamicalSystemsBase.PoincareMap","page":"Overarching tutorial","title":"DynamicalSystemsBase.PoincareMap","text":"PoincareMap <: DiscreteTimeDynamicalSystem\nPoincareMap(ds::CoupledODEs, plane; kwargs...) → pmap\n\nA discrete time dynamical system that produces iterations over the Poincaré map[DatserisParlitz2022] of the given continuous time ds. This map is defined as the sequence of points on the Poincaré surface of section, which is defined by the plane argument.\n\nSee also StroboscopicMap, poincaresos.\n\nKeyword arguments\n\ndirection = -1: Only crossings with sign(direction) are considered to belong to the surface of section. Negative direction means going from less than b to greater than b.\nu0 = nothing: Specify an initial state.\nrootkw = (xrtol = 1e-6, atol = 1e-8): A NamedTuple of keyword arguments passed to find_zero from Roots.jl.\nTmax = 1e3: The argument Tmax exists so that the integrator can terminate instead of being evolved for infinite time, to avoid cases where iteration would continue forever for ill-defined hyperplanes or for convergence to fixed points, where the trajectory would never cross again the hyperplane. If during one step! the system has been evolved for more than Tmax, then step!(pmap) will terminate and error.\n\nDescription\n\nThe Poincaré surface of section is defined as sequential transversal crossings a trajectory has with any arbitrary manifold, but here the manifold must be a hyperplane. PoincareMap iterates over the crossings of the section.\n\nIf the state of ds is mathbfu = (u_1 ldots u_D) then the equation defining a hyperplane is\n\na_1u_1 + dots + a_Du_D = mathbfacdotmathbfu=b\n\nwhere mathbfa b are the parameters of the hyperplane.\n\nIn code, plane can be either:\n\nA Tuple{Int, <: Real}, like (j, r): the plane is defined as when the jth variable of the system equals the value r.\nA vector of length D+1. The first D elements of the vector correspond to mathbfa while the last element is b.\n\nPoincareMap uses ds, higher order interpolation from DifferentialEquations.jl, and root finding from Roots.jl, to create a high accuracy estimate of the section.\n\nPoincareMap follows the DynamicalSystem interface with the following adjustments:\n\ndimension(pmap) == dimension(ds), even though the Poincaré map is effectively 1 dimension less.\nLike StroboscopicMap time is discrete and counts the iterations on the surface of section. initial_time is always 0 and current_time is current iteration number.\nA new function current_crossing_time returns the real time corresponding to the latest crossing of the hyperplane, which is what the current_state(ds) corresponds to as well.\nFor the special case of plane being a Tuple{Int, <:Real}, a special reinit! method is allowed with input state of length D-1 instead of D, i.e., a reduced state already on the hyperplane that is then converted into the D dimensional state.\n\nExample\n\nusing DynamicalSystemsBase\nds = Systems.rikitake(zeros(3); μ = 0.47, α = 1.0)\npmap = poincaremap(ds, (3, 0.0))\nstep!(pmap)\nnext_state_on_psos = current_state(pmap)\n\n[DatserisParlitz2022]: Datseris & Parlitz 2022, Nonlinear Dynamics: A Concise Introduction Interlaced with Code, Springer Nature, Undergrad. Lect. Notes In Physics\n\n\n\n\n\n","category":"type"},{"location":"tutorial/#DynamicalSystemsBase.ProjectedDynamicalSystem","page":"Overarching tutorial","title":"DynamicalSystemsBase.ProjectedDynamicalSystem","text":"ProjectedDynamicalSystem <: DynamicalSystem\nProjectedDynamicalSystem(ds::DynamicalSystem, projection, complete_state)\n\nA dynamical system that represents a projection of an existing ds on a (projected) space.\n\nThe projection defines the projected space. If projection isa AbstractVector{Int}, then the projected space is simply the variable indices that projection contains. Otherwise, projection can be an arbitrary function that given the state of the original system ds, returns the state in the projected space. In this case the projected space can be equal, or even higher-dimensional, than the original.\n\ncomplete_state produces the state for the original system from the projected state. complete_state can always be a function that given the projected state returns a state in the original space. However, if projection isa AbstractVector{Int}, then complete_state can also be a vector that contains the values of the remaining variables of the system, i.e., those not contained in the projected space. In this case the projected space needs to be lower-dimensional than the original.\n\nNotice that ProjectedDynamicalSystem does not require an invertible projection, complete_state is only used during reinit!. ProjectedDynamicalSystem is in fact a rather trivial wrapper of ds which steps it as normal in the original state space and only projects as a last step, e.g., during current_state.\n\nExamples\n\nCase 1: project 5-dimensional system to its last two dimensions.\n\nds = Systems.lorenz96(5)\nprojection = [4, 5]\ncomplete_state = [0.0, 0.0, 0.0] # completed state just in the plane of last two dimensions\npds = ProjectedDynamicalSystem(ds, projection, complete_state)\nreinit!(pds, [0.2, 0.4])\nstep!(pds)\nget_state(pds)\n\nCase 2: custom projection to general functions of state.\n\nds = Systems.lorenz96(5)\nprojection(u) = [sum(u), sqrt(u[1]^2 + u[2]^2)]\ncomplete_state(y) = repeat([y[1]/5], 5)\npds = # same as in above example...\n\n\n\n\n\n","category":"type"},{"location":"tutorial/#DynamicalSystemsBase.ArbitrarySteppable","page":"Overarching tutorial","title":"DynamicalSystemsBase.ArbitrarySteppable","text":"ArbitrarySteppable <: DiscreteTimeDynamicalSystem\nArbitrarySteppable(\n    model, step!, extract_state, extract_parameters, reset_model!;\n    isdeterministic = true, set_state = reinit!,\n)\n\nA dynamical system generated by an arbitrary \"model\" that can be stepped in-place with some function step!(model) for 1 step. The state of the model is extracted by the extract_state(model) -> u function The parameters of the model are extracted by the extract_parameters(model) -> p function. The system may be re-initialized, via reinit!, with the reset_model! user-provided function that must have the call signature\n\nreset_model!(model, u, p)\n\ngiven a (potentially new) state u and parameter container p, both of which will default to the initial ones in the reinit! call.\n\nArbitrarySteppable exists to provide the DynamicalSystems.jl interface to models from other packages that could be used within the DynamicalSystems.jl library. ArbitrarySteppable follows the DynamicalSystem interface with the following adjustments:\n\ninitial_time is always 0, as time counts the steps the model has taken since creation or last reinit! call.\nset_state! is the same as reinit! by default. If not, the keyword argument set_state is a function set_state(model, u) that sets the state of the model to u.\nThe keyword isdeterministic should be set properly, as it decides whether downstream algorithms should error or not.\n\n\n\n\n\n","category":"type"},{"location":"tutorial/#Learn-more","page":"Overarching tutorial","title":"Learn more","text":"","category":"section"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"To learn more, you need to visit the documentation pages of the individual packages. See the contents page for more!","category":"page"}]
}
