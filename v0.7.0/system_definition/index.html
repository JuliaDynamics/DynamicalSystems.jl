<!DOCTYPE html><HTML class="no-js" lang="en"><head><meta charset="utf-8"/><meta content="width=device-width,initial-scale=1" name="viewport"/><meta content="ie=edge" http-equiv="x-ua-compatible"/><meta content="A Julia package for the exploration of chaos in continuous and discrete dynamical systems." name="description"/><meta content="George Datseris" name="author"/><meta content="Copy to clipboard" name="lang:clipboard.copy"/><meta content="Copied to clipboard" name="lang:clipboard.copied"/><meta content="en" name="lang:search.language"/><meta content="No matching documents" name="lang:search.result.none"/><meta content="1 matching document" name="lang:search.result.one"/><meta content="# matching documents" name="lang:search.result.other"/><meta content="[\s\-]+" name="lang:search.tokenizer"/><link href="../assets/images/favicon.png" rel="shortcut icon"/><meta content="mkdocs-0.17.2, mkdocs-material-2.2.3" name="generator"/><title>System Definition - DynamicalSystems.jl</title><link href="../assets/stylesheets/application.bcabdff3.css" rel="stylesheet"/><link href="../assets/stylesheets/application-palette.792431c1.css" rel="stylesheet"/><script src="../assets/javascripts/modernizr.1aa3b519.js"></script><link href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono" rel="stylesheet"/><style>body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}</style><link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"/><link href="../assets\Documenter.css" rel="stylesheet"/><script data-outdated-warner="">function maybeAddWarning () {
    const head = document.getElementsByTagName('head')[0];

    // Add a noindex meta tag (unless one exists) so that search engines don't index this version of the docs.
    if (document.body.querySelector('meta[name="robots"]') === null) {
        const meta = document.createElement('meta');
        meta.name = 'robots';
        meta.content = 'noindex';

        head.appendChild(meta);
    };

    // Add a stylesheet to avoid inline styling
    const style = document.createElement('style');
    style.type = 'text/css';
    style.appendChild(document.createTextNode('.outdated-warning-overlay {  position: fixed;  top: 0;  left: 0;  right: 0;  box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);  z-index: 999;  background-color: #ffaba7;  color: rgba(0, 0, 0, 0.7);  border-bottom: 3px solid #da0b00;  padding: 10px 35px;  text-align: center;  font-size: 15px; }  .outdated-warning-overlay .outdated-warning-closer {    position: absolute;    top: calc(50% - 10px);    right: 18px;    cursor: pointer;    width: 12px; }  .outdated-warning-overlay a {    color: #2e63b8; }    .outdated-warning-overlay a:hover {      color: #363636; }'));
    head.appendChild(style);

    const div = document.createElement('div');
    div.classList.add('outdated-warning-overlay');
    const closer = document.createElement('div');
    closer.classList.add('outdated-warning-closer');

    // Icon by font-awesome (license: https://fontawesome.com/license, link: https://fontawesome.com/icons/times?style=solid)
    closer.innerHTML = '<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="times" class="svg-inline--fa fa-times fa-w-11" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 352 512"><path fill="currentColor" d="M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"></path></svg>';
    closer.addEventListener('click', function () {
        document.body.removeChild(div);
    });
    let href = '/stable';
    if (window.documenterBaseURL) {
        href = window.documenterBaseURL + '/../stable';
    }
    div.innerHTML = 'This documentation is not for the latest version. <br> <a href="' + href + '">Go to the latest documentation</a>.';
    div.appendChild(closer);
    document.body.appendChild(div);
};

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', maybeAddWarning);
} else {
    maybeAddWarning();
};
</script></head><body data-md-color-accent="teal" data-md-color-primary="deep-purple"><svg class="md-svg"><defs><svg height="448" id="github" viewBox="0 0 416 448" width="416" xmlns="http://www.w3.org/2000/svg"><path d="M160 304q0 10-3.125 20.5t-10.75 19T128 352t-18.125-8.5-10.75-19T96 304t3.125-20.5 10.75-19T128 256t18.125 8.5 10.75 19T160 304zm160 0q0 10-3.125 20.5t-10.75 19T288 352t-18.125-8.5-10.75-19T256 304t3.125-20.5 10.75-19T288 256t18.125 8.5 10.75 19T320 304zm40 0q0-30-17.25-51T296 232q-10.25 0-48.75 5.25Q229.5 240 208 240t-39.25-2.75Q130.75 232 120 232q-29.5 0-46.75 21T56 304q0 22 8 38.375t20.25 25.75 30.5 15 35 7.375 37.25 1.75h42q20.5 0 37.25-1.75t35-7.375 30.5-15 20.25-25.75T360 304zm56-44q0 51.75-15.25 82.75-9.5 19.25-26.375 33.25t-35.25 21.5-42.5 11.875-42.875 5.5T212 416q-19.5 0-35.5-.75t-36.875-3.125-38.125-7.5-34.25-12.875T37 371.5t-21.5-28.75Q0 312 0 260q0-59.25 34-99-6.75-20.5-6.75-42.5 0-29 12.75-54.5 27 0 47.5 9.875t47.25 30.875Q171.5 96 212 96q37 0 70 8 26.25-20.5 46.75-30.25T376 64q12.75 25.5 12.75 54.5 0 21.75-6.75 42 34 40 34 99.5z" fill="currentColor"></path></svg></defs></svg><input class="md-toggle" data-md-toggle="drawer" id="drawer" type="checkbox"/><input class="md-toggle" data-md-toggle="search" id="search" type="checkbox"/><label class="md-overlay" data-md-component="overlay" for="drawer"></label><header class="md-header" data-md-component="header"><nav class="md-header-nav md-grid"><div class="md-flex"><div class="md-flex__cell md-flex__cell--shrink"><a class="md-header-nav__button md-logo" href=".." title="DynamicalSystems.jl"><i class="md-icon"></i></a></div><div class="md-flex__cell md-flex__cell--shrink"><label class="md-icon md-icon--menu md-header-nav__button" for="drawer"></label></div><div class="md-flex__cell md-flex__cell--stretch"><div class="md-flex__ellipsis md-header-nav__title" data-md-component="title"><span class="md-header-nav__topic">
                DynamicalSystems.jl
              </span><span class="md-header-nav__topic">
                System Definition
              </span></div></div><div class="md-flex__cell md-flex__cell--shrink"><label class="md-icon md-icon--search md-header-nav__button" for="search"></label><div class="md-search" data-md-component="search" role="dialog"><label class="md-search__overlay" for="search"></label><div class="md-search__inner"><form class="md-search__form" name="search"><input autocapitalize="off" autocomplete="off" autocorrect="off" class="md-search__input" data-md-component="query" name="query" placeholder="Search" required="" spellcheck="false" type="text"/><label class="md-icon md-search__icon" for="search"></label><button class="md-icon md-search__icon" data-md-component="reset" type="reset"></button></form><div class="md-search__output"><div class="md-search__scrollwrap" data-md-scrollfix=""><div class="md-search-result" data-md-component="result"><div class="md-search-result__meta">
            Type to start searching
          </div><ol class="md-search-result__list"></ol></div></div></div></div></div></div><div class="md-flex__cell md-flex__cell--shrink"><div class="md-header-nav__source"><a class="md-source" data-md-source="github" href="https://github.com/JuliaDynamics/DynamicalSystems.jl/" title="Go to repository"><div class="md-source__icon"><svg height="24" viewBox="0 0 24 24" width="24"><use height="24" href="#github" width="24"></use></svg></div><div class="md-source__repository">
      GitHub
    </div></a></div></div></div></nav></header><div class="md-container"><main class="md-main"><div class="md-main__inner md-grid" data-md-component="container"><div class="md-sidebar md-sidebar--primary" data-md-component="navigation"><div class="md-sidebar__scrollwrap"><div class="md-sidebar__inner"><nav class="md-nav md-nav--primary" data-md-level="0"><label class="md-nav__title md-nav__title--site" for="drawer"><span class="md-nav__button md-logo"><i class="md-icon"></i></span>
    DynamicalSystems.jl
  </label><div class="md-nav__source"><a class="md-source" data-md-source="github" href="https://github.com/JuliaDynamics/DynamicalSystems.jl/" title="Go to repository"><div class="md-source__icon"><svg height="24" viewBox="0 0 24 24" width="24"><use height="24" href="#github" width="24"></use></svg></div><div class="md-source__repository">
      GitHub
    </div></a></div><ul class="md-nav__list" data-md-scrollfix=""><li class="md-nav__item"><a class="md-nav__link" href=".." title="Introduction">
      Introduction
    </a></li><li class="md-nav__item md-nav__item--active"><input class="md-toggle md-nav__toggle" data-md-toggle="toc" id="toc" type="checkbox"/><label class="md-nav__link md-nav__link--active" for="toc">
        System Definition
      </label><a class="md-nav__link md-nav__link--active" href="./" title="System Definition">
      System Definition
    </a><nav class="md-nav md-nav--secondary"><label class="md-nav__title" for="toc">Table of contents</label><ul class="md-nav__list" data-md-scrollfix=""><li class="md-nav__item"><a class="md-nav__link" href="#continuous-systems" title="Continuous Systems">
    Continuous Systems
  </a><nav class="md-nav"><ul class="md-nav__list"><li class="md-nav__item"><a class="md-nav__link" href="#defining-a-dynamicalsystem-using-functors" title="Defining a DynamicalSystem using Functors">
    Defining a DynamicalSystem using Functors
  </a></li></ul></nav></li><li class="md-nav__item"><a class="md-nav__link" href="#discrete-systems" title="Discrete Systems">
    Discrete Systems
  </a><nav class="md-nav"><ul class="md-nav__list"><li class="md-nav__item"><a class="md-nav__link" href="#high-dimensional-discrete-systems" title="High-Dimensional Discrete Systems">
    High-Dimensional Discrete Systems
  </a></li><li class="md-nav__item"><a class="md-nav__link" href="#low-dimensional-discrete-systems" title="Low-dimensional Discrete Systems">
    Low-dimensional Discrete Systems
  </a><nav class="md-nav"><ul class="md-nav__list"><li class="md-nav__item"><a class="md-nav__link" href="#defining-a-dynamicalsystem-without-functors" title="Defining a DynamicalSystem without Functors">
    Defining a DynamicalSystem without Functors
  </a></li></ul></nav></li><li class="md-nav__item"><a class="md-nav__link" href="#1-dimensional-discrete-systems" title="1-dimensional Discrete Systems">
    1-dimensional Discrete Systems
  </a></li></ul></nav></li><li class="md-nav__item"><a class="md-nav__link" href="#system-evolution" title="System evolution">
    System evolution
  </a></li><li class="md-nav__item"><a class="md-nav__link" href="#coordination-with-other-packages" title="Coordination with other packages">
    Coordination with other packages
  </a></li><li class="md-nav__item"><a class="md-nav__link" href="#numerical-data" title="Numerical Data">
    Numerical Data
  </a></li><li class="md-nav__item"><a class="md-nav__link" href="#predefined-systems" title="Predefined Systems">
    Predefined Systems
  </a></li></ul></nav></li><li class="md-nav__item"><a class="md-nav__link" href="../lyapunovs/" title="Lyapunov Exponents">
      Lyapunov Exponents
    </a></li><li class="md-nav__item"><a class="md-nav__link" href="../entropies/" title="Entropies and Dimensions">
      Entropies and Dimensions
    </a></li><li class="md-nav__item"><a class="md-nav__link" href="../nlts/" title="Nonlinear Timeseries Analysis">
      Nonlinear Timeseries Analysis
    </a></li><li class="md-nav__item"><a class="md-nav__link" href="../periodicity/" title="Periodicity">
      Periodicity
    </a></li><li class="md-nav__item"><a class="md-nav__link" href="../chaos_detection/" title="Chaos Detection">
      Chaos Detection
    </a></li><li class="md-nav__item"><a class="md-nav__link" href="../visualization/" title="Visualization">
      Visualization
    </a></li><li class="md-nav__item"><a class="md-nav__link" href="../contributors_guide/" title="Contributor Guide">
      Contributor Guide
    </a></li></ul></nav></div></div></div><div class="md-sidebar md-sidebar--secondary" data-md-component="toc"><div class="md-sidebar__scrollwrap"><div class="md-sidebar__inner"><nav class="md-nav md-nav--secondary"><label class="md-nav__title" for="toc">Table of contents</label><ul class="md-nav__list" data-md-scrollfix=""><li class="md-nav__item"><a class="md-nav__link" href="#continuous-systems" title="Continuous Systems">
    Continuous Systems
  </a><nav class="md-nav"><ul class="md-nav__list"><li class="md-nav__item"><a class="md-nav__link" href="#defining-a-dynamicalsystem-using-functors" title="Defining a DynamicalSystem using Functors">
    Defining a DynamicalSystem using Functors
  </a></li></ul></nav></li><li class="md-nav__item"><a class="md-nav__link" href="#discrete-systems" title="Discrete Systems">
    Discrete Systems
  </a><nav class="md-nav"><ul class="md-nav__list"><li class="md-nav__item"><a class="md-nav__link" href="#high-dimensional-discrete-systems" title="High-Dimensional Discrete Systems">
    High-Dimensional Discrete Systems
  </a></li><li class="md-nav__item"><a class="md-nav__link" href="#low-dimensional-discrete-systems" title="Low-dimensional Discrete Systems">
    Low-dimensional Discrete Systems
  </a><nav class="md-nav"><ul class="md-nav__list"><li class="md-nav__item"><a class="md-nav__link" href="#defining-a-dynamicalsystem-without-functors" title="Defining a DynamicalSystem without Functors">
    Defining a DynamicalSystem without Functors
  </a></li></ul></nav></li><li class="md-nav__item"><a class="md-nav__link" href="#1-dimensional-discrete-systems" title="1-dimensional Discrete Systems">
    1-dimensional Discrete Systems
  </a></li></ul></nav></li><li class="md-nav__item"><a class="md-nav__link" href="#system-evolution" title="System evolution">
    System evolution
  </a></li><li class="md-nav__item"><a class="md-nav__link" href="#coordination-with-other-packages" title="Coordination with other packages">
    Coordination with other packages
  </a></li><li class="md-nav__item"><a class="md-nav__link" href="#numerical-data" title="Numerical Data">
    Numerical Data
  </a></li><li class="md-nav__item"><a class="md-nav__link" href="#predefined-systems" title="Predefined Systems">
    Predefined Systems
  </a></li></ul></nav></div></div></div><div class="md-content"><article class="md-content__inner md-typeset"><a class="md-icon md-content__icon" href="https://github.com/JuliaDynamics/DynamicalSystems.jl/edit/master/docs/system_definition.md" title="Edit this page"></a><p><a id="System-Definition-1"></a></p><h1 id="system-definition">System Definition</h1><p>For DynamicalSystems.jl a system is simple a structure that contains the system's state, the equations of motion and the Jacobian. The last two are <em>functions</em> that take as an input a state. It is highly advised to create a <code>DynamicalSystem</code> using Functors (see below).</p><p>The above of course stand for systems where one already <em>knows</em> the equations of motion. if instead, your "system" is in the form of <a href="#numerical-data">numerical data</a>, then see the appropriate section.</p><div class="admonition warning"><p class="admonition-title">Non-autonomous systems</p><p>This package does <strong>not</strong> accept non-autonomous systems. To use such systems with this package increase the dimensionality of your system by 1, by introducing an additional variable <code>τ</code> such that <code>dτdt = 1</code> (or <code>τ_next = τ_prev + 1</code>). This additional variable will serve as the "time" in your equations of motion.</p></div><div class="admonition info"><p class="admonition-title">Trajectory and Timeseries</p><p>The word "timeseries" can be very confusing, because it can mean a univariate (also called scalar or one-dimensional) timeseries or a multivariate (also called multi-dimensional) timeseries. To resolve this confusion, in DynamicalSystems.jl we have the following convention: <strong>"timeseries"</strong> always refers to a one-dimensional vector of numbers, which exists with respect to some other one-dimensional vector of numbers that corresponds to a time-vector. On the other hand, the word <strong>"trajectory"</strong> is used to refer to a <em>multi-dimensional</em> timeseries, which is of course simply a group/set of one-dimensional timeseries.</p><p>Note that the data representation of a "trajectory" in Julia may vary: from a 2D Matrix to independent Vectors. In our package, a trajectory is always represented using a <a href="./#DynamicalSystems.Dataset"><code>Dataset</code></a>, which is a <code>Vector</code> of <code>SVector</code>s, and each <code>SVector</code> represents a data-point (the values of the variables at a given time-point).</p></div><hr/><p><a id="Continuous-Systems-1"></a></p><h2 id="continuous-systems">Continuous Systems</h2><p>Continuous systems of the form</p><div><div class="MathJax_Preview">
\frac{d\vec{u}}{dt} = \vec{f}(\vec{u}),
</div><script type="math/tex; mode=display">
\frac{d\vec{u}}{dt} = \vec{f}(\vec{u}),
</script></div><p>are defined almost identically with the <a href="./#DynamicalSystems.BigDiscreteDS"><code>BigDiscreteDS</code></a> systems:</p><p><a href="#DynamicalSystems.ContinuousDS" id="DynamicalSystems.ContinuousDS">#</a><strong><code>DynamicalSystems.ContinuousDS</code></strong> — <em>Type</em>.</p><div class="codehilite"><pre><span></span>ContinuousDS(state, eom! [, jacob! [, J]]) &lt;: DynamicalSystem
</pre></div><p><code>D</code>-dimensional continuous dynamical system.</p><p><strong>Fields:</strong></p><ul><li><code>state::Vector{T}</code> : Current state-vector of the system. Do <code>ds.state .= u</code> to change the state.</li><li><code>eom!</code> (function) : The function that represents the system's equations of motion (also called vector field). The function is of the format: <code>eom!(du, u)</code> which means that it is <strong>in-place</strong>, with the Julian syntax (the mutated argument <code>du</code> is the first).</li><li><code>jacob!</code> (function) : The function that represents the Jacobian of the system, given in the format: <code>jacob!(J, u)</code> which means it is in-place, with the mutated argument being the first.</li><li><code>J::Matrix{T}</code> : Initialized Jacobian matrix (optional).</li></ul><p>Only the first two fields of this type are displayed during print.</p><p>As mentioned in our <a href="https://juliadynamics.github.io/DynamicalSystems.jl/latest/system_definition#example-using-functors">official documentation</a>, it is preferred to use Functors for both the equations of motion and the Jacobian.</p><p>If the <code>jacob</code> is not provided by the user, it is created automatically using the module <a href="http://www.juliadiff.org/ForwardDiff.jl/stable/"><code>ForwardDiff</code></a>.</p><p><a class="documenter-source" href="https://github.com/JuliaDynamics/DynamicalSystems.jl/blob/ad2b0c0e81e05f7cf3c1bbd69ed79b6cde4ae51e/src/systems/continuous.jl#L13-L35" target="_blank">source</a><br/></p><p>Notice that the fields <code>eom!</code> and <code>jacob!</code> end with a <code>!</code>, to remind users that these functions should operate in-place. Also notice that the type <code>ContinuousDS</code> is actually immutable.</p><p>You can give any function that complies with the requirements stated by the documentation string. However, it is highly advised to use <a href="https://docs.julialang.org/en/stable/manual/methods/#Function-like-objects-1">Functors</a> for dynamical systems where the equations of motion contain parameters.</p><p><a id="Defining-a-DynamicalSystem-using-Functors-1"></a></p><h3 id="defining-a-dynamicalsystem-using-functors">Defining a <code>DynamicalSystem</code> using Functors</h3><p>A Functor is a shorthand for saying <a href="https://docs.julialang.org/en/stable/manual/methods/#Function-like-objects-1">Function-like objects</a>, i.e. <code>struct</code>s that are also callable (see the linked documentation page). Using such objects one can create both the equations of motion and a parameter container under a single <code>struct</code> definition.</p><p>For example, let's take a look at the source code that generates continuous Rössler system, from the <a href="#predefined-systems">Predefined Systems</a>:</p><div class="codehilite"><pre><span></span><span class="k">using</span> <span class="n">DynamicalSystems</span>
<span class="n">mutable</span> <span class="n">struct</span> <span class="n">Rössler</span>
    <span class="n">a</span><span class="o">::</span><span class="kt">Float64</span>
    <span class="n">b</span><span class="o">::</span><span class="kt">Float64</span>
    <span class="n">c</span><span class="o">::</span><span class="kt">Float64</span>
<span class="k">end</span>
<span class="k">function</span> <span class="p">(</span><span class="n">s</span><span class="o">::</span><span class="n">Rössler</span><span class="p">)(</span><span class="n">du</span><span class="o">::</span><span class="n">EomVector</span><span class="p">,</span> <span class="n">u</span><span class="o">::</span><span class="n">EomVector</span><span class="p">)</span>
    <span class="n">du</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">u</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">u</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">du</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">s</span><span class="o">.</span><span class="n">a</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">du</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">b</span> <span class="o">+</span> <span class="n">u</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">s</span><span class="o">.</span><span class="n">c</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">nothing</span>
<span class="k">end</span>
<span class="k">function</span> <span class="p">(</span><span class="n">s</span><span class="o">::</span><span class="n">Rössler</span><span class="p">)(</span><span class="n">J</span><span class="o">::</span><span class="n">EomMatrix</span><span class="p">,</span> <span class="n">u</span><span class="o">::</span><span class="n">EomVector</span><span class="p">)</span>
    <span class="n">J</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">a</span>
    <span class="n">J</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span> <span class="n">J</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">s</span><span class="o">.</span><span class="n">c</span>
    <span class="k">return</span> <span class="nb">nothing</span>
<span class="k">end</span>
</pre></div><p>The first code-block defines a <code>struct</code> that is simply a container for the parameters of the Rössler system. The second code-block defines the equations of motion of the system, by taking advantage of the fact that you can <em>call</em> this <code>struct</code> as if it was a function:</p><div class="codehilite"><pre><span></span><span class="n">s</span> <span class="o">=</span> <span class="n">Rössler</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">rand</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span> <span class="n">du</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
<span class="n">s</span><span class="p">(</span><span class="n">du</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
<span class="n">du</span> <span class="o">==</span> <span class="n">u</span>
</pre></div><div class="codehilite"><pre><span></span>false
</pre></div><p>The third code-block then defines the Jacobian function using multiple dispatch. This allows us to use the <em>same</em> instance of <code>Rössler</code> for <em>both</em> the equations of motion <em>and</em> the Jacobian function!</p><div class="admonition important"><p class="admonition-title">Use <code>EomVector</code> and <code>EomMatrix</code></p><p>The Types <code>EomVector</code> and <code>EomMatrix</code> are simple aliases exported by our package. They represent a <code>Union{}</code> over all possible vectors or matrices that are involved in the equations of motion as used in DynamicalSystems.jl (namely <code>Vector</code>, <code>SubArray</code> and <code>SVector</code>).</p><p><strong>You must define your equations of motion / Jacobian functions using these Types instead of a simple <code>Vector</code> or <code>Matrix</code>, otherwise functions like <code>lyapunovs</code> won't work properly.</strong></p></div><p>The possibility of providing an initialized Jacobian to the <code>ContinuousDS</code> constructor allows us to "cheat". Notice that the Jacobian function only accesses fields that depend on the parameters and/or the state variables, because the other fields are constants and will be initialized properly later.</p><p>Next, we define a "set-up" function, that returns a <code>ContinuousDS</code>:</p><div class="codehilite"><pre><span></span><span class="c"># this is in fact the function Systems.roessler()</span>
<span class="k">function</span> <span class="n">roessler</span><span class="p">(</span><span class="n">u0</span><span class="o">=</span><span class="n">rand</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span> <span class="n">a</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="mf">5.7</span><span class="p">)</span>
    <span class="c"># Initialize Jacobian matrix:</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">one</span><span class="p">(</span><span class="n">eltype</span><span class="p">(</span><span class="n">u0</span><span class="p">))</span>
    <span class="n">o</span> <span class="o">=</span> <span class="n">zero</span><span class="p">(</span><span class="n">eltype</span><span class="p">(</span><span class="n">u0</span><span class="p">))</span>
    <span class="n">J</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">eltype</span><span class="p">(</span><span class="n">u0</span><span class="p">),</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
    <span class="n">J</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="o">:</span><span class="p">]</span> <span class="o">.=</span> <span class="p">[</span><span class="n">o</span><span class="p">,</span> <span class="o">-</span><span class="n">i</span><span class="p">,</span>      <span class="o">-</span><span class="n">i</span><span class="p">]</span>
    <span class="n">J</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="o">:</span><span class="p">]</span> <span class="o">.=</span> <span class="p">[</span><span class="n">i</span><span class="p">,</span>  <span class="n">a</span><span class="p">,</span>       <span class="n">o</span><span class="p">]</span>
    <span class="n">J</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="o">:</span><span class="p">]</span> <span class="o">.=</span> <span class="p">[</span><span class="n">u0</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">o</span><span class="p">,</span> <span class="n">u0</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">c</span><span class="p">]</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">Rössler</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
    <span class="c"># Pass the same system to both fields!</span>
    <span class="k">return</span> <span class="n">ContinuousDS</span><span class="p">(</span><span class="n">u0</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">J</span><span class="p">)</span>
<span class="k">end</span>

<span class="n">ds</span> <span class="o">=</span> <span class="n">roessler</span><span class="p">()</span>
</pre></div><div class="codehilite"><pre><span></span>3-dimensional continuous dynamical system:
state: [0.274332, 0.89272, 0.733955]
eom: ex-1.Rössler
</pre></div><p>Then, it is trivial to change a parameter of the system by e.g. doing <code>ds.eom!.c = 2.2</code>. Notice that this parameter change will affect both the equations of motion as well as the Jacobian function, making everything concise and easy-to-use!</p><div class="admonition info"><p class="admonition-title"><code>Vectors</code> vs. <code>SVectors</code> for continuous systems.</p><p>There is no distinction based on the size of the system for continuous because using <code>SVectors</code> or in-place operations with normal <code>Vectors</code> yield almost no speed differences in conjunction with <a href="http://docs.juliadiffeq.org/stable/index.html">DifferentialEquations.jl</a> for small dimensions.</p></div><p>An example of a system definition without Functors is <a href="#defining-a-dynamicalsystem-without-functors">also shown here</a>.</p><hr/><p><a id="Discrete-Systems-1"></a></p><h2 id="discrete-systems">Discrete Systems</h2><p>Discrete systems are of the form:</p><div><div class="MathJax_Preview">
\vec{x}_{n+1} = \vec{f}(\vec{x}_n).
</div><script type="math/tex; mode=display">
\vec{x}_{n+1} = \vec{f}(\vec{x}_n).
</script></div><p>DynamicalSystems.jl categorizes discrete systems in three cases, due to the extremely performant handling that <a href="https://github.com/JuliaArrays/StaticArrays.jl"><code>StaticArrays</code></a> offers for small dimensionalities.</p><p><a id="High-Dimensional-Discrete-Systems-1"></a></p><h3 id="high-dimensional-discrete-systems">High-Dimensional Discrete Systems</h3><p>At around <code>D=10</code> dimensions, Static Arrays start to become less efficient than Julia's base Arrays, provided that the latter use in-place operations. For cases of discrete systems with much high dimensionality, we offer a type called <code>BigDiscreteDS</code>:</p><p><a href="#DynamicalSystems.BigDiscreteDS" id="DynamicalSystems.BigDiscreteDS">#</a><strong><code>DynamicalSystems.BigDiscreteDS</code></strong> — <em>Type</em>.</p><div class="codehilite"><pre><span></span>BigDiscreteDS(state, eom! [, jacob! [, J]]) &lt;: DynamicalSystem
</pre></div><p><code>D</code>-dimensional discrete dynamical system (used for big <code>D</code>). The equations for this system perform all operations <em>in-place</em>.</p><p><strong>Fields:</strong></p><ul><li><code>state::Vector{T}</code> : Current state-vector of the system. Do <code>ds.state .= u</code> to change the state.</li><li><code>eom!</code> (function) : The function that represents the system's equations of motion (also called vector field). The function is of the format: <code>eom!(xnew, x)</code> which means that given a state-vector <code>x</code> and another similar one <code>xnew</code>, it writes in-place the new state in <code>xnew</code>.</li><li><code>jacob!</code> (function) : A function that calculates the system's jacobian matrix, based on the format: <code>jacob!(J, x)</code> which means that given a state-vector <code>x</code> it writes in-place the Jacobian in <code>J</code>.</li><li><code>J::Matrix{T}</code> : Initialized Jacobian matrix (optional).</li><li><code>dummystate::Vector{T}</code> : Dummy vector, which most of the time fills the role of the previous state in e.g. <a href="./#DynamicalSystems.evolve"><code>evolve</code></a>.</li></ul><p>Only the first two fields of this type are displayed during print.</p><p>As mentioned in our <a href="https://juliadynamics.github.io/DynamicalSystems.jl/latest/system_definition#example-using-functors">official documentation</a>, it is preferred to use Functors for both the equations of motion and the Jacobian.</p><p>If the <code>jacob</code> is not provided by the user, it is created automatically using the module <a href="http://www.juliadiff.org/ForwardDiff.jl/stable/"><code>ForwardDiff</code></a>.</p><p><a class="documenter-source" href="https://github.com/JuliaDynamics/DynamicalSystems.jl/blob/ad2b0c0e81e05f7cf3c1bbd69ed79b6cde4ae51e/src/systems/discrete.jl#L78-L103" target="_blank">source</a><br/></p><p>This system is identical to <a href="./#DynamicalSystems.ContinuousDS"><code>ContinuousDS</code></a> as far as definition is concerned. All operations are done in place, and the type is immutable. The same suggestions about using Functors and initialized Jacobians also apply here.</p><p>See the source code of the pre-defined <a href="https://juliadynamics.github.io/DynamicalSystems.jl/latest/system_definition/#DynamicalSystems.Systems.coupledstandardmaps">coupled standard maps</a> for an example of a <code>BigDiscreteDS</code> definition.</p><hr/><p><a id="Low-dimensional-Discrete-Systems-1"></a></p><h3 id="low-dimensional-discrete-systems">Low-dimensional Discrete Systems</h3><p>The definition of low-dimensional discrete systems differs fundamentally from high dimensional ones, because everything is <em>much</em> more efficiently done with statically sized vectors. The Type representing such systems is called <code>DiscreteDS</code>:</p><p><a href="#DynamicalSystems.DiscreteDS" id="DynamicalSystems.DiscreteDS">#</a><strong><code>DynamicalSystems.DiscreteDS</code></strong> — <em>Type</em>.</p><div class="codehilite"><pre><span></span>DiscreteDS(state, eom [, jacob]) &lt;: DynamicalSystem
</pre></div><p><code>D</code>-dimensional discrete dynamical system.</p><p><strong>Fields:</strong></p><ul><li><code>state::SVector{D}</code> : Current state-vector of the system, stored in the data format of <code>StaticArray</code>'s <code>SVector</code>. Use <code>ds.state = newstate</code> to set a new state.</li><li><code>eom</code> (function) : The function that represents the system's equations of motion (also called vector field). The function is of the format: <code>eom(u) -&gt; SVector</code> which means that given a state-vector <code>u</code> it returns an <code>SVector</code> containing the next state.</li><li><code>jacob</code> (function) : A function that calculates the system's jacobian matrix, based on the format: <code>jacob(u) -&gt; SMatrix</code> which means that given a state-vector <code>u</code> it returns an <code>SMatrix</code> containing the Jacobian at that state.</li></ul><p>Only the first two fields of this type are displayed during print.</p><p>If the <code>jacob</code> is not provided by the user, it is created automatically using the module <a href="http://www.juliadiff.org/ForwardDiff.jl/stable/"><code>ForwardDiff</code></a>.</p><p><a class="documenter-source" href="https://github.com/JuliaDynamics/DynamicalSystems.jl/blob/ad2b0c0e81e05f7cf3c1bbd69ed79b6cde4ae51e/src/systems/discrete.jl#L11-L29" target="_blank">source</a><br/></p><p>The documentation string of the constructor is perfectly self-contained, but for the sake of clarity we will go through all the steps in the following.</p><p><code>state</code> is simply the state the system starts (a.k.a. initial conditions) and is always of type <code>SVector</code> from <a href="https://github.com/JuliaArrays/StaticArrays.jl"><code>StaticArrays.jl</code></a>. <code>eom</code> is a <em>function</em> that takes a <code>state</code> as an input and returns the next state as an output. The <code>jacob</code> is also a <em>function</em> that takes a <code>state</code> as an input and returns the Jacobian matrix of the system (at this state). So far this is actually different than <code>BigDiscreteDS</code> where the functions where in-place.</p><div class="admonition note"><p class="admonition-title">Return form of the <code>eom</code> function</p><p>It is <strong>heavily</strong> advised that the equations of motion <code>eom</code> function returns an <code>SVector</code> from the julia package <a href="https://github.com/JuliaArrays/StaticArrays.jl"><code>StaticArrays.jl</code></a> and similarly the <code>jacob</code> function returns an <code>SMatrix</code>. <a href="https://github.com/Datseris/DynamicalSystems.jl/tree/master/test/benchmarks">Numerous benchmarks</a> have been made in order to deduce the most efficient way to define a system, and this way was proved to be the best when the system's dimension is small.</p></div><p>Something important to note when defining a <code>DiscreteDS</code> using Functors: since the function calls take only one argument (always a state), it is impossible to use multiple dispatch to differentiate between a call to the e.o.m. or the Jacobian functions.</p><p>However, it is very easy to still define both function calls using a single <code>struct</code>, by using a 2 argument function given to the constructor. For example:</p><div class="codehilite"><pre><span></span><span class="k">using</span> <span class="n">DynamicalSystems</span>
<span class="k">using</span> <span class="n">StaticArrays</span> <span class="c"># only necessary when defining a system</span>

<span class="k">function</span> <span class="n">henon</span><span class="p">(</span><span class="n">u0</span><span class="o">=</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span> <span class="n">a</span> <span class="o">=</span> <span class="mf">1.4</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mf">0.3</span><span class="p">)</span>
    <span class="n">he</span> <span class="o">=</span> <span class="n">HénonMap</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
    <span class="c"># The jacobian function: (still uses the HénonMap)</span>
    <span class="nd">@inline</span> <span class="n">jacob_henon</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="n">he</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">nothing</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">DiscreteDS</span><span class="p">(</span><span class="n">u0</span><span class="p">,</span> <span class="n">he</span><span class="p">,</span> <span class="n">jacob_henon</span><span class="p">)</span>
<span class="k">end</span>
<span class="n">mutable</span> <span class="n">struct</span> <span class="n">HénonMap</span>
    <span class="n">a</span><span class="o">::</span><span class="kt">Float64</span>
    <span class="n">b</span><span class="o">::</span><span class="kt">Float64</span>
<span class="k">end</span>
<span class="p">(</span><span class="n">f</span><span class="o">::</span><span class="n">HénonMap</span><span class="p">)(</span><span class="n">x</span><span class="o">::</span><span class="n">EomVector</span><span class="p">)</span> <span class="o">=</span> <span class="n">SVector</span><span class="p">{</span><span class="mi">2</span><span class="p">}(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">f</span><span class="o">.</span><span class="n">a</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">f</span><span class="o">.</span><span class="n">b</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="p">(</span><span class="n">f</span><span class="o">::</span><span class="n">HénonMap</span><span class="p">)(</span><span class="n">x</span><span class="o">::</span><span class="n">EomVector</span><span class="p">,</span> <span class="n">no</span><span class="o">::</span><span class="kt">Void</span><span class="p">)</span> <span class="o">=</span> <span class="nd">@SMatrix</span> <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="o">.</span><span class="n">a</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="mf">1.0</span><span class="p">;</span> <span class="n">f</span><span class="o">.</span><span class="n">b</span> <span class="mf">0.0</span><span class="p">]</span>

<span class="n">ds</span> <span class="o">=</span> <span class="n">henon</span><span class="p">()</span>
</pre></div><div class="codehilite"><pre><span></span>2-dimensional discrete system
 state: [0.0, 0.0]
 eom: ex-henon.HénonMap
</pre></div><p>In this case, doing <code>ds.eom.a = 2.5</code> would still affect <em>both</em> the equations of motion as well as the Jacobian, making everything work perfectly!</p><p><a id="Defining-a-DynamicalSystem-without-Functors-1"></a></p><h4 id="defining-a-dynamicalsystem-without-functors">Defining a <code>DynamicalSystem</code> without Functors</h4><p>As an example of defining a system without using Functors, let's create another one of the <a href="#predefined-systems">Predefined Systems</a> offered by this package, the Folded Towel map.</p><p>Because this map doesn't have any parameters, it is unnecessary to associate a Functor with it.</p><div class="codehilite"><pre><span></span><span class="k">using</span> <span class="n">DynamicalSystems</span>
<span class="k">using</span> <span class="n">StaticArrays</span> <span class="c"># only necessary when defining a system</span>

<span class="nd">@inline</span> <span class="nd">@inbounds</span> <span class="k">function</span> <span class="n">eom_towel</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">x3</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="n">SVector</span><span class="p">(</span> <span class="mf">3.8</span><span class="o">*</span><span class="n">x1</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">x1</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.05</span><span class="o">*</span><span class="p">(</span><span class="n">x2</span><span class="o">+</span><span class="mf">0.35</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">x3</span><span class="p">),</span>
<span class="mf">0.1</span><span class="o">*</span><span class="p">(</span> <span class="p">(</span><span class="n">x2</span><span class="o">+</span><span class="mf">0.35</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">x3</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mf">1.9</span><span class="o">*</span><span class="n">x1</span><span class="p">),</span>
<span class="mf">3.78</span><span class="o">*</span><span class="n">x3</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">x3</span><span class="p">)</span><span class="o">+</span><span class="mf">0.2</span><span class="o">*</span><span class="n">x2</span> <span class="p">)</span>
<span class="k">end</span>

<span class="nd">@inline</span> <span class="nd">@inbounds</span> <span class="k">function</span> <span class="n">jacob_towel</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="nd">@SMatrix</span> <span class="p">[</span><span class="mf">3.8</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">2</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span><span class="mf">0.05</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="mi">2</span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="mf">0.1</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.35</span><span class="p">);</span>
    <span class="o">-</span><span class="mf">0.19</span><span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.35</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="mi">2</span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>  <span class="mf">0.1</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="mi">2</span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="mf">1.9</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>  <span class="o">-</span><span class="mf">0.2</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.35</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="mf">1.9</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="mf">0.0</span>  <span class="mf">0.2</span>  <span class="mf">3.78</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="mi">2</span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="p">]</span>
<span class="k">end</span>

<span class="n">u0</span><span class="o">=</span><span class="p">[</span><span class="mf">0.085</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.121</span><span class="p">,</span> <span class="mf">0.075</span><span class="p">]</span>
<span class="n">towel</span> <span class="o">=</span>  <span class="n">DiscreteDS</span><span class="p">(</span><span class="n">u0</span><span class="p">,</span> <span class="n">eom_towel</span><span class="p">,</span> <span class="n">jacob_towel</span><span class="p">)</span>
</pre></div><div class="codehilite"><pre><span></span>3-dimensional discrete system
 state: [0.085, -0.121, 0.075]
 eom: ex-2.#eom_towel
</pre></div><p>If we did not want to write a Jacobian for it, we could do</p><div class="codehilite"><pre><span></span><span class="n">towl_nojac</span> <span class="o">=</span> <span class="n">DiscreteDS</span><span class="p">(</span><span class="n">rand</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">eom_towel</span><span class="p">)</span>
</pre></div><p>and the Jacobian function is created automatically.</p><p><a id="dimensional-Discrete-Systems-1"></a></p><h3 id="1-dimensional-discrete-systems">1-dimensional Discrete Systems</h3><p>In the case of maps, there a special structure for one-dimensional systems. The syntax is <code>DiscreteDS1D(state, eom [, deriv])</code>. In this one-dimensional case, you don't need to worry about StaticArrays.jl because everything is in plain numbers. For example:</p><div class="codehilite"><pre><span></span><span class="k">using</span> <span class="n">DynamicalSystems</span>

<span class="nd">@inline</span> <span class="n">eom_logistic</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">r</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">x</span><span class="p">)</span>  <span class="c"># this is a closure</span>
<span class="nd">@inline</span> <span class="n">deriv_logistic</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">r</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="mi">2</span><span class="n">x</span><span class="p">)</span> <span class="c"># this is a closure</span>
<span class="n">r</span> <span class="o">=</span> <span class="mf">3.7</span>
<span class="n">logistic</span> <span class="o">=</span> <span class="n">DiscreteDS1D</span><span class="p">(</span><span class="n">rand</span><span class="p">(),</span> <span class="n">eom_logistic</span><span class="p">(</span><span class="n">r</span><span class="p">),</span> <span class="n">deriv_logistic</span><span class="p">(</span><span class="n">r</span><span class="p">))</span>
</pre></div><div class="codehilite"><pre><span></span>1-dimensional discrete dynamical system:
state: 0.045600796480044226
eom: ex-3.##1#2{Float64}
</pre></div><p>Once again, if you skip the derivative functions it will be calculated automatically using ForwardDiff.jl.</p><hr/><p><a id="System-evolution-1"></a></p><h2 id="system-evolution">System evolution</h2><p>DynamicalSystems.jl provides convenient interfaces for the evolution of systems.</p><p><a href="#DynamicalSystems.evolve" id="DynamicalSystems.evolve">#</a><strong><code>DynamicalSystems.evolve</code></strong> — <em>Function</em>.</p><div class="codehilite"><pre><span></span><span class="nt">evolve</span><span class="o">(</span><span class="nt">ds</span><span class="p">::</span><span class="nd">DynamicalSystem</span><span class="o">,</span> <span class="nt">T</span><span class="o">=</span><span class="nt">1</span> <span class="cp">[</span><span class="p">,</span> <span class="nx">u0</span><span class="cp">]</span><span class="o">;</span> <span class="nt">diff_eq_kwargs</span> <span class="o">=</span> <span class="nt">Dict</span><span class="o">())</span>
</pre></div><p>Evolve the <code>ds.state</code> (or <code>u0</code> if given) for total time <code>T</code> and return the <code>final_state</code>. For discrete systems <code>T</code> corresponds to steps and thus it must be integer.</p><p>Notice that for <code>BigDiscreteDS</code> a <em>copy</em> of <code>ds.state</code> is made for no given <code>u0</code>, so that <code>ds.state</code> is not mutated.</p><p><code>evolve</code><em>does not store</em> any information about intermediate steps. Use <a href="./#DynamicalSystems.trajectory"><code>trajectory</code></a> if you want to produce a trajectory of the system. If you want to perform step-by-step evolution of a continuous system, use <code>ODEIntegrator(ds, args...)</code> and the <code>step!(integrator)</code> function provided by <a href="https://github.com/JuliaDiffEq/DifferentialEquations.jl"><code>DifferentialEquations</code></a>.</p><p><a class="documenter-source" href="https://github.com/JuliaDynamics/DynamicalSystems.jl/blob/ad2b0c0e81e05f7cf3c1bbd69ed79b6cde4ae51e/src/systems/discrete.jl#L151-L167" target="_blank">source</a><br/></p><p><a href="#DynamicalSystems.trajectory" id="DynamicalSystems.trajectory">#</a><strong><code>DynamicalSystems.trajectory</code></strong> — <em>Function</em>.</p><div class="codehilite"><pre><span></span><span class="n">trajectory</span><span class="p">(</span><span class="n">ds</span><span class="o">::</span><span class="n">DynamicalSystem</span><span class="p">,</span> <span class="n">T</span><span class="p">;</span> <span class="n">kwargs</span><span class="o">...</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">dataset</span>
</pre></div><p>Return a dataset what will contain the trajectory of the sytem, after evolving it for time <code>T</code>. See <a href="./#DynamicalSystems.Dataset"><code>Dataset</code></a> for info on how to manipulate this object.</p><p>For the discrete case, <code>T</code> is an integer and a <code>T×D</code> dataset is returned (<code>D</code> is the system dimensionality). For the continuous case, a <code>W×D</code> dataset is returned, with <code>W = length(0:dt:T)</code> with <code>0:dt:T</code> representing the time vector (<em>not</em> returned).</p><p><strong>Keyword Arguments</strong></p><ul><li><code>dt = 0.05</code> : (only for continuous) Time step of value output during the solving of the continuous system.</li><li><code>diff_eq_kwargs = Dict()</code> : (only for continuous) A dictionary <code>Dict{Symbol, ANY}</code> of keyword arguments passed into the <code>solve</code> of the <code>DifferentialEquations.jl</code> package, for example <code>Dict(:abstol =&gt; 1e-9)</code>. If you want to specify a solver, do so by using the symbol <code>:solver</code>, e.g.: <code>Dict(:solver =&gt; DP5(), :maxiters =&gt; 1e9)</code>. This requires you to have been first <code>using OrdinaryDiffEq</code> to access the solvers.</li></ul><p><a class="documenter-source" href="https://github.com/JuliaDynamics/DynamicalSystems.jl/blob/ad2b0c0e81e05f7cf3c1bbd69ed79b6cde4ae51e/src/systems/discrete.jl#L185-L207" target="_blank">source</a><br/></p><p>Especially in the continuous case, an API is provided for usage directly with <a href="https://github.com/JuliaDiffEq/DifferentialEquations.jl">DifferentialEquations.jl</a>, by giving additional constructors:</p><p><a href="#DiffEqBase.ODEProblem" id="DiffEqBase.ODEProblem">#</a><strong><code>DiffEqBase.ODEProblem</code></strong> — <em>Type</em>.</p><div class="codehilite"><pre><span></span><span class="n">ODEProblem</span><span class="p">(</span><span class="n">ds</span><span class="o">::</span><span class="n">ContinuousDS</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
</pre></div><p>Return an <code>ODEProblem</code> with the given system information (t0 is zero). This can be passed directly into <code>solve</code> from <a href="http://docs.juliadiffeq.org/stable/index.html"><code>DifferentialEquations.jl</code></a>.</p><p><a class="documenter-source" href="https://github.com/JuliaDynamics/DynamicalSystems.jl/blob/ad2b0c0e81e05f7cf3c1bbd69ed79b6cde4ae51e/src/systems/continuous.jl#L79-L86" target="_blank">source</a><br/></p><p><a href="#OrdinaryDiffEq.ODEIntegrator" id="OrdinaryDiffEq.ODEIntegrator">#</a><strong><code>OrdinaryDiffEq.ODEIntegrator</code></strong> — <em>Type</em>.</p><div class="codehilite"><pre><span></span><span class="n">ODEIntegrator</span><span class="p">(</span><span class="n">ds</span><span class="o">::</span><span class="n">ContinuousDS</span><span class="p">,</span> <span class="n">t</span><span class="p">;</span> <span class="n">diff_eq_kwargs</span><span class="p">)</span>
</pre></div><p>Return an <code>ODEIntegrator</code>, by first creating an <code>ODEProblem(ds, t)</code>. This can be used directly with the interfaces of <a href="http://docs.juliadiffeq.org/stable/index.html"><code>DifferentialEquations.jl</code></a>.</p><p><code>diff_eq_kwargs = Dict()</code> is a dictionary <code>Dict{Symbol, ANY}</code> of keyword arguments passed into the <code>init</code> of the <a href="http://docs.juliadiffeq.org/stable/index.html"><code>DifferentialEquations.jl</code></a> package, for example <code>Dict(:abstol =&gt; 1e-9)</code>. If you want to specify a solver, do so by using the symbol <code>:solver</code>, e.g.: <code>Dict(:solver =&gt; DP5(), :tstops =&gt; 0:0.01:t)</code>. This requires you to have been first <code>using OrdinaryDiffEq</code> to access the solvers.</p><p><a class="documenter-source" href="https://github.com/JuliaDynamics/DynamicalSystems.jl/blob/ad2b0c0e81e05f7cf3c1bbd69ed79b6cde4ae51e/src/systems/continuous.jl#L94-L110" target="_blank">source</a><br/></p><p><a href="#DynamicalSystems.variational_integrator" id="DynamicalSystems.variational_integrator">#</a><strong><code>DynamicalSystems.variational_integrator</code></strong> — <em>Function</em>.</p><div class="codehilite"><pre><span></span>variational_integrator(ds::ContinuousDS, k::Int, tfinal, S::Matrix, kwargs...)
</pre></div><p>Return an <code>ODEIntegrator</code> that represents the variational equations of motion for the system. Used in <a href="../lyapunovs/#DynamicalSystems.lyapunovs"><code>lyapunovs</code></a> and <a href="../chaos_detection/#DynamicalSystems.gali"><code>gali</code></a>.</p><p>It evolves in parallel <code>ds.state</code> and <code>k</code> deviation vectors <span><span class="MathJax_Preview">w_i</span><script type="math/tex">w_i</script></span> such that <span><span class="MathJax_Preview">\dot{w}_i = J\times w_i</span><script type="math/tex">\dot{w}_i = J\times w_i</script></span> with <span><span class="MathJax_Preview">J</span><script type="math/tex">J</script></span> the Jacobian at the current state. <code>S</code> is the initial "conditions" which contain both the system's state as well as the initial diviation vectors: <code>S = cat(2, ds.state, ws)</code> if <code>ws</code> is a matrix that has as <em>columns</em> the initial deviation vectors.</p><p>The only keyword argument for this funcion is <code>diff_eq_kwargs = Dict()</code> (see <a href="./#DynamicalSystems.trajectory"><code>trajectory</code></a>).</p><p><a class="documenter-source" href="https://github.com/JuliaDynamics/DynamicalSystems.jl/blob/ad2b0c0e81e05f7cf3c1bbd69ed79b6cde4ae51e/src/systems/continuous.jl#L132-L146" target="_blank">source</a><br/></p><p>Notice that if you want to do repeated evolutions of different states of a continuous system, you should use the <code>ODEIntegrator(ds::DynamicalSystem)</code> in conjunction with <code>DifferentialEquations.reinit!(integrator, newstate)</code> to avoid the intermediate initializations of the integrator each time. –-</p><p><a id="Coordination-with-other-packages-1"></a></p><h2 id="coordination-with-other-packages">Coordination with other packages</h2><p>One more advantage of using <a href="https://docs.julialang.org/en/stable/manual/methods/#Function-like-objects-1">Functors</a>, is that it offers a universal definition of your equations of motion that fits both the expected structure of DynamicalSystems.jl as well as other packages.</p><p>For example, take a look at the following code:</p><div class="codehilite"><pre><span></span><span class="n">mutable</span> <span class="n">struct</span> <span class="n">Rössler</span>
    <span class="n">a</span><span class="o">::</span><span class="kt">Float64</span>
    <span class="n">b</span><span class="o">::</span><span class="kt">Float64</span>
    <span class="n">c</span><span class="o">::</span><span class="kt">Float64</span>
<span class="k">end</span>
<span class="c"># E.o.m. as expected by DynamicalSystems.jl:</span>
<span class="nd">@inline</span> <span class="nd">@inbounds</span> <span class="k">function</span> <span class="p">(</span><span class="n">s</span><span class="o">::</span><span class="n">Rössler</span><span class="p">)(</span><span class="n">du</span><span class="o">::</span><span class="n">EomVector</span><span class="p">,</span> <span class="n">u</span><span class="o">::</span><span class="n">EomVector</span><span class="p">)</span>
    <span class="n">du</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">u</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">u</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">du</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">s</span><span class="o">.</span><span class="n">a</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">du</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">b</span> <span class="o">+</span> <span class="n">u</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">s</span><span class="o">.</span><span class="n">c</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">nothing</span>
<span class="k">end</span>
<span class="c"># E.o.m. as expected by e.g. LTISystems.jl or OrdinaryDiffEq.jl:</span>
<span class="nd">@inline</span> <span class="nd">@inbounds</span> <span class="p">(</span><span class="n">s</span><span class="o">::</span><span class="n">Rössler</span><span class="p">)(</span><span class="n">t</span><span class="o">::</span><span class="kt">Real</span><span class="p">,</span> <span class="n">u</span><span class="o">::</span><span class="n">EomVector</span><span class="p">,</span> <span class="n">du</span><span class="o">::</span><span class="n">EomVector</span><span class="p">)</span> <span class="o">=</span> <span class="n">s</span><span class="p">(</span><span class="n">du</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
</pre></div><p>You could then give <code>s = Rössler(1, 2)</code> to <code>ContinuousDS</code><em>as well as</em> the interfaces of e.g. <a href="https://github.com/JuliaSystems/LTISystems.jl">LTISystems.jl</a> and everything will "just work"!</p><hr/><p><a id="Numerical-Data-1"></a></p><h2 id="numerical-data">Numerical Data</h2><p>Numerical data in DynamicalSystems.jl is represented by a structure called <code>Dataset</code>:</p><p><a href="#DynamicalSystems.Dataset" id="DynamicalSystems.Dataset">#</a><strong><code>DynamicalSystems.Dataset</code></strong> — <em>Type</em>.</p><div class="codehilite"><pre><span></span>Dataset{D, T} &lt;: AbstractDataset{D,T}
</pre></div><p>A dedicated interface for datasets, i.e. vectors of vectors. It contains <strong>equally-sized datapoints</strong> of length <code>D</code>, represented by <code>SVector{D, T}</code>, containing numbers of type <code>T</code>.</p><p>The internal data representation is more efficient than having a <code>Matrix</code> and also leads to faster numerical computation of other quantities (like e.g. entropies). However, it can be used exactly like a matrix that has each of the columns be the timeseries of each of the dynamic variables. <a href="./#DynamicalSystems.trajectory"><code>trajectory</code></a> always returns a <code>Dataset</code>.</p><p>For example,</p><div class="codehilite"><pre><span></span><span class="n">ds</span> <span class="o">=</span> <span class="n">Systems</span><span class="o">.</span><span class="n">towel</span><span class="p">()</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">trajectory</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span> <span class="c">#this returns a dataset</span>
<span class="n">data</span><span class="p">[</span><span class="o">:</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="c"># this is the second variable timeseries</span>
<span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">:</span><span class="p">]</span> <span class="c"># this is the first datapoint (D-dimensional)</span>
<span class="n">data</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="c"># value of the third variable, at the 5th timepoint</span>
</pre></div><p>Use <code>convert(Matrix, dataset)</code> to create a <code>Matrix</code>, and <code>convert(Dataset, matrix)</code> to create a <code>Dataset</code> from a matrix. Notice: <code>convert(Dataset, matrix)</code> assumes that each column of the matrix represents one dynamic variable. If instead each column of the matrix represents a datapoint, use <code>reinterpret(Dataset, matrix)</code>.</p><p>If you have various timeseries vectors <code>x, y, z, ...</code> pass them like <code>Dataset(x, y, z, ...)</code>.</p><p><a class="documenter-source" href="https://github.com/JuliaDynamics/DynamicalSystems.jl/blob/ad2b0c0e81e05f7cf3c1bbd69ed79b6cde4ae51e/src/systems/dataset.jl#L35-L64" target="_blank">source</a><br/></p><hr/><p>In essence a <code>Dataset</code> is simply a container for a <code>Vector</code> of <code>SVector</code>s. However, it is visually represented as a matrix, similarly to how numerical data would be printed on a spreadsheet (with time being the <em>column</em> direction). It also offers a lot more functionality than just pretty-printing. Besides the examples in the documentation string, you can also do:</p><div class="codehilite"><pre><span></span><span class="k">using</span> <span class="n">DynamicalSystems</span>
<span class="n">hen</span> <span class="o">==</span> <span class="n">Systems</span><span class="o">.</span><span class="n">henon</span><span class="p">()</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">trajectory</span><span class="p">(</span><span class="n">hen</span><span class="p">,</span> <span class="mi">10000</span><span class="p">)</span>
<span class="k">for</span> <span class="n">point</span> <span class="kp">in</span> <span class="n">data</span>
<span class="c"># do stuff with each datapoint (vector with as many elements as system dimension)</span>
<span class="k">end</span>
</pre></div><p>All functions of our package that manipulate and use data are expecting an <code>AbstractDataset</code> subtype. This allows us to define efficient methods that coordinate well with other packages, like e.g. <a href="../nlts/#DynamicalSystems.neighborhood"><code>neighborhood</code></a>.</p><p>If given a matrix, we first convert to <code>Dataset</code>. This means that you should first convert your data to a <code>Dataset</code> if you want to call functions more than once, to avoid constantly converting.</p><hr/><p><a id="Predefined-Systems-1"></a></p><h2 id="predefined-systems">Predefined Systems</h2><p>Predefined systems exist in the <code>Systems</code> submodule exported by <code>DynamicalSystems</code>, in the form of functions that return a <code>DynamicalSystem</code>. They are accessed like:</p><div class="codehilite"><pre><span></span><span class="k">using</span> <span class="n">DynamicalSystems</span>
<span class="n">ds</span> <span class="o">=</span> <span class="n">Systems</span><span class="o">.</span><span class="n">lorenz</span><span class="p">(</span><span class="n">ρ</span> <span class="o">=</span> <span class="mf">32.0</span><span class="p">)</span>
<span class="n">typeof</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span> <span class="c"># ContinuousDS</span>
<span class="n">ts</span> <span class="o">=</span> <span class="n">trajectory</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">)</span>
</pre></div><p>So far, the predefined systems that exist in the <code>Systems</code> sub-module are:</p><p><a href="#DynamicalSystems.Systems.coupledstandardmaps" id="DynamicalSystems.Systems.coupledstandardmaps">#</a><strong><code>DynamicalSystems.Systems.coupledstandardmaps</code></strong> — <em>Function</em>.</p><div class="codehilite"><pre><span></span><span class="n">coupledstandardmaps</span><span class="p">(</span><span class="n">M</span><span class="o">::</span><span class="kt">Int</span><span class="p">,</span> <span class="n">u0</span> <span class="o">=</span> <span class="mf">0.001</span><span class="n">rand</span><span class="p">(</span><span class="mi">2</span><span class="n">M</span><span class="p">);</span> <span class="n">ks</span> <span class="o">=</span> <span class="n">ones</span><span class="p">(</span><span class="n">M</span><span class="p">),</span> <span class="n">Γ</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">)</span>
</pre></div><div><div class="MathJax_Preview">
\begin{aligned}
\theta_{i}' &amp;= \theta_i + p_{i}' \\
p_{i}' &amp;= p_i + k_i\sin(\theta_i) - \Gamma \left[
\sin(\theta_{i+1} - \theta_{i}) + \sin(\theta_{i-1} - \theta_{i})
\right]
\end{aligned}
</div><script type="math/tex; mode=display">
\begin{aligned}
\theta_{i}' &= \theta_i + p_{i}' \\
p_{i}' &= p_i + k_i\sin(\theta_i) - \Gamma \left[
\sin(\theta_{i+1} - \theta_{i}) + \sin(\theta_{i-1} - \theta_{i})
\right]
\end{aligned}
</script></div><p>A discrete system of <code>M</code> nonlinearly coupled standard maps, first introduced in [1] to study diffusion and chaos thresholds. The <em>total</em> dimension of the system is <code>2M</code>. The maps are coupled through <code>Γ</code> and the <code>i</code>-th map has a nonlinear parameter <code>ks[i]</code>.</p><p>The <code>eom!</code> field of the returned system has as fields the keyword arguments of this function. You can access them and change their value at any point using <code>ds.eom!.parameter = value</code>.</p><p>[1] : H. Kantz &amp; P. Grassberger, J. Phys. A <strong>21</strong>, pp 127–133 (1988)</p><p><a class="documenter-source" href="https://github.com/JuliaDynamics/DynamicalSystems.jl/blob/ad2b0c0e81e05f7cf3c1bbd69ed79b6cde4ae51e/src/systems/famous_systems.jl#L341-L364" target="_blank">source</a><br/></p><p><a href="#DynamicalSystems.Systems.double_pendulum" id="DynamicalSystems.Systems.double_pendulum">#</a><strong><code>DynamicalSystems.Systems.double_pendulum</code></strong> — <em>Function</em>.</p><div class="codehilite"><pre><span></span>double_pendulum(u0=rand(4); G=10.0, L1 = 1.0, L2 = 1.0, M1 = 1.0, M2 = 1.0)
</pre></div><p>Famous chaotic double pendulum system (also used for our logo!). Keywords are gravity (G), lengths of each rod and mass of each ball (all assumed SI units).</p><p>The variables order is [θ1, dθ1/dt, θ2, dθ2/dt].</p><p>Jacobian is created automatically (thus methods that use the Jacobian will be slower)!</p><p>(please contribute the Jacobian and the e.o.m. in LaTeX :smile:)</p><p>The <code>eom!</code> field of the returned system has as fields the keyword arguments of this function. You can access them and change their value at any point using <code>ds.eom!.parameter = value</code>.</p><p><a class="documenter-source" href="https://github.com/JuliaDynamics/DynamicalSystems.jl/blob/ad2b0c0e81e05f7cf3c1bbd69ed79b6cde4ae51e/src/systems/famous_systems.jl#L116-L130" target="_blank">source</a><br/></p><p><a href="#DynamicalSystems.Systems.henon" id="DynamicalSystems.Systems.henon">#</a><strong><code>DynamicalSystems.Systems.henon</code></strong> — <em>Function</em>.</p><div class="codehilite"><pre><span></span><span class="n">henon</span><span class="p">(</span><span class="n">u0</span><span class="o">=</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span> <span class="n">a</span> <span class="o">=</span> <span class="mf">1.4</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mf">0.3</span><span class="p">)</span>
</pre></div><div><div class="MathJax_Preview">
\begin{aligned}
x_{n+1} &amp;= 1 - ax^2_n+y_n \\
y_{n+1} &amp; = bx_n
\end{aligned}
</div><script type="math/tex; mode=display">
\begin{aligned}
x_{n+1} &= 1 - ax^2_n+y_n \\
y_{n+1} & = bx_n
\end{aligned}
</script></div><p>The Hénon map is a two-dimensional mapping due to Hénon [1] that can display a strange attractor (at the default parameters). In addition, it also displays many other aspects of chaos, like period doubling or intermittency, for other parameters.</p><p>According to the author, it is a system displaying all the properties of the Lorentz system (1963) while being as simple as possible. Default values are the ones used in the original paper.</p><p>The <code>eom</code> field of the returned system has as fields the keyword arguments of this function. You can access them and change their value at any point using <code>ds.eom.parameter = value</code>.</p><p>[1] : M. Hénon, Commun.Math. Phys. <strong>50</strong>, pp 69 (1976)</p><p><a class="documenter-source" href="https://github.com/JuliaDynamics/DynamicalSystems.jl/blob/ad2b0c0e81e05f7cf3c1bbd69ed79b6cde4ae51e/src/systems/famous_systems.jl#L423-L446" target="_blank">source</a><br/></p><p><a href="#DynamicalSystems.Systems.henonhelies" id="DynamicalSystems.Systems.henonhelies">#</a><strong><code>DynamicalSystems.Systems.henonhelies</code></strong> — <em>Function</em>.</p><div class="codehilite"><pre><span></span>henonhelies(u0=[0, -0.25, 0.42081,0]; λ = 1)
</pre></div><div><div class="MathJax_Preview">
\begin{aligned}
\dot{x} &amp;= p_x \\
\dot{y} &amp;= p_y \\
\dot{p}_x &amp;= -x -2\lambda xy \\
\dot{p}_y &amp;= -y -\lambda (x^2 - y^2)
\end{aligned}
</div><script type="math/tex; mode=display">
\begin{aligned}
\dot{x} &= p_x \\
\dot{y} &= p_y \\
\dot{p}_x &= -x -2\lambda xy \\
\dot{p}_y &= -y -\lambda (x^2 - y^2)
\end{aligned}
</script></div><p>The Hénon–Heiles system [1] was introduced as a simplification of the motion of a star around a galactic center. It was originally intended to study the existence of a "third integral of motion" (which would make this 4D system integrable). In that search, the authors encountered chaos, as the third integral existed for only but a few initial conditions.</p><p>The default initial condition is a typical chaotic orbit.</p><p>The <code>eom!</code> field of the returned system has as fields the keyword arguments of this function. You can access them and change their value at any point using <code>ds.eom!.parameter = value</code>.</p><p>[1] : Hénon, M. &amp; Heiles, C., The Astronomical Journal <strong>69</strong>, pp 73–79 (1964)</p><p><a class="documenter-source" href="https://github.com/JuliaDynamics/DynamicalSystems.jl/blob/ad2b0c0e81e05f7cf3c1bbd69ed79b6cde4ae51e/src/systems/famous_systems.jl#L164-L188" target="_blank">source</a><br/></p><p><a href="#DynamicalSystems.Systems.logistic" id="DynamicalSystems.Systems.logistic">#</a><strong><code>DynamicalSystems.Systems.logistic</code></strong> — <em>Function</em>.</p><div class="codehilite"><pre><span></span><span class="n">logistic</span><span class="p">(</span><span class="n">x0</span> <span class="o">=</span> <span class="n">rand</span><span class="p">();</span> <span class="n">r</span> <span class="o">=</span> <span class="mf">4.0</span><span class="p">)</span>
</pre></div><div><div class="MathJax_Preview">
x_{n+1} = rx_n(1-x_n)
</div><script type="math/tex; mode=display">
x_{n+1} = rx_n(1-x_n)
</script></div><p>The logistic map is an one dimensional unimodal mapping due to May [1] and is used by many as the archetypal example of how chaos can arise from very simple equations.</p><p>Originally intentend to be a discretized model of polulation dynamics, it is now famous for its bifurcation diagram, an immensly complex graph that that was shown be universal by Feigenbaum [2].</p><p>The <code>eom</code> field of the returned system has as fields the keyword arguments of this function. You can access them and change their value at any point using <code>ds.eom.parameter = value</code>.</p><p>[1] : R. M. May, Nature <strong>261</strong>, pp 459 (1976)</p><p>[2] : M. J. Feigenbaum, J. Stat. Phys. <strong>19</strong>, pp 25 (1978)</p><p><a class="documenter-source" href="https://github.com/JuliaDynamics/DynamicalSystems.jl/blob/ad2b0c0e81e05f7cf3c1bbd69ed79b6cde4ae51e/src/systems/famous_systems.jl#L461-L482" target="_blank">source</a><br/></p><p><a href="#DynamicalSystems.Systems.lorenz" id="DynamicalSystems.Systems.lorenz">#</a><strong><code>DynamicalSystems.Systems.lorenz</code></strong> — <em>Function</em>.</p><div class="codehilite"><pre><span></span><span class="n">lorenz</span><span class="p">(</span><span class="n">u0</span><span class="o">=</span><span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">];</span> <span class="n">σ</span> <span class="o">=</span> <span class="mf">10.0</span><span class="p">,</span> <span class="n">ρ</span> <span class="o">=</span> <span class="mf">28.0</span><span class="p">,</span> <span class="n">β</span> <span class="o">=</span> <span class="mi">8</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ds</span>
</pre></div><div><div class="MathJax_Preview">
\begin{aligned}
\dot{X} &amp;= \sigma(Y-X) \\
\dot{Y} &amp;= -XZ + \rho X -Y \\
\dot{Z} &amp;= XY - \beta Z
\end{aligned}
</div><script type="math/tex; mode=display">
\begin{aligned}
\dot{X} &= \sigma(Y-X) \\
\dot{Y} &= -XZ + \rho X -Y \\
\dot{Z} &= XY - \beta Z
\end{aligned}
</script></div><p>The famous three dimensional system due to Lorenz [1], shown to exhibit so-called "deterministic nonperiodic flow". It was originally invented to study a simplified form of atmospheric convection.</p><p>Currently, it is most famous for its strange attractor (occuring at the default parameters), which resembles a butterfly. For the same reason it is also associated with the term "butterfly effect" (a term which Lorenz himself disliked) even though the effect applies generally to dynamical systems. Default values are the ones used in the original paper.</p><p>The <code>eom!</code> field of the returned system has as fields the keyword arguments of this function. You can access them and change their value at any point using <code>ds.eom!.parameter = value</code>.</p><p>[1] : E. N. Lorenz, J. atmos. Sci. <strong>20</strong>, pp 130 (1963)</p><p><a class="documenter-source" href="https://github.com/JuliaDynamics/DynamicalSystems.jl/blob/ad2b0c0e81e05f7cf3c1bbd69ed79b6cde4ae51e/src/systems/famous_systems.jl#L11-L37" target="_blank">source</a><br/></p><p><a href="#DynamicalSystems.Systems.lorenz96" id="DynamicalSystems.Systems.lorenz96">#</a><strong><code>DynamicalSystems.Systems.lorenz96</code></strong> — <em>Function</em>.</p><div class="codehilite"><pre><span></span><span class="nt">lorenz96</span><span class="o">(</span><span class="nt">N</span><span class="p">::</span><span class="nd">Int</span><span class="o">,</span> <span class="nt">u0</span> <span class="o">=</span> <span class="nt">rand</span><span class="o">(</span><span class="nt">M</span><span class="o">);</span> <span class="nt">F</span><span class="o">=</span><span class="nt">0</span><span class="p">.</span><span class="nc">01</span><span class="o">)</span>
</pre></div><p><code>N</code> is the chain length, <code>F</code> the forcing. Jacobian is created automatically.</p><p><a class="documenter-source" href="https://github.com/JuliaDynamics/DynamicalSystems.jl/blob/ad2b0c0e81e05f7cf3c1bbd69ed79b6cde4ae51e/src/systems/famous_systems.jl#L217-L220" target="_blank">source</a><br/></p><p><a href="#DynamicalSystems.Systems.roessler" id="DynamicalSystems.Systems.roessler">#</a><strong><code>DynamicalSystems.Systems.roessler</code></strong> — <em>Function</em>.</p><div class="codehilite"><pre><span></span><span class="n">roessler</span><span class="p">(</span><span class="n">u0</span><span class="o">=</span><span class="n">rand</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span> <span class="n">a</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="mf">5.7</span><span class="p">)</span>
</pre></div><div><div class="MathJax_Preview">
\begin{aligned}
\dot{x} &amp;= -y-z \\
\dot{y} &amp;= x+ay \\
\dot{z} &amp;= -b + z(x-c)
\end{aligned}
</div><script type="math/tex; mode=display">
\begin{aligned}
\dot{x} &= -y-z \\
\dot{y} &= x+ay \\
\dot{z} &= -b + z(x-c)
\end{aligned}
</script></div><p>This three-dimensional continuous system is due to Rössler [1]. It is a system that by design behaves similarly to the <code>lorenz</code> system and displays a (fractal) strange attractor. However, it is easier to analyze qualitatively, as for example the attractor is composed of a single manifold. Default values are the same as the original paper.</p><p>The <code>eom!</code> field of the returned system has as fields the keyword arguments of this function. You can access them and change their value at any point using <code>ds.eom!.parameter = value</code>.</p><p>[1] : O. E. Rössler, Phys. Lett. <strong>57A</strong>, pp 397 (1976)</p><p><a class="documenter-source" href="https://github.com/JuliaDynamics/DynamicalSystems.jl/blob/ad2b0c0e81e05f7cf3c1bbd69ed79b6cde4ae51e/src/systems/famous_systems.jl#L64-L87" target="_blank">source</a><br/></p><p><a href="#DynamicalSystems.Systems.standardmap" id="DynamicalSystems.Systems.standardmap">#</a><strong><code>DynamicalSystems.Systems.standardmap</code></strong> — <em>Function</em>.</p><div class="codehilite"><pre><span></span><span class="n">standardmap</span><span class="p">(</span><span class="n">u0</span><span class="o">=</span><span class="mf">0.001</span><span class="n">rand</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span> <span class="n">k</span> <span class="o">=</span> <span class="mf">0.971635</span><span class="p">)</span>
</pre></div><div><div class="MathJax_Preview">
\begin{aligned}
\theta_{n+1} &amp;= \theta_n + p_{n+1} \\
p_{n+1} &amp;= p_n + k\sin(\theta_n)
\end{aligned}
</div><script type="math/tex; mode=display">
\begin{aligned}
\theta_{n+1} &= \theta_n + p_{n+1} \\
p_{n+1} &= p_n + k\sin(\theta_n)
\end{aligned}
</script></div><p>The standard map (also known as Chirikov standard map) is a two dimensional, area-preserving chaotic mapping due to Chirikov [1]. It is one of the most studied chaotic systems and by far the most studied Hamiltonian (area-preserving) mapping.</p><p>The map corresponds to the  Poincaré's surface of section of the kicked rotor system. Changing the non-linearity parameter <code>k</code> transitions the system from completely periodic motion, to quasi-periodic, to local chaos (mixed phase-space) and finally to global chaos.</p><p>The default parameter <code>k</code> is the critical parameter where the golden-ratio torus is destroyed, as was calculated by Greene [2]. The e.o.m. considers the angle variable <code>θ</code> to be the first, and the angular momentum <code>p</code> to be the second, while both variables are always taken modulo 2π (the mapping is on the [0,2π)² torus).</p><p>The <code>eom</code> field of the returned system has as fields the keyword arguments of this function. You can access them and change their value at any point using <code>ds.eom.parameter = value</code>.</p><p>[1] : B. V. Chirikov, Preprint N. <strong>267</strong>, Institute of Nuclear Physics, Novosibirsk (1969)</p><p>[2] : J. M. Greene, J. Math. Phys. <strong>20</strong>, pp 1183 (1979)</p><p><a class="documenter-source" href="https://github.com/JuliaDynamics/DynamicalSystems.jl/blob/ad2b0c0e81e05f7cf3c1bbd69ed79b6cde4ae51e/src/systems/famous_systems.jl#L285-L318" target="_blank">source</a><br/></p><p><a href="#DynamicalSystems.Systems.towel" id="DynamicalSystems.Systems.towel">#</a><strong><code>DynamicalSystems.Systems.towel</code></strong> — <em>Function</em>.</p><div class="codehilite"><pre><span></span><span class="n">towel</span><span class="p">(</span><span class="n">u0</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.085</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.121</span><span class="p">,</span> <span class="mf">0.075</span><span class="p">])</span>
</pre></div><div><div class="MathJax_Preview">
\begin{aligned}
x_{n+1} &amp;= a x_n (1-x_n) -0.05 (y_n +0.35) (1-2z_n) \\
y_{n+1} &amp;= 0.1 \left( \left( y_n +0.35 \right)\left( 1+2z_n\right) -1 \right)
\left( 1 -1.9 x_n \right) \\
z_{n+1} &amp;= 3.78 z_n (1-z_n) + b y_n
\end{aligned}
</div><script type="math/tex; mode=display">
\begin{aligned}
x_{n+1} &= a x_n (1-x_n) -0.05 (y_n +0.35) (1-2z_n) \\
y_{n+1} &= 0.1 \left( \left( y_n +0.35 \right)\left( 1+2z_n\right) -1 \right)
\left( 1 -1.9 x_n \right) \\
z_{n+1} &= 3.78 z_n (1-z_n) + b y_n
\end{aligned}
</script></div><p>The folded-towel map is a hyperchaotic mapping due to Rössler [1]. It is famous for being a mapping that has the smallest possible dimensions necessary for hyperchaos, having two positive and one negative Lyapunov exponent. The name comes from the fact that when plotted looks like a folded towel, in every projection.</p><p>Default values are the ones used in the original paper.</p><p>[1] : O. E. Rössler, Phys. Lett. <strong>71A</strong>, pp 155 (1979)</p><p><a class="documenter-source" href="https://github.com/JuliaDynamics/DynamicalSystems.jl/blob/ad2b0c0e81e05f7cf3c1bbd69ed79b6cde4ae51e/src/systems/famous_systems.jl#L247-L268" target="_blank">source</a><br/></p></article></div></div></main><footer class="md-footer"><div class="md-footer-nav"><nav class="md-footer-nav__inner md-grid"><a class="md-flex md-footer-nav__link md-footer-nav__link--prev" href=".." rel="prev" title="Introduction"><div class="md-flex__cell md-flex__cell--shrink"><i class="md-icon md-icon--arrow-back md-footer-nav__button"></i></div><div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title"><span class="md-flex__ellipsis"><span class="md-footer-nav__direction">
                  Previous
                </span>
                Introduction
              </span></div></a><a class="md-flex md-footer-nav__link md-footer-nav__link--next" href="../lyapunovs/" rel="next" title="Lyapunov Exponents"><div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title"><span class="md-flex__ellipsis"><span class="md-footer-nav__direction">
                  Next
                </span>
                Lyapunov Exponents
              </span></div><div class="md-flex__cell md-flex__cell--shrink"><i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i></div></a></nav></div><div class="md-footer-meta md-typeset"><div class="md-footer-meta__inner md-grid"><div class="md-footer-copyright">
        
        powered by
        <a href="http://www.mkdocs.org">MkDocs</a>
        and
        <a href="https://squidfunk.github.io/mkdocs-material/">
          Material for MkDocs</a></div><div class="md-footer-social"><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"/><a class="md-footer-social__link fa fa-github" href="https://github.com/JuliaDynamics/DynamicalSystems.jl"></a></div></div></div></footer></div><script src="../assets/javascripts/application.6cdc17f0.js"></script><script>app.initialize({version:"0.17.2",url:{base:".."}})</script><script src="../assets\mathjaxhelper.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script></body></HTML>