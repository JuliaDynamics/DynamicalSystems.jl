<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Recurrence Plots · DynamicalSystems.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/logo.ico" rel="icon" type="image/x-icon"/><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="DynamicalSystems.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">DynamicalSystems.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../../contents/">Contents</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Dynamical systems</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../ds/general/">Dynamical System Definition</a></li><li><a class="tocitem" href="../../ds/predefined/">Predefined Dynamical Systems</a></li><li><a class="tocitem" href="../../embedding/dataset/">Numerical Data</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Entropies</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../entropies/api/">Entropies &amp; Probabilities</a></li><li><a class="tocitem" href="../../entropies/estimators/">Probabilities Estimators</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">DelayEmbeddings</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../embedding/reconstruction/">Delay Coordinates Embedding</a></li><li><a class="tocitem" href="../../embedding/traditional/">Traditional Optimal Embedding</a></li><li><a class="tocitem" href="../../embedding/unified/">Unified Optimal Embedding</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">ChaosTools</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../chaos/orbitdiagram/">Orbit Diagrams &amp; PSOS</a></li><li><a class="tocitem" href="../../chaos/lyapunovs/">Lyapunov Exponents</a></li><li><a class="tocitem" href="../../chaos/chaos_detection/">Detecting &amp; Categorizing Chaos</a></li><li><a class="tocitem" href="../../chaos/fractaldim/">Fractal Dimension</a></li><li><a class="tocitem" href="../../chaos/nlts/">Nonlinear Timeseries Analysis</a></li><li><a class="tocitem" href="../../chaos/periodicity/">Periodicity &amp; Ergodicity</a></li><li><a class="tocitem" href="../../chaos/choosing/">Choosing a solver</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox" checked/><label class="tocitem" for="menuitem-7"><span class="docs-label">RecurrenceAnalysis</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Recurrence Plots</a><ul class="internal"><li><a class="tocitem" href="#Recurrence-Matrices"><span>Recurrence Matrices</span></a></li><li><a class="tocitem" href="#Simple-Recurrence-Plots"><span>Simple Recurrence Plots</span></a></li><li><a class="tocitem" href="#Advanced-Recurrence-Plots"><span>Advanced Recurrence Plots</span></a></li><li><a class="tocitem" href="#Example"><span>Example</span></a></li><li><a class="tocitem" href="#Distances"><span>Distances</span></a></li></ul></li><li><a class="tocitem" href="../quantification/">Recurrence Quantification Analysis</a></li><li><a class="tocitem" href="../windowed/">Windowed RQA</a></li><li><a class="tocitem" href="../networks/">Recurrence Network Analysis</a></li></ul></li><li><a class="tocitem" href="../../advanced/">Advanced Documentation</a></li><li><a class="tocitem" href="../../contributors_guide/">Contributor Guide</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">RecurrenceAnalysis</a></li><li class="is-active"><a href>Recurrence Plots</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Recurrence Plots</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDynamics/DynamicalSystems.jl/blob/master/docs/src/rqa/rplots.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Recurrence-Plots"><a class="docs-heading-anchor" href="#Recurrence-Plots">Recurrence Plots</a><a id="Recurrence-Plots-1"></a><a class="docs-heading-anchor-permalink" href="#Recurrence-Plots" title="Permalink"></a></h1><h2 id="Recurrence-Matrices"><a class="docs-heading-anchor" href="#Recurrence-Matrices">Recurrence Matrices</a><a id="Recurrence-Matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Recurrence-Matrices" title="Permalink"></a></h2><p>A <a href="https://en.wikipedia.org/wiki/Recurrence_plot">Recurrence plot</a> (which refers to the plot of a matrix) is a way to quantify <em>recurrences</em> that occur in a trajectory. A recurrence happens when a trajectory visits the same neighborhood on the phase space that it was at some previous time.</p><p>The central structure used in these recurrences is the (cross-) recurrence matrix:</p><p class="math-container">\[R[i, j] = \begin{cases}
1 \quad \text{if}\quad d(x[i], y[j]) \le \varepsilon\\
0 \quad \text{else}
\end{cases}\]</p><p>where <span>$d(x[i], y[j])$</span> stands for the <em>distance</em> between trajectory <span>$x$</span> at point <span>$i$</span> and trajectory <span>$y$</span> at point <span>$j$</span>. Both <span>$x, y$</span> can be single timeseries, full trajectories or embedded timeseries (which are also trajectories).</p><p>If <span>$x\equiv y$</span> then <span>$R$</span> is called recurrence matrix, otherwise it is called cross-recurrence matrix. There is also the joint-recurrence variant, see below. With <code>RecurrenceAnalysis</code> you can use the following functions to access these matrices</p><article class="docstring"><header><a class="docstring-binding" id="RecurrenceAnalysis.RecurrenceMatrix" href="#RecurrenceAnalysis.RecurrenceMatrix"><code>RecurrenceAnalysis.RecurrenceMatrix</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RecurrenceMatrix(x, ε; kwargs...)
RecurrenceMatrix{FAN}(...)</code></pre><p>Create a recurrence matrix from trajectory <code>x</code>. Objects of type <code>&lt;:AbstractRecurrenceMatrix</code> are displayed as a <a href="#RecurrenceAnalysis.recurrenceplot"><code>recurrenceplot</code></a>.</p><p><strong>Description</strong></p><p>The recurrence matrix is a numeric representation of a &quot;recurrence plot&quot; [1, 2], in the form of a sparse square matrix of Boolean values.</p><p><code>x</code> must be a <code>Vector</code> or an <code>AbstractDataset</code> (possibly representing an embedded phase space; see <a href="../../embedding/reconstruction/#DelayEmbeddings.embed"><code>embed</code></a>). If <code>d(x[i], x[j]) ≤ ε</code> (with <code>d</code> the distance function), then the cell <code>(i, j)</code> of the matrix will have a <code>true</code> value. The criteria to evaluate distances between data points are defined by the following keyword arguments:</p><ul><li><code>scale=1</code> : a function of the distance matrix (see <a href="#RecurrenceAnalysis.distancematrix"><code>distancematrix</code></a>), or a fixed number, used to scale the value of <code>ε</code>. Typical choices are <code>maximum</code> or <code>mean</code>, such that the threshold <code>ε</code> is defined as a ratio of the maximum or the mean distance between data points, respectively (using <code>mean</code> or <code>maximum</code> calls specialized versions that are faster than the naive approach).  Use <code>1</code> to keep the distances unscaled (default).</li><li><code>fixedrate::Bool=false</code> : a flag that indicates if <code>ε</code> should be taken as a target fixed recurrence rate (see <a href="../quantification/#RecurrenceAnalysis.recurrencerate"><code>recurrencerate</code></a>). If <code>fixedrate</code> is set to <code>true</code>, <code>ε</code> must be a value between 0 and 1, and <code>scale</code> is ignored.</li><li><code>metric=&quot;euclidean&quot;</code> : metric of the distances, either <code>Metric</code> or a string,  as in <a href="#RecurrenceAnalysis.distancematrix"><code>distancematrix</code></a>.</li><li><code>parallel::Bool=false</code> : whether to parallelize the computation of the recurrence  matrix.  This will split the computation of the matrix across multiple threads.</li></ul><p>The parametrized constructor <code>RecurrenceMatrix{NeighborNumber}</code> creates the recurrence matrix with a fixed number of neighbors for each point in the phase space, i.e. the number of recurrences is the same for all columns of the recurrence matrix. In such case, <code>ε</code> is taken as the target fixed local recurrence rate, defined as a value between 0 and 1, and <code>scale</code> and <code>fixedrate</code> are ignored. This is often referred to in the literature as the method of &quot;Fixed Amount of Nearest Neighbors&quot; (or FAN for short); <code>RecurrenceMatrix{FAN}</code> can be used as a convenient alias for <code>RecurrenceMatrix{NeighborNumber}</code>.</p><p>If no parameter is specified, <code>RecurrenceMatrix</code> returns a <code>RecurrenceMatrix{WithinRange}</code> object, meaning that recurrences will be taken for pairs of data points whose distance is within the range determined by the input arguments. Note that while recurrence matrices with neighbors defined within a given range are always symmetric, those defined by a fixed amount of neighbors can be non-symmetric.</p><p>See also: <a href="#RecurrenceAnalysis.CrossRecurrenceMatrix"><code>CrossRecurrenceMatrix</code></a>, <a href="#RecurrenceAnalysis.JointRecurrenceMatrix"><code>JointRecurrenceMatrix</code></a> and use <a href="#RecurrenceAnalysis.recurrenceplot"><code>recurrenceplot</code></a> to turn the result of these functions into a plottable format.</p><p><strong>References</strong></p><p>[1] : N. Marwan <em>et al.</em>, &quot;Recurrence plots for the analysis of complex systems&quot;, <em>Phys. Reports 438</em>(5-6), 237-329 (2007). <a href="https://doi.org/10.1016/j.physrep.2006.11.001">DOI:10.1016/j.physrep.2006.11.001</a></p><p>[2] : N. Marwan &amp; C.L. Webber, &quot;Mathematical and computational foundations of recurrence quantifications&quot;, in: Webber, C.L. &amp; N. Marwan (eds.), <em>Recurrence Quantification Analysis. Theory and Best Practices</em>, Springer, pp. 3-43 (2015).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RecurrenceAnalysis.CrossRecurrenceMatrix" href="#RecurrenceAnalysis.CrossRecurrenceMatrix"><code>RecurrenceAnalysis.CrossRecurrenceMatrix</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CrossRecurrenceMatrix(x, y, ε; kwargs...)
CrossRecurrenceMatrix{FAN}(...)</code></pre><p>Create a cross recurrence matrix from trajectories <code>x</code> and <code>y</code>.</p><p>The cross recurrence matrix is a bivariate extension of the recurrence matrix. For the time series <code>x</code>, <code>y</code>, of length <code>n</code> and <code>m</code>, respectively, it is a sparse <code>n×m</code> matrix of Boolean values, such that if <code>d(x[i], y[j]) ≤ ε</code>, then the cell <code>(i, j)</code> of the matrix will have a <code>true</code> value.</p><p>Note that, unlike univariate recurrence matrices, cross recurrence matrices are not generally symmetric, regardless of the method used to make them.</p><p>See <a href="#RecurrenceAnalysis.RecurrenceMatrix"><code>RecurrenceMatrix</code></a> for details, references and keywords. See also: <a href="#RecurrenceAnalysis.JointRecurrenceMatrix"><code>JointRecurrenceMatrix</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RecurrenceAnalysis.JointRecurrenceMatrix" href="#RecurrenceAnalysis.JointRecurrenceMatrix"><code>RecurrenceAnalysis.JointRecurrenceMatrix</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">JointRecurrenceMatrix(x, y, ε; kwargs...)
JointRecurrenceMatrix{FAN}(...)</code></pre><p>Create a joint recurrence matrix from <code>x</code> and <code>y</code>.</p><p>The joint recurrence matrix considers the recurrences of the trajectories of <code>x</code> and <code>y</code> separately, and looks for points where both recur simultaneously. It is calculated by the element-wise multiplication of the recurrence matrices of <code>x</code> and <code>y</code>. If <code>x</code> and <code>y</code> are of different length, the recurrences are only calculated until the length of the shortest one.</p><p>See <a href="#RecurrenceAnalysis.RecurrenceMatrix"><code>RecurrenceMatrix</code></a> for details, references and keywords. See also: <a href="#RecurrenceAnalysis.CrossRecurrenceMatrix"><code>CrossRecurrenceMatrix</code></a>.</p></div></section><section><div><pre><code class="language-none">JointRecurrenceMatrix(R1, R2; kwargs...)</code></pre><p>Create a joint recurrence matrix from given recurrence matrices <code>R1, R2</code>.</p></div></section></article><h2 id="Simple-Recurrence-Plots"><a class="docs-heading-anchor" href="#Simple-Recurrence-Plots">Simple Recurrence Plots</a><a id="Simple-Recurrence-Plots-1"></a><a class="docs-heading-anchor-permalink" href="#Simple-Recurrence-Plots" title="Permalink"></a></h2><p>The recurrence matrices are internally stored as sparse matrices with boolean values. Typically in the literature one does not &quot;see&quot; the matrices themselves but instead a plot of them (hence &quot;Recurrence Plots&quot;). By default, when a Recurrence Matrix is created we &quot;show&quot; a mini plot of it which is a text-based scatterplot.</p><p>Here is an example recurrence plot/matrix of a full trajectory of the Roessler system:</p><pre><code class="language-julia">using DynamicalSystems
ro = Systems.roessler(ones(3), a=0.15, b=0.20, c=10.0)
N = 2000; dt = 0.05
tr = trajectory(ro, N*dt; dt = dt, Ttr = 10.0)

R = RecurrenceMatrix(tr, 5.0; metric = &quot;euclidean&quot;)
recurrenceplot(R; ascii = true)</code></pre><pre class="documenter-example-output">      RecurrenceMatrix of size (2001, 2001) with 383597 entries
    +------------------------------------------------------------+ 
    |         ..:&#39;.::&#39;       .::&#39;.:&#39;..:&#39;       ..:&#39;.::    ..  .:&#39;|
    |   ..  .::&#39;.:&#39;&#39;   .:&#39; .:&#39;..&#39;&#39;.::&#39;   .   .::&#39;.:&#39;    .:&#39;..:&#39;  |
    | .:&#39;:.:&#39;:::&#39; .  .:&#39;.::&#39;.::&#39;.:&#39;    .:&#39;.::&#39;.::&#39;..  ::&#39;.::&#39;.:&#39; |
    |:&#39;.::&#39;.::&#39;      :.:::.:&#39;    ..    &#39;.::&#39;.::&#39;      :.:::.:&#39;   |
    | &#39;&#39;&#39; &#39;&#39;&#39; &#39; ..  .:&#39;&#39;&#39;&#39;&#39;   ..:&#39;..  .:&#39;&#39;&#39;&#39;&#39;  &#39; .. ..:&#39; &#39;&#39;&#39;   ..|
    |         .:&#39;.::&#39;       .::&#39;.:&#39;.::&#39;       .::&#39;.::&#39;    .  .:&#39;&#39;|
    |      .:&#39; .:&#39;..:    ..:&#39;..:&#39;.:&#39;&#39;.:&#39;    .:&#39;..:&#39;..:    ..:&#39;.::|
    |   ..:&#39;.::&#39;.::&#39;   .::&#39;.::&#39; :&#39;.::&#39;   .::&#39;.::&#39;.:&#39;&#39; &#39; .::&#39;.:&#39;&#39; |
    |&#39;.::&#39;.::&#39;.:&#39;    .:::.:&#39;..  .:&#39;&#39;   .:::.:::.:&#39;    .:&#39;:::&#39;    |
    |:::::&#39;:::&#39;      &#39;.::&#39;.:&#39;&#39;  &#39;      &#39;:::&#39;.::&#39;      &#39;.::&#39;..    |
    |&#39;::&#39; ::&#39;   ..  .::&#39;::&#39;    .. .   .::&#39;.::&#39;   ..  .::&#39;::&#39;    .|
    |         .:&#39;.::&#39;       .::&#39;.:&#39; .:&#39;       ..:&#39;.::&#39;       .::&#39;|
    |      .::&#39;.::&#39;.:     .:&#39;&#39;.:&#39;.::&#39;..     .::&#39;.:&#39;&#39;.: .   .:&#39;:.:|
    |     :&#39;&#39; :&#39;.::&#39;.:  ::&#39; ::&#39;.:&#39;:.:&#39;..   :&#39; ::&#39;.::&#39;.:&#39; ::&#39;.::&#39;.|
    |     .   .:&#39;..:&#39;    .:&#39;.::&#39;.:&#39;&#39;.:&#39;    .  ..:&#39;.::&#39;   ..:&#39;.::&#39;|
    |  ..:&#39;.::&#39;.::&#39;   .::&#39;.::&#39;..&#39;.::&#39;   ..:&#39;.::&#39;.:&#39;&#39;   .::&#39;.:&#39;&#39;  |
    |.::&#39;.:::.:&#39;     :::.:&#39;.::&#39; ::&#39;    :::.:::.:&#39;     :&#39;:::&#39;.::  |
    |::::&#39;:::&#39;       .::&#39;.::&#39;   .      .::&#39;.::&#39;       .::&#39;.:&#39;&#39;   |
    | &#39;&#39;  &#39;&#39;  &#39;.:&#39; .:&#39;&#39; &#39;&#39;    .:&#39;..: .:&#39;&#39; &#39;&#39;&#39;   .:&#39; .:&#39;&#39; &#39;&#39;    .:|
    |        .:&#39;..:&#39;.      .::&#39;.:&#39;&#39;.:&#39;..      .:&#39;.::&#39;.    . .::&#39;.|
    |     .::&#39;.::&#39;.:&#39;    .:&#39;&#39;.:&#39;.::&#39;.:&#39;    .::&#39;.:&#39;:.:&#39;.   .:&#39;..:&#39;|
    |.  .:&#39;:.:&#39;..:&#39;  &#39;.::&#39;.::&#39;  &#39;&#39;.:&#39;   ..:&#39;:::&#39;..&#39;&#39;  &#39;.::&#39;.::&#39;  |
    |:::&#39;.::&#39;.:&#39;&#39;    :::.::&#39;..  ::&#39;    ::&#39;.::&#39;.:&#39;     :::.:&#39;&#39;    |
    |::::::::&#39;       .::&#39;.::&#39;          .::::::&#39;       .::&#39;.::    |
    |::::::&#39;..       ::.::&#39;            :::::&#39;.        ::.:&#39;      |
    +------------------------------------------------------------+ </pre><pre><code class="language-julia">typeof(R)</code></pre><pre class="documenter-example-output">RecurrenceMatrix{WithinRange}</pre><pre><code class="language-julia">summary(R)</code></pre><pre class="documenter-example-output">&quot;RecurrenceMatrix of size (2001, 2001) with 383597 entries&quot;</pre><hr/><p>The above simple plotting functionality is possible through the package <a href="https://github.com/Evizero/UnicodePlots.jl"><code>UnicodePlots</code></a>. The following function creates the plot:</p><article class="docstring"><header><a class="docstring-binding" id="RecurrenceAnalysis.recurrenceplot" href="#RecurrenceAnalysis.recurrenceplot"><code>RecurrenceAnalysis.recurrenceplot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">recurrenceplot([io,] R; minh = 25, maxh = 0.5, ascii, kwargs...) -&gt; u</code></pre><p>Create a text-based scatterplot representation of a recurrence matrix <code>R</code> to be displayed in <code>io</code> (by default <code>stdout</code>) using <code>UnicodePlots</code>. The matrix spans at minimum <code>minh</code> rows and at maximum <code>maxh*displaysize(io)[1]</code> (i.e. by default half the display). As we always try to plot in equal aspect ratio, if the width of the plot is even less, the minimum height is dictated by the width.</p><p>The keyword <code>ascii::Bool</code> can ensure that all elements of the plot are ASCII characters (<code>true</code>) or Unicode (<code>false</code>).</p><p>The rest of the <code>kwargs</code> are propagated into <code>UnicodePlots.scatterplot</code>.</p><p>Notice that the accuracy of this function drops drastically for matrices whose size is significantly bigger than the width and height of the display (assuming each index of the matrix is one character).</p></div></section></article><hr/><p>Here is the same plot but using Unicode Braille characters</p><pre><code class="language-julia">recurrenceplot(R; ascii = false)</code></pre><pre class="documenter-example-output">      RecurrenceMatrix of size (2001, 2001) with 383597 entries
    ┌────────────────────────────────────────────────────────────┐ 
    │⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⠞⠃⢀⣴⠟⠁⠀⠀⠀⠀⠀⠀⠀⢀⣴⠟⠁⣠⡶⠋⢀⣤⠞⠁⠀⠀⠀⠀⠀⠀⠀⢀⣤⠞⠁⣀⡴⠟⠀⠀⠀⠀⢀⣤⠀⠀⣀⡴⠛│
    │⠀⠀⠀⢀⡀⠀⠀⣀⣴⠟⠁⣠⡶⠋⠁⠀⠀⠀⣀⡴⠋⠀⣠⡾⠋⢀⣠⠘⠉⣀⡴⠟⠁⠀⠀⠀⢀⠀⠀⠀⣠⡶⠟⠁⣠⡾⠋⠀⠀⠀⠀⣠⡶⠋⢀⣠⡾⠋⠀⠀│
    │⠀⣠⡶⠛⢁⣠⡾⠋⢁⣴⠾⠋⠀⡀⠀⠀⢠⡾⠋⢀⣴⠟⠋⣀⡴⠟⠁⢠⡾⠋⠀⠀⠀⠀⢠⡾⠋⢀⣴⡾⠋⢀⣴⠞⠉⢀⡀⠀⠀⣴⡾⠋⣀⣴⠟⠉⣀⡴⠋⠀│
    │⡿⠋⣠⣴⡿⠋⣠⣶⠟⠁⠀⠀⠀⠀⠀⠀⢈⣠⣾⠟⢁⣠⡾⠋⠀⠀⠀⠀⢀⡀⠀⠀⠀⠀⠈⣠⣶⠟⠋⣠⣾⠟⠁⠀⠀⠀⠀⠀⠀⢁⣤⡾⠟⢁⣠⡾⠋⠀⠀⠀│
    │⠀⠚⠛⠁⠀⠚⠛⠁⠀⠒⠀⣠⡄⠀⠀⣠⠞⠛⠁⠐⠛⠋⠀⠀⠀⢀⣠⠞⠋⢀⡄⠀⠀⣠⡼⠛⠁⠐⠛⠋⠀⠀⠒⠀⣠⡄⠀⢀⣤⠟⠋⠀⠐⠛⠉⠀⠀⠀⢀⣤│
    │⠀⠀⠀⠀⠀⠀⠀⠀⠀⣤⠞⠉⢀⣴⠟⠁⠀⠀⠀⠀⠀⠀⠀⢀⣴⠟⠁⣠⡾⠋⢀⣴⠞⠉⠀⠀⠀⠀⠀⠀⠀⢀⣴⠞⠁⣀⡴⠟⠁⠀⠀⠀⠀⡀⠀⠀⣠⡴⠛⠁│
    │⠀⠀⠀⠀⠀⠀⣀⡴⠂⠀⣠⡾⠋⢀⣠⠞⠀⠀⠀⠀⢀⣠⡾⠋⢀⣤⠞⠁⣠⡴⠛⠁⣠⡶⠃⠀⠀⠀⠀⣠⡴⠋⢀⣠⡾⠋⢀⣤⠞⠀⠀⠀⠀⢀⣤⠾⠋⢀⣴⠞│
    │⠀⠀⠀⢀⣤⡾⠋⢀⣴⠟⠋⢀⡴⠟⠁⠀⠀⠀⣀⣴⠟⠁⣠⡴⠟⠁⠀⠸⠋⢀⣴⠞⠁⠀⠀⠀⢀⣴⠾⠋⣀⣴⠟⠁⣀⡴⠋⠁⠀⠒⠀⣠⣴⠟⠁⣠⡶⠋⠁⠀│
    │⠃⣠⣶⠟⠉⣠⣾⠟⠁⣠⡾⠋⠀⠀⠀⠀⣠⣾⠟⢁⣤⡾⠋⢀⡀⠀⠀⢠⡴⠋⠁⠀⠀⠀⢠⣶⠟⢁⣠⡾⠟⢁⣠⠾⠋⠀⠀⠀⠀⣤⡾⠛⢁⣴⡾⠋⠀⠀⠀⠀│
    │⣿⠟⣁⣴⡿⠋⣁⣴⠟⠋⠀⠀⠀⠀⠀⠀⠉⣠⣶⠿⠋⣠⡴⠛⠁⠀⠀⠈⠀⠀⠀⠀⠀⠀⠈⣡⣴⡿⠋⣠⣴⠟⠁⠀⠀⠀⠀⠀⠀⠉⣠⣾⠟⠁⣠⡄⠀⠀⠀⠀│
    │⠁⠾⠿⠋⠀⠾⠟⠁⠀⠀⠀⢀⡀⠀⠀⣠⡾⠟⠁⠰⠾⠋⠀⠀⠀⠀⣠⡄⠀⢀⠀⠀⠀⣀⡼⠿⠋⠠⠾⠟⠁⠀⠀⠀⣀⡀⠀⠀⣠⠿⠟⠁⠰⠞⠋⠀⠀⠀⠀⣠│
    │⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⡾⠋⢀⣴⠞⠉⠀⠀⠀⠀⠀⠀⠀⢀⣴⠞⠁⢠⡴⠋⠀⣠⡾⠋⠀⠀⠀⠀⠀⠀⠀⢀⣠⠞⠋⢀⣴⠟⠁⠀⠀⠀⠀⠀⠀⠀⢀⣴⠟⠁│
    │⠀⠀⠀⠀⠀⠀⢀⣴⠞⠁⣠⡴⠟⠁⣠⠶⠀⠀⠀⠀⠀⣠⡴⠋⠁⣠⡾⠋⢀⣴⠟⠁⣀⡤⠀⠀⠀⠀⠀⣀⣴⠟⠁⣠⡶⠋⠁⣠⠖⠀⢀⠀⠀⠀⣠⡾⠋⢁⣠⠞│
    │⠀⠀⠀⠀⠀⠶⠋⠁⠀⠾⠋⢀⣴⠞⠁⣠⡴⠀⠀⠰⠾⠋⠀⠰⠟⠁⣠⡼⠛⢁⣤⠞⠋⢀⡄⠀⠀⠀⠾⠋⠀⠰⠾⠋⣀⡴⠟⠁⣠⠾⠋⠀⠰⠟⠋⢀⡰⠟⠁⣠│
    │⠀⠀⠀⠀⠀⢀⠀⠀⠀⣠⡾⠋⢀⣤⠞⠋⠀⠀⠀⠀⣠⡶⠃⢀⣴⠞⠋⢠⡴⠛⠁⣠⡾⠋⠀⠀⠀⠀⣀⠀⠀⢀⣠⡾⠋⢀⣴⠞⠁⠀⠀⠀⢀⣠⠞⠋⢀⣴⠞⠁│
    │⠀⠀⢀⣠⡾⠋⢀⣴⠟⠋⢀⣴⠟⠁⠀⠀⠀⣀⣴⠟⠁⣠⣴⠟⠁⣠⠄⠈⢀⣴⠞⠉⠀⠀⠀⢀⣤⠞⠉⣀⣴⠟⠁⣠⡴⠛⠁⠀⠀⠀⣀⣴⠟⠁⣠⡶⠛⠁⠀⠀│
    │⣠⣴⠟⠁⣠⣾⠟⢁⣠⡾⠋⠀⠀⠀⠀⠀⠸⠟⢁⣤⡾⠋⢀⣴⠞⠁⠀⠰⠟⠁⠀⠀⠀⠀⠰⠟⢁⣠⡾⠟⢁⣤⡾⠋⠀⠀⠀⠀⠀⠾⠋⢁⣴⡾⠋⢀⣴⠆⠀⠀│
    │⠟⣁⣴⡿⠛⣁⣴⠿⠋⠀⠀⠀⠀⠀⠀⠀⢠⣶⡿⠋⣠⣶⠟⠁⠀⠀⠀⢀⠀⠀⠀⠀⠀⠀⢠⣴⡿⠋⣠⣴⠟⠉⠀⠀⠀⠀⠀⠀⠀⣠⣶⠟⠉⣠⡾⠋⠁⠀⠀⠀│
    │⠀⠉⠉⠀⠀⠉⠁⠀⠀⠁⢀⡴⠂⠀⣠⡶⠋⠁⠀⠈⠉⠀⠀⠀⠀⣠⡶⠋⢀⣤⠆⠀⣀⡴⠋⠉⠀⠈⠉⠁⠀⠀⠀⣀⡴⠂⠀⣠⡶⠋⠁⠀⠈⠉⠀⠀⠀⠀⣠⠶│
    │⠀⠀⠀⠀⠀⠀⠀⠀⣠⠾⠋⢀⣤⠞⠋⢀⠀⠀⠀⠀⠀⠀⢀⣴⠞⠉⣀⡰⠋⠁⣠⡾⠋⢀⡀⠀⠀⠀⠀⠀⠀⣠⠾⠋⢀⣴⠟⠁⢀⠀⠀⠀⠀⠄⠀⢀⣴⠟⠁⣀│
    │⠀⠀⠀⠀⠀⢀⣴⠞⠁⣠⡴⠟⠁⣠⡶⠋⠀⠀⠀⠀⣠⡶⠛⠁⣠⡾⠋⢀⣴⠟⠁⣀⡴⠋⠀⠀⠀⠀⣀⣴⠟⠁⣠⡶⠋⢁⣠⠾⠋⢀⠀⠀⠀⣠⡾⠋⢀⣠⠾⠋│
    │⡤⠀⠀⣠⡾⠛⢁⣤⡾⠋⢀⣤⠞⠁⠀⠀⠈⢀⣴⡾⠋⢀⣴⠟⠉⠀⠀⠈⠁⣠⠾⠋⠀⠀⠀⢀⣠⡾⠋⢁⣴⡾⠋⢀⡤⠈⠁⠀⠀⠉⢀⣴⠿⠋⣀⣴⠟⠁⠀⠀│
    │⣁⣴⡿⠋⣠⣴⠟⠋⣠⡴⠛⠁⠀⠀⠀⠀⣼⠟⢉⣠⡾⠟⠁⣠⠄⠀⠀⢰⠟⠁⠀⠀⠀⠀⢰⡿⠋⣠⣶⠟⠁⣠⡶⠋⠀⠀⠀⠀⠀⣾⠟⢁⣠⡾⠋⠁⠀⠀⠀⠀│
    │⡿⢋⣴⣾⠟⢁⣴⡾⠋⠀⠀⠀⠀⠀⠀⠀⢠⣴⡿⠋⣀⣴⠟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣴⣿⠟⣁⣴⡿⠋⠀⠀⠀⠀⠀⠀⠀⣠⣴⡿⠋⣀⣴⠆⠀⠀⠀⠀│
    │⣾⣿⢟⣡⣾⡿⠋⣀⡀⠀⠀⠀⠀⠀⠀⠀⠻⢋⣤⣾⠟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⢋⣥⣾⠟⠉⣀⠀⠀⠀⠀⠀⠀⠀⠀⠟⢋⣤⡾⠋⠀⠀⠀⠀⠀⠀│
    └────────────────────────────────────────────────────────────┘ </pre><p>As you can see, the Unicode based plotting doesn&#39;t display nicely everywhere. It does display perfectly in e.g. Juno, which is where it is the default printing type. Here is how it looks like in a dark background:</p><p><img src="../rqaplot in Juno.PNG" alt/></p><h2 id="Advanced-Recurrence-Plots"><a class="docs-heading-anchor" href="#Advanced-Recurrence-Plots">Advanced Recurrence Plots</a><a id="Advanced-Recurrence-Plots-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced-Recurrence-Plots" title="Permalink"></a></h2><p>A text-based plot is cool, fast and simple. But often one needs the full resolution offered by the data of a recurrence matrix.</p><p>There are two more ways to plot a recurrence matrix using <code>RecurrenceAnalysis</code>:</p><article class="docstring"><header><a class="docstring-binding" id="RecurrenceAnalysis.coordinates" href="#RecurrenceAnalysis.coordinates"><code>RecurrenceAnalysis.coordinates</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">coordinates(R) -&gt; xs, ys</code></pre><p>Return the coordinates of the recurrence points of <code>R</code> (in indices).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RecurrenceAnalysis.grayscale" href="#RecurrenceAnalysis.grayscale"><code>RecurrenceAnalysis.grayscale</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">grayscale(R [, bwcode]; width::Int, height::Int, exactsize=false)</code></pre><p>Transform the recurrence matrix <code>R</code> into a full matrix suitable for plotting as a grayscale image. By default it returns a matrix with the same size as <code>R</code>, but switched axes, containing &quot;black&quot; values in the cells that represent recurrent points, and &quot;white&quot; values in the empty cells and interpolating in-between for cases with both recurrent and empty cells, see below.</p><p>The numeric codes for black and white are given in a 2-element tuple as a second optional argument. Its default value is <code>(0.0, 1.0)</code>, i.e. black is coded as <code>0.0</code> (no brightness) and white as <code>1.0</code> (full brightness). The type of the elements in the tuple defines the type of the returned matrix. This must be taken into account if, for instance, the image is coded as a matrix of integers corresponding to a grayscale; in such case the black and white codes must be given as numbers of the required integer type.</p><p>The keyword arguments <code>width</code> and <code>height</code> can be given to define a custom size of the image. If only one dimension is given, the other is automatically calculated. If both dimensions are given, by default they are adjusted to keep an aspect proportional to the original matrix, such that the returned matrix fits into a matrix of the given dimensions. This automatic adjustment can be disabled by passing the keyword argument <code>exactsize=true</code>.</p><p>If the image has different dimensions than <code>R</code>, the cells of <code>R</code> are distributed in a grid with the size of the image, and a gray level between white and black is calculated for each element of the grid, proportional to the number of recurrent points contained in it. The levels of gray are coded as numbers of the same type as the black and white codes.</p><p>It is advised to use <code>width, height</code> arguments for large matrices otherwise plots using functions like e.g. <code>imshow</code> could be misleading.</p></div></section></article><hr/><p>For example, here is the representation of the above <code>R</code> from the Roessler system using both plotting approaches:</p><pre><code class="language-julia">using PyPlot
figure(figsize = (10,5))

ax = subplot(121)
xs, ys = coordinates(R)
scatter(xs, ys, color = &quot;k&quot;, s = 1)
xlim(1, size(R)[1]); ylim(1, size(R)[2]);
ax.set_aspect(&quot;equal&quot;)

subplot(122)
Rg = grayscale(R)
imshow(Rg, cmap = &quot;binary_r&quot;, extent = (1, size(R)[1], 1, size(R)[2]))</code></pre><p><img src="../different_rplots.png" alt/></p><p>and here is exactly the same process, but using the embedded trajectory instead</p><pre><code class="language-julia">y = tr[:, 2]
τ = estimate_delay(y, &quot;mi_min&quot;)
m = embed(y, 3, τ)
R = RecurrenceMatrix(m, 5.0; metric = &quot;euclidean&quot;)

figure(figsize = (5,5))

xs, ys = coordinates(R)
scatter(xs, ys, color = &quot;k&quot;, s = 1)
xlim(1, size(R)[1]); ylim(1, size(R)[2]);</code></pre><p><img src="../rmatrix2.png" alt/></p><p>which justifies why recurrence plots are so fitting to be used in embedded timeseries.</p><div class="admonition is-warning"><header class="admonition-header">Careful when using Recurrence Plots</header><div class="admonition-body"><p>It is easy when using <code>grayscale</code> to not change the width/height parameters. These are however very important when the matrix size exceeds the display size! Most plotting libraries may resample arbitrarily or simply limit the displayed pixels, so one needs to be extra careful.</p><p>Besides graphical problems there are also other potential pitfalls dealing with the conceptual understanding and use of recurrence plots. All of these are summarized in the following paper which we suggest users to take a look at:</p><p>N. Marwan, <em>How to avoid potential pitfalls in recurrence plot based data analysis</em>, Int. J. of Bifurcations and Chaos (<a href="http://arxiv.org/abs/1007.2215">arXiv</a>).</p></div></div><h2 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h2><p>In the following we will plot recurrence plots of the Lorenz system for a periodic and chaotic regime (using scatter plot).</p><pre><code class="language-julia">lor = Systems.lorenz()
figure(figsize = (10,10))

for (i, ρ) in enumerate((69.75, 28.0))
    set_parameter!(lor, 2, ρ)
    t, dt = 20.0, 0.01
    tr = trajectory(lor, t; dt = dt, Ttr = 2000.0)
    tvec = 0:dt:t

    subplot(2,2, i)
    plot(tr[:, 1], tr[:, 3], color = &quot;C$(i+1)&quot;, label = &quot;X vs Z&quot;)
    title(&quot;ρ = $ρ, &quot; * (i != 1 ? &quot;not periodic&quot; : &quot;periodic&quot;)); legend()

    ε = i == 1 ? 5.0 : 3.0
    R = RecurrenceMatrix(tr, ε)

    subplot(2,2,i+2)
    x, y = coordinates(R)
    scatter(tvec[x], tvec[y], s = 1, alpha = 0.2, color = &quot;C$(i+1)&quot;)
    xlim(0, t); ylim(0, t); gca().set_aspect(&quot;equal&quot;)
    xlabel(&quot;t&quot;); i == 1 &amp;&amp; ylabel(&quot;t&quot;);
end
PyPlot.tight_layout()</code></pre><pre class="documenter-example-output">┌ Warning: Assignment to `dt` in soft scope is ambiguous because a global variable by the same name exists: `dt` will be treated as a new local. Disambiguate by using `local dt` to suppress this warning or `global dt` to assign to the existing global variable.
└ @ none:4
┌ Warning: Assignment to `tr` in soft scope is ambiguous because a global variable by the same name exists: `tr` will be treated as a new local. Disambiguate by using `local tr` to suppress this warning or `global tr` to assign to the existing global variable.
└ @ none:5
┌ Warning: Assignment to `R` in soft scope is ambiguous because a global variable by the same name exists: `R` will be treated as a new local. Disambiguate by using `local R` to suppress this warning or `global R` to assign to the existing global variable.
└ @ none:13
┌ Warning: Assignment to `y` in soft scope is ambiguous because a global variable by the same name exists: `y` will be treated as a new local. Disambiguate by using `local y` to suppress this warning or `global y` to assign to the existing global variable.
└ @ none:16</pre><p><img src="../rplotexamples.png" alt/></p><p>On the left we see long (infinite) diagonals repeated over and over for different times. This is the case for periodic systems as they visit exactly the same area on the phase space again and again. The distance between the offset diagonals also coincides with the periodicity of the system, which is around <code>t ≈ 4</code>.</p><p>On the right we see a structure typical of chaotic motion on a strange attractor such as the one of the Lorenz system: the orbit visits neighborhoods of previous points but then quickly diverges again. This results in many small diagonal lines.</p><h2 id="Distances"><a class="docs-heading-anchor" href="#Distances">Distances</a><a id="Distances-1"></a><a class="docs-heading-anchor-permalink" href="#Distances" title="Permalink"></a></h2><p>The distance function used in <a href="#RecurrenceAnalysis.RecurrenceMatrix"><code>RecurrenceMatrix</code></a> and co. can be specified either as a string or as any <code>Metric</code> instance from <a href="https://github.com/JuliaStats/Distances.jl"><code>Distances</code></a>. In addition, the following function returns a matrix with the cross-distances across all points in one or two trajectories:</p><article class="docstring"><header><a class="docstring-binding" id="RecurrenceAnalysis.distancematrix" href="#RecurrenceAnalysis.distancematrix"><code>RecurrenceAnalysis.distancematrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">distancematrix(x [, y = x], metric = &quot;euclidean&quot;)</code></pre><p>Create a matrix with the distances between each pair of points of the time series <code>x</code> and <code>y</code> using <code>metric</code>.</p><p>The time series <code>x</code> and <code>y</code> can be <code>AbstractDataset</code>s or vectors or matrices with data points in rows. The data point dimensions (or number of columns) must be the same for <code>x</code> and <code>y</code>. The returned value is a <code>n×m</code> matrix, with <code>n</code> being the length (or number of rows) of <code>x</code>, and <code>m</code> the length of <code>y</code>.</p><p>The metric can be identified by a string, or any of the <code>Metric</code>s defined in the <a href="https://github.com/JuliaStats/Distances.jl"><code>Distances</code> package</a>. The list of strings available to define the metric are:</p><ul><li><code>&quot;max&quot;</code> or <code>&quot;inf&quot;</code> for the maximum or L∞ norm (<code>Chebyshev()</code> in the <code>Distances</code> package).</li><li><code>&quot;euclidean&quot;</code> for the L2 or Euclidean norm, used by default (<code>Euclidean()</code> in <code>Distances</code>).</li><li><code>&quot;manhattan&quot;</code>, <code>&quot;cityblock&quot;</code>, <code>&quot;taxicab&quot;</code> or <code>&quot;min&quot;</code> for the Manhattan or L1 norm (<code>Cityblock()</code> in <code>Distances</code>).</li></ul></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../chaos/choosing/">« Choosing a solver</a><a class="docs-footer-nextpage" href="../quantification/">Recurrence Quantification Analysis »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 13 April 2021 12:22">Tuesday 13 April 2021</span>. Using Julia version 1.6.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
