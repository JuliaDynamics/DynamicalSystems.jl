<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Dynamical System Definition · DynamicalSystems.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/logo.ico" rel="icon" type="image/x-icon"/><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="DynamicalSystems.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">DynamicalSystems.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../../contents/">Contents</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3"><span class="docs-label">Dynamical systems</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Dynamical System Definition</a><ul class="internal"><li><a class="tocitem" href="#Creating-a-Dynamical-System"><span>Creating a Dynamical System</span></a></li><li><a class="tocitem" href="#Example:-continuous,-out-of-place"><span>Example: continuous, out-of-place</span></a></li><li><a class="tocitem" href="#Example:-discrete,-in-place"><span>Example: discrete, in-place</span></a></li><li><a class="tocitem" href="#Complex-Example"><span>Complex Example</span></a></li><li><a class="tocitem" href="#Automatic-Jacobians"><span>Automatic Jacobians</span></a></li><li><a class="tocitem" href="#Time-Evolution-of-Systems"><span>Time Evolution of Systems</span></a></li></ul></li><li><a class="tocitem" href="../predefined/">Predefined Dynamical Systems</a></li><li><a class="tocitem" href="../../embedding/dataset/">Numerical Data</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Entropies</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../entropies/api/">Entropies &amp; Probabilities</a></li><li><a class="tocitem" href="../../entropies/estimators/">Probabilities Estimators</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">DelayEmbeddings</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../embedding/reconstruction/">Delay Coordinates Embedding</a></li><li><a class="tocitem" href="../../embedding/traditional/">Traditional Optimal Embedding</a></li><li><a class="tocitem" href="../../embedding/unified/">Unified Optimal Embedding</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">ChaosTools</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../chaos/orbitdiagram/">Orbit Diagrams &amp; PSOS</a></li><li><a class="tocitem" href="../../chaos/lyapunovs/">Lyapunov Exponents</a></li><li><a class="tocitem" href="../../chaos/chaos_detection/">Detecting &amp; Categorizing Chaos</a></li><li><a class="tocitem" href="../../chaos/fractaldim/">Fractal Dimension</a></li><li><a class="tocitem" href="../../chaos/nlts/">Nonlinear Timeseries Analysis</a></li><li><a class="tocitem" href="../../chaos/periodicity/">Periodicity &amp; Ergodicity</a></li><li><a class="tocitem" href="../../chaos/choosing/">Choosing a solver</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">RecurrenceAnalysis</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../rqa/rplots/">Recurrence Plots</a></li><li><a class="tocitem" href="../../rqa/quantification/">Recurrence Quantification Analysis</a></li><li><a class="tocitem" href="../../rqa/windowed/">Windowed RQA</a></li><li><a class="tocitem" href="../../rqa/networks/">Recurrence Network Analysis</a></li></ul></li><li><a class="tocitem" href="../../advanced/">Advanced Documentation</a></li><li><a class="tocitem" href="../../contributors_guide/">Contributor Guide</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Dynamical systems</a></li><li class="is-active"><a href>Dynamical System Definition</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Dynamical System Definition</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDynamics/DynamicalSystems.jl/blob/master/docs/src/ds/general.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Dynamical-System-Definition"><a class="docs-heading-anchor" href="#Dynamical-System-Definition">Dynamical System Definition</a><a id="Dynamical-System-Definition-1"></a><a class="docs-heading-anchor-permalink" href="#Dynamical-System-Definition" title="Permalink"></a></h1><p>In <strong>DynamicalSystems.jl</strong> a Dynamical System can be either in continuous time</p><p class="math-container">\[\frac{d\vec{u}}{dt} = \vec{f}(\vec{u}, p, t),\]</p><p>or discrete time</p><p class="math-container">\[\vec{u}_{n+1} = \vec{f}(\vec{u}_n, p, n)\]</p><p>where <span>$u$</span> is the state of the system and <span>$p$</span> contains the parameters of the system. The function <span>$f$</span> is called the <em>dynamic rule</em> of the system, also known as <em>equations of motion</em>.</p><p>In addition to <span>$f$</span>, information about the Jacobian of the system <span>$J_f$</span> is also used throughout the library.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Keep in mind that almost all functions of <strong>DynamicalSystems.jl</strong> that use a <code>DynamicalSystem</code> assume that <span>$f$</span> is differentiable!</p></div></div><h2 id="Creating-a-Dynamical-System"><a class="docs-heading-anchor" href="#Creating-a-Dynamical-System">Creating a Dynamical System</a><a id="Creating-a-Dynamical-System-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-a-Dynamical-System" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DynamicalSystemsBase.DynamicalSystem" href="#DynamicalSystemsBase.DynamicalSystem"><code>DynamicalSystemsBase.DynamicalSystem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DynamicalSystem</code></pre><p>The central structure of <strong>DynamicalSystems.jl</strong>. All functions of the suite that can use known dynamic rule <code>f</code> (equations of motion) expect an instance of this type.</p><p><strong>Constructing a <code>DynamicalSystem</code></strong></p><pre><code class="language-julia">DiscreteDynamicalSystem(f, state, p [, jacobian [, J0]]; t0::Int = 0)
ContinuousDynamicalSystem(f, state, p [, jacobian [, J0]]; t0 = 0.0)</code></pre><p>with <code>f</code> a Julia function (see below). <code>p</code> is a parameter container, which we highly suggest to be a mutable, concretely typed container. Pass <code>nothing</code> as <code>p</code> if your system does not have parameters.</p><p><code>t0</code>, <code>J0</code> allow you to choose the initial time and provide an initialized Jacobian matrix. See <code>CDS_KWARGS</code> for the default options used to evolve continuous systems (through <code>OrdinaryDiffEq</code>).</p><p><strong>Dynamic rule <code>f</code></strong></p><p>The are two &quot;versions&quot; for <code>DynamicalSystem</code>, depending on whether <code>f</code> is in-place (iip) or out-of-place (oop). Here is how to define them (1D systems are treated differently, see below):</p><ul><li><strong>oop</strong> : <code>f</code> <strong>must</strong> be in the form <code>f(x, p, t) -&gt; SVector</code> which means that given a state <code>x::SVector</code> and some parameter container <code>p</code> it returns an <a href="http://juliaarrays.github.io/StaticArrays.jl/stable/pages/api.html#SVector-1"><code>SVector</code></a> (from the <a href="https://github.com/JuliaArrays/StaticArrays.jl">StaticArrays</a> module) containing the next state/rate-of-change.</li><li><strong>iip</strong> : <code>f</code> <strong>must</strong> be in the form <code>f!(xnew, x, p, t)</code> which means that given a state <code>x::Vector</code> and some parameter container <code>p</code>, it writes in-place the new state/rate-of-change in <code>xnew</code>.</li></ul><p><code>t</code> stands for time (integer for discrete systems). iip is suggested for big systems, whereas oop is suggested for small systems. The break-even point at around 10 dimensions.</p><p>The constructor deduces automatically whether <code>f</code> is iip or oop. It is not possible however to deduce whether the system is continuous or discrete just from <code>f</code>, hence the 2 constructors.</p><p><strong>Jacobian</strong></p><p>The optional argument <code>jacobian</code> for the constructors is a <em>function</em> and (if given) must also be of the same form as <code>f</code>, <code>jacobian(x, p, n) -&gt; SMatrix</code> for the out-of-place version and <code>jacobian!(J, x, p, n)</code> for the in-place version.</p><p>The constructors also allow you to pass an initialized Jacobian matrix <code>J0</code>. This is useful for large oop systems where only a few components of the Jacobian change during the time evolution.</p><p>If <code>jacobian</code> is not given, it is constructed automatically using the module <a href="http://www.juliadiff.org/ForwardDiff.jl/stable/"><code>ForwardDiff</code></a>. Even though <code>ForwardDiff</code> is very fast, depending on your exact system you might gain significant speed-up by providing a hand-coded Jacobian and so we recommend it.</p><p><strong>Comment on 1-D</strong></p><p>One dimensional discrete systems expect the state always as a pure number, <code>0.8</code> instead of <code>SVector(0.8)</code>. For continuous systems, the state can be in-place/out-of-place as in higher dimensions, however the derivative function must be always explicitly given.</p><p><strong>Interface to DifferentialEquations.jl</strong></p><p>Continuous systems are solved using <a href="http://docs.juliadiffeq.org/latest/"><strong>DifferentialEquations.jl</strong></a>, by default using the keyword arguments contained in the constant <code>CDS_KWARGS.</code></p><p>The following two interfaces are provided:</p><pre><code class="language-none">ContinuousDynamicalSystem(prob::ODEProblem [, jacobian [, J0]])
ODEProblem(continuous_dynamical_system, tspan, args...)</code></pre><p>where in the second case <code>args</code> stands for the standard extra arguments of <code>ODEProblem</code>: <code>callback, mass_matrix</code>.</p><p>If you want to use callbacks with <a href="../../advanced/#DynamicalSystemsBase.tangent_integrator"><code>tangent_integrator</code></a> or <a href="../../advanced/#DynamicalSystemsBase.parallel_integrator"><code>parallel_integrator</code></a>, then invoke them with extra arguments as shown in the <a href="https://juliadynamics.github.io/DynamicalSystems.jl/latest/advanced/">Advanced Documentation</a>.</p><p><strong>Relevant Functions</strong></p><p><a href="#DynamicalSystemsBase.trajectory"><code>trajectory</code></a>, <a href="#DynamicalSystemsBase.set_parameter!"><code>set_parameter!</code></a>.</p></div></section></article><h3 id="Definition-Table"><a class="docs-heading-anchor" href="#Definition-Table">Definition Table</a><a id="Definition-Table-1"></a><a class="docs-heading-anchor-permalink" href="#Definition-Table" title="Permalink"></a></h3><p>Here is a handy table that summarizes in what form should be the functions required for the equations of motion and the Jacobian, for each system type:</p><table><tr><th style="text-align: center">System Type</th><th style="text-align: center">equations of motion</th><th style="text-align: center">Jacobian</th></tr><tr><td style="text-align: center">in-place (big systems)</td><td style="text-align: center"><code>eom!(du, u, p, t)</code></td><td style="text-align: center"><code>jacobian!(J, u, p, t)</code></td></tr><tr><td style="text-align: center">out-of-place (small systems)</td><td style="text-align: center"><code>eom(u, p, t) -&gt; SVector</code></td><td style="text-align: center"><code>jacobian(u, p, t) -&gt; SMatrix</code></td></tr></table><div class="admonition is-success"><header class="admonition-header">Use mutable containers for the parameters</header><div class="admonition-body"><p>It is highly suggested to use a subtype of <code>Array</code>,  <a href="https://github.com/JuliaDiffEq/LabelledArrays.jl"><code>LMArray</code></a> or a dictionary for the container of the model&#39;s parameters. Some functions offered by <strong>DynamicalSystems.jl</strong>, like e.g. <a href="../../chaos/orbitdiagram/#ChaosTools.orbitdiagram"><code>orbitdiagram</code></a>, assume that the parameters can be first accessed by <code>p[x]</code> with <code>x</code> some qualifier as well as that this value can be set by <code>p[x] = newvalue</code>.</p><p>The <a href="https://github.com/JuliaDiffEq/LabelledArrays.jl">Labelled Arrays</a> package offers <code>Array</code> implementations that can be accessed both by index as well as by some name.</p></div></div><h3 id="Convenience-functions"><a class="docs-heading-anchor" href="#Convenience-functions">Convenience functions</a><a id="Convenience-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Convenience-functions" title="Permalink"></a></h3><p>The following functions are defined for convenience for any dynamical system:</p><article class="docstring"><header><a class="docstring-binding" id="DelayEmbeddings.dimension" href="#DelayEmbeddings.dimension"><code>DelayEmbeddings.dimension</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dimension(thing) -&gt; D</code></pre><p>Return the dimension of the <code>thing</code>, in the sense of state-space dimensionality.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicalSystemsBase.jacobian" href="#DynamicalSystemsBase.jacobian"><code>DynamicalSystemsBase.jacobian</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">jacobian(ds::DynamicalSystem, u = ds.u0, t = ds.t0)</code></pre><p>Return the jacobian of the system at <code>u</code>, at <code>t</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicalSystemsBase.set_parameter!" href="#DynamicalSystemsBase.set_parameter!"><code>DynamicalSystemsBase.set_parameter!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">set_parameter!(ds::DynamicalSystem, index, value)
set_parameter!(ds::DynamicalSystem, values)</code></pre><p>Change one or many parameters of the system by setting <code>p[index] = value</code> in the first case and <code>p .= values</code> in the second.</p><p>The same function also works for any integrator.</p></div></section></article><h2 id="Example:-continuous,-out-of-place"><a class="docs-heading-anchor" href="#Example:-continuous,-out-of-place">Example: continuous, out-of-place</a><a id="Example:-continuous,-out-of-place-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-continuous,-out-of-place" title="Permalink"></a></h2><p>Let&#39;s see an example for a small system, which is a case where out-of-place equations of motion are preferred.</p><pre><code class="language-julia">using DynamicalSystems # also exports relevant StaticArrays names
# Lorenz system
# Equations of motion:
@inline @inbounds function loop(u, p, t)
    σ = p[1]; ρ = p[2]; β = p[3]
    du1 = σ*(u[2]-u[1])
    du2 = u[1]*(ρ-u[3]) - u[2]
    du3 = u[1]*u[2] - β*u[3]
    return SVector{3}(du1, du2, du3)
end
# Jacobian:
@inline @inbounds function loop_jac(u, p, t)
    σ, ρ, β = p
    J = @SMatrix [-σ  σ  0;
    ρ - u[3]  (-1)  (-u[1]);
    u[2]   u[1]  -β]
    return J
end

ds = ContinuousDynamicalSystem(loop, rand(3), [10.0, 28.0, 8/3], loop_jac)</code></pre><pre><code class="language-none">3-dimensional continuous dynamical system
 state:     [0.068248, 0.828095, 0.0743729]
 e.o.m.:    loop
 in-place?  false
 jacobian:  loop_jac</code></pre><h2 id="Example:-discrete,-in-place"><a class="docs-heading-anchor" href="#Example:-discrete,-in-place">Example: discrete, in-place</a><a id="Example:-discrete,-in-place-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-discrete,-in-place" title="Permalink"></a></h2><p>The following example is only 2-dimensional, and thus once again it is &quot;correct&quot; to use out-of-place version with <code>SVector</code>. For the sake of example though, we use the in-place version.</p><pre><code class="language-julia"># Henon map.
# equations of motion:
function hiip(dx, x, p, n)
    dx[1] = 1.0 - p[1]*x[1]^2 + x[2]
    dx[2] = p[2]*x[1]
    return
end
# Jacobian:
function hiip_jac(J, x, p, n)
    J[1,1] = -2*p[1]*x[1]
    J[1,2] = 1.0
    J[2,1] = p[2]
    J[2,2] = 0.0
    return
end
ds = DiscreteDynamicalSystem(hiip, zeros(2), [1.4, 0.3], hiip_jac)</code></pre><pre><code class="language-none">2-dimensional discrete dynamical system
 state:     [0.0, 0.0]
 e.o.m.:    hiip
 in-place?  true
 jacobian:  hiip_jac</code></pre><p>Or, if you don&#39;t want to write a Jacobian and want to use the auto-differentiation capabilities of <strong>DynamicalSystems.jl</strong>, which use the module <a href="http://www.juliadiff.org/ForwardDiff.jl/stable/index.html"><code>ForwardDiff</code></a>:</p><pre><code class="language-julia">ds = DiscreteDynamicalSystem(hiip, zeros(2), [1.4, 0.3])</code></pre><pre><code class="language-none">2-dimensional discrete dynamical system
 state:     [0.0, 0.0]
 e.o.m.:    hiip
 in-place?  true
 jacobian:  ForwardDiff</code></pre><h2 id="Complex-Example"><a class="docs-heading-anchor" href="#Complex-Example">Complex Example</a><a id="Complex-Example-1"></a><a class="docs-heading-anchor-permalink" href="#Complex-Example" title="Permalink"></a></h2><p>In this example we will go through the implementation of the coupled standard maps from our <a href="../predefined/#Predefined-Dynamical-Systems">Predefined Dynamical Systems</a>. It is the most complex implementation and takes full advantage of the flexibility of the constructors. The example will use a function-like-object as equations of motion, as well as a sparse matrix for the Jacobian.</p><p>Coupled standard maps is a big mapping that can have arbitrary number of equations of motion, since you can couple <code>N</code> standard maps which are 2D maps, like:</p><p class="math-container">\[\theta_{i}&#39; = \theta_i + p_{i}&#39; \\
p_{i}&#39; = p_i + k_i\sin(\theta_i) - \Gamma \left[\sin(\theta_{i+1} - \theta_{i}) + \sin(\theta_{i-1} - \theta_{i}) \right]\]</p><p>To model this, we will make a dedicated <code>struct</code>, which is parameterized on the number of coupled maps:</p><pre><code class="language-julia">struct CoupledStandardMaps{N}
    idxs::SVector{N, Int}
    idxsm1::SVector{N, Int}
    idxsp1::SVector{N, Int}
end</code></pre><p>(what these fields are will become apparent later)</p><p>We initialize the struct with the amount of standard maps we want to couple, and we also define appropriate parameters:</p><pre><code class="language-julia">M = 5  # couple number
u0 = 0.001rand(2M) #initial state
ks = 0.9ones(M) # nonlinearity parameters
Γ = 1.0 # coupling strength
p = (ks, Γ) # parameter container

# Create struct:
SV = SVector{M, Int}
idxs = SV(1:M...) # indexes of thetas
idxsm1 = SV(circshift(idxs, +1)...)  #indexes of thetas - 1
idxsp1 = SV(circshift(idxs, -1)...)  #indexes of thetas + 1
# So that:
# x[i] ≡ θᵢ
# x[[idxsp1[i]]] ≡ θᵢ+₁
# x[[idxsm1[i]]] ≡ θᵢ-₁
csm = CoupledStandardMaps{M}(idxs, idxsm1, idxsp1);</code></pre><p>We will now use this struct to define a <a href="https://docs.julialang.org/en/v1/manual/methods/#Function-like-objects">function-like-object</a>, a Type that also acts as a function.</p><pre><code class="language-julia">function (f::CoupledStandardMaps{N})(xnew::AbstractVector, x, p, n) where {N}
    ks, Γ = p
    @inbounds for i in f.idxs

        xnew[i+N] = mod2pi(
            x[i+N] + ks[i]*sin(x[i]) -
            Γ*(sin(x[f.idxsp1[i]] - x[i]) + sin(x[f.idxsm1[i]] - x[i]))
        )

        xnew[i] = mod2pi(x[i] + xnew[i+N])
    end
    return nothing
end</code></pre><p>We will use <em>the same</em> <code>struct</code> to create a function for the Jacobian:</p><pre><code class="language-julia">function (f::CoupledStandardMaps{M})(
    J::AbstractMatrix, x, p, n) where {M}

    ks, Γ = p
    # x[i] ≡ θᵢ
    # x[[idxsp1[i]]] ≡ θᵢ+₁
    # x[[idxsm1[i]]] ≡ θᵢ-₁
    @inbounds for i in f.idxs
        cosθ = cos(x[i])
        cosθp= cos(x[f.idxsp1[i]] - x[i])
        cosθm= cos(x[f.idxsm1[i]] - x[i])
        J[i+M, i] = ks[i]*cosθ + Γ*(cosθp + cosθm)
        J[i+M, f.idxsm1[i]] = - Γ*cosθm
        J[i+M, f.idxsp1[i]] = - Γ*cosθp
        J[i, i] = 1 + J[i+M, i]
        J[i, f.idxsm1[i]] = J[i+M, f.idxsm1[i]]
        J[i, f.idxsp1[i]] = J[i+M, f.idxsp1[i]]
    end
    return nothing
end</code></pre><p>The only reason that this is possible, is because the <code>eom</code> always takes a <code>AbstractVector</code> as first argument, while the Jacobian always takes an <code>AbstractMatrix</code>. Therefore we can take advantage of multiple dispatch!</p><p>Notice in addition, that the Jacobian function accesses <em>only half the elements of the matrix</em>. This is intentional, and takes advantage of the fact that the other half is constant. We can leverage this further, by making the Jacobian a sparse matrix. Because the <code>DynamicalSystem</code> constructors allow us to give in a pre-initialized Jacobian matrix, we take advantage of that and create:</p><pre><code class="language-julia">J = zeros(eltype(u0), 2M, 2M)
# Set ∂/∂p entries (they are eye(M,M))
# And they dont change they are constants
for i in idxs
    J[i, i+M] = 1
    J[i+M, i+M] = 1
end
sparseJ = sparse(J)

csm(sparseJ, u0, p, 0) # apply Jacobian to initial state</code></pre><p>And finally, we are ready to create our dynamical system:</p><pre><code class="language-julia">ds = DiscreteDynamicalSystem(csm, u0, p, csm, sparseJ)</code></pre><pre><code class="language-none">10-dimensional discrete dynamical system
 state:       [0.000803001, 0.00092095, 0.000313022, …, 3.07769e-5, 0.000670152]
 e.o.m.:      CoupledStandardMaps
 in-place?    true
 jacobian:    CoupledStandardMaps
 parameters:  Tuple</code></pre><h2 id="Automatic-Jacobians"><a class="docs-heading-anchor" href="#Automatic-Jacobians">Automatic Jacobians</a><a id="Automatic-Jacobians-1"></a><a class="docs-heading-anchor-permalink" href="#Automatic-Jacobians" title="Permalink"></a></h2><p>Notice that if you are using automatic differentiation for the Jacobian, you should take care to NOT define your equations of motion so that they explicitly use, or return, <code>Float64</code> numbers. This is because <code>ForwardDiff</code> uses <code>DualNumbers</code> for differentiation. For example, if you did</p><pre><code class="language-julia">function lorenz(u,p,t)
    σ, ρ, β = p
    dx = zeros(3)
    du1 = σ*(u[2] - u[1]) +
    du2 = u[1]*(ρ - u[3]) - u[2]
    du3 = u[1]*u[2] - β*u[3]
    return SVector{Float64, 3}(du1, du2, du3)
end</code></pre><p>this function could not be used to auto-differentiate, as you would get an error when adding dual numbers to <code>SVector{Float64}</code>. Instead, leave the number type untyped, or use <code>eltype(u)</code> as the number type.</p><h2 id="Time-Evolution-of-Systems"><a class="docs-heading-anchor" href="#Time-Evolution-of-Systems">Time Evolution of Systems</a><a id="Time-Evolution-of-Systems-1"></a><a class="docs-heading-anchor-permalink" href="#Time-Evolution-of-Systems" title="Permalink"></a></h2><p><strong>DynamicalSystems.jl</strong> provides a convenient function for getting a trajectory of a system at equally spaced time points:</p><article class="docstring"><header><a class="docstring-binding" id="DynamicalSystemsBase.trajectory" href="#DynamicalSystemsBase.trajectory"><code>DynamicalSystemsBase.trajectory</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">trajectory(ds::DynamicalSystem, T [, u]; kwargs...) -&gt; dataset</code></pre><p>Return a dataset that will contain the trajectory of the system, after evolving it for total time <code>T</code>, optionally starting from state <code>u</code>. See <a href="../../embedding/dataset/#DelayEmbeddings.Dataset"><code>Dataset</code></a> for info on how to use this object.</p><p>A <code>W×D</code> dataset is returned, with <code>W = length(t0:dt:T)</code> with <code>t0:dt:T</code> representing the time vector (<em>not</em> returned) and <code>D</code> the system dimension.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>dt</code> :  Time step of value output. For discrete systems it must be an integer. Defaults to <code>0.01</code> for continuous and <code>1</code> for discrete.</li><li><code>Ttr</code> : Transient time to evolve the initial state before starting saving states.</li><li><code>save_idxs</code>: Which variables to output in the dataset. By default all.</li><li><code>diffeq...</code> : Remaining keyword arguments are propagated to the solvers of DifferentialEquations.jl. For example <code>abstol = 1e-9</code>.  Only valid for continuous systems. If you want to specify a solver, do so by using the name <code>alg</code>, e.g.: <code>alg = Tsit5(), maxiters = 100000</code>. This requires you to have been first <code>using OrdinaryDiffEq</code> to access the solvers. See <code>DynamicalSystemsBase.CDS_KWARGS</code> for default values. These keywords can also include <code>callback</code> for <a href="http://docs.juliadiffeq.org/latest/features/callback_functions.html">event handling</a>.</li></ul></div></section></article><p>Notice that if you want to do repeated evolutions of different states of a continuous system, you should use the <a href="../../advanced/#DynamicalSystemsBase.integrator"><code>integrator</code></a> interface instead.</p><h3 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h3><pre><code class="language-julia">using DynamicalSystems
ds = Systems.towel()</code></pre><pre class="documenter-example-output">3-dimensional discrete dynamical system
 state:       [0.085, -0.121, 0.075]
 rule f:      rule_towel
 in-place?    false
 jacobian:    jacob_towel
 parameters:  nothing
</pre><pre><code class="language-julia">tr = trajectory(ds, 100)</code></pre><pre class="documenter-example-output">3-dimensional Dataset{Float64} with 101 points
 0.085     -0.121       0.075
 0.285813  -0.0675286   0.238038
 0.76827   -0.038933    0.672094
 0.681871   0.0508933   0.825263
 0.837347   0.0372633   0.555269
 0.51969    0.0616256   0.940906
 0.966676  -0.00171595  0.2225
 0.112748   0.0674955   0.653573
 0.386547  -0.0886542   0.869349
 0.910741  -0.0316828   0.411607
 ⋮                      
 0.729743   0.0566836   0.25032
 0.739275   0.0308018   0.720691
 0.740845   0.047263    0.767058
 0.740185   0.0494093   0.684863
 0.738165   0.0466359   0.825703
 0.747373   0.0506512   0.553337
 0.719603   0.0437958   0.944377
 0.784243   0.0495777   0.20732
 0.631288   0.0375437   0.631114</pre><p>To get every 3-rd point of the trajectory, do</p><pre><code class="language-julia">tr = trajectory(ds, 100; dt = 3)</code></pre><pre class="documenter-example-output">3-dimensional Dataset{Float64} with 34 points
 0.085     -0.121       0.075
 0.681871   0.0508933   0.825263
 0.966676  -0.00171595  0.2225
 0.910741  -0.0316828   0.411607
 0.545332   0.0508239   0.819404
 0.544182  -0.0940112   0.270849
 0.690701  -0.0679162   0.727605
 0.939111   0.010943    0.736301
 0.841034   0.0322099   0.689976
 0.140788   0.0876455   0.918065
 ⋮                      
 0.223785   0.0902301   0.75948
 0.510326   0.0726233   0.682717
 0.529268  -0.069801    0.962927
 0.435893  -0.0686173   0.92088
 0.583619  -0.0769684   0.76526
 0.729705  -0.0680752   0.508933
 0.739275   0.0308018   0.720691
 0.738165   0.0466359   0.825703
 0.784243   0.0495777   0.20732</pre><p>Identical syntax is used for continuous systems</p><pre><code class="language-julia">ds = Systems.lorenz()</code></pre><pre class="documenter-example-output">3-dimensional continuous dynamical system
 state:       [0.0, 10.0, 0.0]
 rule f:      loop
 in-place?    false
 jacobian:    loop_jac
 parameters:  [10.0, 28.0, 2.66667]
</pre><pre><code class="language-julia">tr = trajectory(ds, 10.0; dt = 0.01)</code></pre><pre class="documenter-example-output">3-dimensional Dataset{Float64} with 1001 points
  0.0       10.0       0.0
  0.951226  10.0352    0.0479002
  1.82768   10.3224    0.18683
  2.6593    10.839     0.416592
  3.47133   11.5678    0.744804
  4.28518   12.496     1.18585
  5.1191    13.6125    1.76047
  5.98858   14.9063    2.49569
  6.90648   16.3638    3.42487
  7.88291   17.9659    4.58749
  ⋮                   
 -8.3603    -9.01682  25.9478
 -8.42664   -9.09574  26.0152
 -8.49391   -9.16911  26.0931
 -8.56145   -9.23601  26.1809
 -8.62859   -9.29558  26.278
 -8.69462   -9.34701  26.3833
 -8.75883   -9.38954  26.4959
 -8.82053   -9.4225   26.6146
 -8.879     -9.44532  26.7382</pre><p>And a final example controlling the integrator accuracy:</p><pre><code class="language-julia">ds = Systems.lorenz()
tr = trajectory(ds, 10.0; dt = 0.1, abstol = 1e-9, reltol = 1e-9)</code></pre><pre class="documenter-example-output">3-dimensional Dataset{Float64} with 101 points
  0.0      10.0       0.0
  8.92478  19.6843    6.02839
 20.0553   24.8278   39.9785
  9.89835  -7.67212  42.312
 -2.67297  -9.86486  30.4531
 -6.73013  -8.71064  27.4841
 -7.91     -8.61271  26.6731
 -8.44189  -8.84913  26.7275
 -8.72492  -8.86503  27.1909
 -8.70356  -8.53165  27.5098
  ⋮                  
 -7.90028  -8.12207  25.9823
 -8.35252  -8.96846  25.9951
 -8.94418  -9.4035   26.9655
 -9.09673  -8.90402  27.9987
 -8.6238   -7.96535  28.007
 -8.01079  -7.54848  27.0382
 -7.83288  -7.96251  26.0288
 -8.23289  -8.84589  25.8466
 -8.87894  -9.44531  26.7381</pre><h3 id="Solution-precision-for-continuous-systems"><a class="docs-heading-anchor" href="#Solution-precision-for-continuous-systems">Solution precision for continuous systems</a><a id="Solution-precision-for-continuous-systems-1"></a><a class="docs-heading-anchor-permalink" href="#Solution-precision-for-continuous-systems" title="Permalink"></a></h3><p>A numerical solution of an ODE is not the &quot;true&quot; solution, uniquely defined by a (well-defined) ODE and an initial condition. Especially for chaotic systems, where deviations are amplified exponentially, one is left worried if the numerical solutions truly are part of the system and can truly give insight in understanding the system.</p><p>DifferentialEquations.jl offers a tool, called <a href="https://docs.juliadiffeq.org/latest/analysis/uncertainty_quantification/">Uncertainty Quantification</a>, which allows users to asses up to what time-scales the numerical solution is close to the &quot;true&quot; solution. For example, using the default solving parameters of <strong>DynamicalSystems.jl</strong>, the Lorenz system is accurate up to time <code>t = 50.0</code>.</p><p>However, fortunately for us, there is not too much worry about the numerical solution diverging from the true solution. That is because of the <a href="http://mathworld.wolfram.com/ShadowingTheorem.html">shadowing theorem</a> (or <a href="http://www.scholarpedia.org/article/Shadowing_lemma_for_flows">shadowing lemma</a>):</p><div class="admonition is-category-quote"><header class="admonition-header">Shadowing Theorem</header><div class="admonition-body"><p>Although a numerically computed chaotic trajectory diverges exponentially from the true trajectory with the same initial coordinates, there exists an errorless trajectory with a slightly different initial condition that stays near (&quot;shadows&quot;) the numerically computed one.</p></div></div><p>This simply means that one can always numerically study chaos not only qualitatively but also quantitatively. For more information, see the book <em>Chaos in Dynamical Systems</em> by E. Ott, or the <a href="http://www.scholarpedia.org/article/Shadowing_lemma_for_flows">scholarpedia</a> entry.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../contents/">« Contents</a><a class="docs-footer-nextpage" href="../predefined/">Predefined Dynamical Systems »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 13 April 2021 12:22">Tuesday 13 April 2021</span>. Using Julia version 1.6.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
