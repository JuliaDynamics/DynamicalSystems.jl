<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Dynamical System Definition · DynamicalSystems.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/logo.ico" rel="icon" type="image/x-icon"/><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="DynamicalSystems.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">DynamicalSystems.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../../contents/">Contents</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">DelayEmbeddings</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../embedding/dataset/">Numerical Data</a></li><li><a class="tocitem" href="../../embedding/reconstruction/">Delay Coordinates Embedding</a></li><li><a class="tocitem" href="../../embedding/estimate/">Estimating Delay Embedding Parameters</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox" checked/><label class="tocitem" for="menuitem-4"><span class="docs-label">DynamicalSystemsBase</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Dynamical System Definition</a><ul class="internal"><li><a class="tocitem" href="#Creating-a-Dynamical-System-1"><span>Creating a Dynamical System</span></a></li><li><a class="tocitem" href="#Definition-Table-1"><span>Definition Table</span></a></li><li><a class="tocitem" href="#General-Functions-1"><span>General Functions</span></a></li><li><a class="tocitem" href="#Examples-1"><span>Examples</span></a></li></ul></li><li><a class="tocitem" href="../evolve/">Time Evolution</a></li><li><a class="tocitem" href="../predefined/">Predefined Dynamical Systems</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">ChaosTools</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../chaos/orbitdiagram/">Orbit Diagrams &amp; PSOS</a></li><li><a class="tocitem" href="../../chaos/lyapunovs/">Lyapunov Exponents</a></li><li><a class="tocitem" href="../../chaos/chaos_detection/">Detecting &amp; Categorizing Chaos</a></li><li><a class="tocitem" href="../../chaos/entropies/">Entropies and Dimensions</a></li><li><a class="tocitem" href="../../chaos/nlts/">Nonlinear Timeseries Analysis</a></li><li><a class="tocitem" href="../../chaos/periodicity/">Periodicity</a></li><li><a class="tocitem" href="../../chaos/choosing/">Choosing a solver</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">RecurrenceAnalysis</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../rqa/rplots/">Recurrence Plots</a></li><li><a class="tocitem" href="../../rqa/quantification/">Recurrence Quantification Analysis</a></li><li><a class="tocitem" href="../../rqa/windowed/">Windowed RQA</a></li></ul></li><li><a class="tocitem" href="../../advanced/">Advanced Documentation</a></li><li><a class="tocitem" href="../../contributors_guide/">Contributor Guide</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">DynamicalSystemsBase</a></li><li class="is-active"><a href>Dynamical System Definition</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Dynamical System Definition</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDynamics/DynamicalSystems.jl/blob/master/docs/src/ds/general.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Dynamical-Systems-1"><a class="docs-heading-anchor" href="#Dynamical-Systems-1">Dynamical Systems</a><a class="docs-heading-anchor-permalink" href="#Dynamical-Systems-1" title="Permalink"></a></h1><p>Currently a system in <strong>DynamicalSystems.jl</strong> can be either continuous</p><div>\[\frac{d\vec{u}}{dt} = \vec{f}(\vec{u}, p, t),\]</div><p>or discrete</p><div>\[\vec{u}_{n+1} = \vec{f}(\vec{u}_n, p, n)\]</div><p>where <span>$p$</span> contains the parameters of the system. In addition to the above equations of motion, information about the Jacobian of the system is also part of a &quot;dynamical system&quot;.</p><p>Keep in mind that almost all functions of <strong>DynamicalSystems.jl</strong> assume that <span>$\vec{f}$</span> is differentiable!</p><h2 id="Creating-a-Dynamical-System-1"><a class="docs-heading-anchor" href="#Creating-a-Dynamical-System-1">Creating a Dynamical System</a><a class="docs-heading-anchor-permalink" href="#Creating-a-Dynamical-System-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DynamicalSystemsBase.DynamicalSystem" href="#DynamicalSystemsBase.DynamicalSystem"><code>DynamicalSystemsBase.DynamicalSystem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DynamicalSystem</code></pre><p>The central structure of <strong>DynamicalSystems.jl</strong>. All functions of the suite that can use known equations of motion expect an instance of this type.</p><p><strong>Constructing a <code>DynamicalSystem</code></strong></p><pre><code class="language-julia">DiscreteDynamicalSystem(eom, state, p [, jacobian [, J0]]; t0::Int = 0)
ContinuousDynamicalSystem(eom, state, p [, jacobian [, J0]]; t0 = 0.0)</code></pre><p>with <code>eom</code> the equations of motion function (see below). <code>p</code> is a parameter container, which we highly suggest to use a mutable object like <code>Array</code>, <a href="https://github.com/JuliaDiffEq/LabelledArrays.jl"><code>LMArray</code></a> or a dictionary. Pass <code>nothing</code> in the place of <code>p</code> if your system does not have parameters.</p><p><code>t0</code>, <code>J0</code> allow you to choose the initial time and provide an initialized Jacobian matrix. See <code>CDS_KWARGS</code> for the default options used to evolve continuous systems (through <code>OrdinaryDiffEq</code>).</p><p><strong>Equations of motion</strong></p><p>The are two &quot;versions&quot; for <code>DynamicalSystem</code>, depending on whether the equations of motion (<code>eom</code>) are in-place (iip) or out-of-place (oop). Here is how to define them:</p><ul><li><strong>oop</strong> : The <code>eom</code> <strong>must</strong> be in the form <code>eom(x, p, t) -&gt; SVector</code> which means that given a state <code>x::SVector</code> and some parameter container <code>p</code> it returns an <a href="http://juliaarrays.github.io/StaticArrays.jl/stable/pages/api.html#SVector-1"><code>SVector</code></a> (from the <a href="https://github.com/JuliaArrays/StaticArrays.jl">StaticArrays</a> module) containing the next state.</li><li><strong>iip</strong> : The <code>eom</code> <strong>must</strong> be in the form <code>eom!(xnew, x, p, t)</code> which means that given a state <code>x::Vector</code> and some parameter container <code>p</code>, it writes in-place the new state in <code>xnew</code>.</li></ul><p><code>t</code> stands for time (integer for discrete systems). iip is suggested for big systems, whereas oop is suggested for small systems. The break-even point at around 100 dimensions, and for using functions that use the tangent space (like e.g. <code>lyapunovs</code> or <code>gali</code>), the break-even point is at around 10 dimensions.</p><p>The constructor deduces automatically whether <code>eom</code> is iip or oop. It is not possible however to deduce whether the system is continuous or discrete just from the equations of motion, hence the 2 constructors.</p><p><strong>Jacobian</strong></p><p>The optional argument <code>jacobian</code> for the constructors is a <em>function</em> and (if given) must also be of the same form as the <code>eom</code>, <code>jacobian(x, p, n) -&gt; SMatrix</code> for the out-of-place version and <code>jacobian!(Jnew, x, p, n)</code> for the in-place version.</p><p>If <code>jacobian</code> is not given, it is constructed automatically using the module <a href="http://www.juliadiff.org/ForwardDiff.jl/stable/"><code>ForwardDiff</code></a>. Even though <code>ForwardDiff</code> is very fast, depending on your exact system you might gain significant speed-up by providing a hand-coded Jacobian and so we recommend it.</p><p><strong>Interface to DifferentialEquations.jl</strong></p><p>Continuous systems are solved using <a href="http://docs.juliadiffeq.org/latest/"><strong>DifferentialEquations.jl</strong></a>. The following two interfaces are provided:</p><pre><code class="language-none">ContinuousDynamicalSystem(prob::ODEProblem [, jacobian [, J0]])
ODEProblem(continuous_dynamical_system, tspan, args...)</code></pre><p>where in the second case <code>args</code> stands for the standard extra arguments of <code>ODEProblem</code>: <code>callback, mass_matrix</code>.</p><p>If you want to use callbacks with <a href="../../advanced/#DynamicalSystemsBase.tangent_integrator"><code>tangent_integrator</code></a> or <a href="../../advanced/#DynamicalSystemsBase.parallel_integrator"><code>parallel_integrator</code></a>, then invoke them with extra arguments as shown in the <a href="https://juliadynamics.github.io/DynamicalSystems.jl/latest/advanced/">Advanced Documentation</a>.</p><p><strong>Relevant Functions</strong></p><p><a href="../evolve/#DynamicalSystemsBase.trajectory"><code>trajectory</code></a>, <a href="#DynamicalSystemsBase.set_parameter!"><code>set_parameter!</code></a>.</p></div></section></article><hr/><h2 id="Definition-Table-1"><a class="docs-heading-anchor" href="#Definition-Table-1">Definition Table</a><a class="docs-heading-anchor-permalink" href="#Definition-Table-1" title="Permalink"></a></h2><p>Here is a handy table that summarizes in what form should be the functions required for the equations of motion and the Jacobian, for each system type:</p><table><tr><th style="text-align: center">System Type</th><th style="text-align: center">equations of motion</th><th style="text-align: center">Jacobian</th></tr><tr><td style="text-align: center">in-place (big systems)</td><td style="text-align: center"><code>eom!(du, u, p, t)</code></td><td style="text-align: center"><code>jacobian!(J, u, p, t)</code></td></tr><tr><td style="text-align: center">out-of-place (small systems)</td><td style="text-align: center"><code>eom(u, p, t) -&gt; SVector</code></td><td style="text-align: center"><code>jacobian(u, p, t) -&gt; SMatrix</code></td></tr></table><div class="admonition is-success"><header class="admonition-header">Use mutable containers for the parameters</header><div class="admonition-body"><p>It is highly suggested to use a subtype of <code>Array</code>,  <a href="https://github.com/JuliaDiffEq/LabelledArrays.jl"><code>LMArray</code></a> or a dictionary for the container of the model&#39;s parameters. Some functions offered by <strong>DynamicalSystems.jl</strong>, like e.g. <a href="../../chaos/orbitdiagram/#ChaosTools.orbitdiagram"><code>orbitdiagram</code></a>, assume that the parameters can be first accessed by <code>p[x]</code> with <code>x</code> some qualifier as well as that this value can be set by <code>p[x] = newvalue</code>.</p><p>The <a href="https://github.com/JuliaDiffEq/LabelledArrays.jl">Labelled Arrays</a> package offers <code>Array</code> implementations that can be accessed both by index as well as by some name.</p></div></div><h2 id="General-Functions-1"><a class="docs-heading-anchor" href="#General-Functions-1">General Functions</a><a class="docs-heading-anchor-permalink" href="#General-Functions-1" title="Permalink"></a></h2><p>The following functions are defined for convenience for any dynamical system:</p><article class="docstring"><header><a class="docstring-binding" id="DynamicalSystemsBase.dimension" href="#DynamicalSystemsBase.dimension"><code>DynamicalSystemsBase.dimension</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dimension(thing) -&gt; D</code></pre><p>Return the dimension of the <code>thing</code>, in the sense of state-space dimensionality.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicalSystemsBase.jacobian" href="#DynamicalSystemsBase.jacobian"><code>DynamicalSystemsBase.jacobian</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">jacobian(ds::DynamicalSystem, u = ds.u0, t = ds.t0)</code></pre><p>Return the jacobian of the system at <code>u</code>, at <code>t</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicalSystemsBase.set_parameter!" href="#DynamicalSystemsBase.set_parameter!"><code>DynamicalSystemsBase.set_parameter!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">set_parameter!(ds::DynamicalSystem, index, value)
set_parameter!(ds::DynamicalSystem, values)</code></pre><p>Change one or many parameters of the system by setting <code>p[index] = value</code> in the first case and <code>p .= values</code> in the second.</p><p>The same function also works for any integrator.</p></div></section></article><h2 id="Examples-1"><a class="docs-heading-anchor" href="#Examples-1">Examples</a><a class="docs-heading-anchor-permalink" href="#Examples-1" title="Permalink"></a></h2><h3 id="Continuous,-out-of-place-1"><a class="docs-heading-anchor" href="#Continuous,-out-of-place-1">Continuous, out-of-place</a><a class="docs-heading-anchor-permalink" href="#Continuous,-out-of-place-1" title="Permalink"></a></h3><p>Let&#39;s see an example for a small system, which is a case where out-of-place equations of motion are preferred.</p><pre><code class="language-julia">using DynamicalSystems # also exports relevant StaticArrays names
# Lorenz system
# Equations of motion:
@inline @inbounds function loop(u, p, t)
    σ = p[1]; ρ = p[2]; β = p[3]
    du1 = σ*(u[2]-u[1])
    du2 = u[1]*(ρ-u[3]) - u[2]
    du3 = u[1]*u[2] - β*u[3]
    return SVector{3}(du1, du2, du3)
end
# Jacobian:
@inline @inbounds function loop_jac(u, p, t)
    σ, ρ, β = p
    J = @SMatrix [-σ  σ  0;
    ρ - u[3]  (-1)  (-u[1]);
    u[2]   u[1]  -β]
    return J
end

ds = ContinuousDynamicalSystem(loop, rand(3), [10.0, 28.0, 8/3], loop_jac)</code></pre><pre><code class="language-none">3-dimensional continuous dynamical system
 state:     [0.068248, 0.828095, 0.0743729]
 e.o.m.:    loop
 in-place?  false
 jacobian:  loop_jac</code></pre><h3 id="Discrete,-in-place-1"><a class="docs-heading-anchor" href="#Discrete,-in-place-1">Discrete, in-place</a><a class="docs-heading-anchor-permalink" href="#Discrete,-in-place-1" title="Permalink"></a></h3><p>The following example is only 2-dimensional, and thus once again it is &quot;correct&quot; to use out-of-place version with <code>SVector</code>. For the sake of example though, we use the in-place version.</p><pre><code class="language-julia"># Henon map.
# equations of motion:
function hiip(dx, x, p, n)
    dx[1] = 1.0 - p[1]*x[1]^2 + x[2]
    dx[2] = p[2]*x[1]
    return
end
# Jacobian:
function hiip_jac(J, x, p, n)
    J[1,1] = -2*p[1]*x[1]
    J[1,2] = 1.0
    J[2,1] = p[2]
    J[2,2] = 0.0
    return
end
ds = DiscreteDynamicalSystem(hiip, zeros(2), [1.4, 0.3], hiip_jac)</code></pre><pre><code class="language-none">2-dimensional discrete dynamical system
 state:     [0.0, 0.0]
 e.o.m.:    hiip
 in-place?  true
 jacobian:  hiip_jac</code></pre><p>Or, if you don&#39;t want to write a Jacobian and want to use the auto-differentiation capabilities of <strong>DynamicalSystems.jl</strong>, which use the module <a href="http://www.juliadiff.org/ForwardDiff.jl/stable/index.html"><code>ForwardDiff</code></a>:</p><pre><code class="language-julia">ds = DiscreteDynamicalSystem(hiip, zeros(2), [1.4, 0.3])</code></pre><pre><code class="language-none">2-dimensional discrete dynamical system
 state:     [0.0, 0.0]
 e.o.m.:    hiip
 in-place?  true
 jacobian:  ForwardDiff</code></pre><h3 id="Complex-Example-1"><a class="docs-heading-anchor" href="#Complex-Example-1">Complex Example</a><a class="docs-heading-anchor-permalink" href="#Complex-Example-1" title="Permalink"></a></h3><p>In this example we will go through the implementation of the coupled standard maps from our <a href="../predefined/#Predefined-Dynamical-Systems-1">Predefined Dynamical Systems</a>. It is the most complex implementation and takes full advantage of the flexibility of the constructors. The example will use a Functor as equations of motion, as well as a sparse matrix for the Jacobian.</p><p>Coupled standard maps is a big mapping that can have arbitrary number of equations of motion, since you can couple <code>N</code> standard maps which are 2D maps, like:</p><div>\[\theta_{i}&#39; = \theta_i + p_{i}&#39; \\
p_{i}&#39; = p_i + k_i\sin(\theta_i) - \Gamma \left[\sin(\theta_{i+1} - \theta_{i}) + \sin(\theta_{i-1} - \theta_{i}) \right]\]</div><p>To model this, we will make a dedicated <code>struct</code>, which is parameterized on the number of coupled maps:</p><pre><code class="language-julia">struct CoupledStandardMaps{N}
    idxs::SVector{N, Int}
    idxsm1::SVector{N, Int}
    idxsp1::SVector{N, Int}
end</code></pre><p>(what these fields are will become apparent later)</p><p>We initialize the struct with the amount of standard maps we want to couple, and we also define appropriate parameters:</p><pre><code class="language-julia">M = 5  # couple number
u0 = 0.001rand(2M) #initial state
ks = 0.9ones(M) # nonlinearity parameters
Γ = 1.0 # coupling strength
p = (ks, Γ) # parameter container

# Create struct:
SV = SVector{M, Int}
idxs = SV(1:M...) # indexes of thetas
idxsm1 = SV(circshift(idxs, +1)...)  #indexes of thetas - 1
idxsp1 = SV(circshift(idxs, -1)...)  #indexes of thetas + 1
# So that:
# x[i] ≡ θᵢ
# x[[idxsp1[i]]] ≡ θᵢ+₁
# x[[idxsm1[i]]] ≡ θᵢ-₁
csm = CoupledStandardMaps{M}(idxs, idxsm1, idxsp1);</code></pre><p>We will now use this struct to define a <a href="https://docs.julialang.org/en/stable/manual/methods/#Function-like-objects-1">functor</a>, a Type that also acts as a function.</p><pre><code class="language-julia">function (f::CoupledStandardMaps{N})(xnew::AbstractVector, x, p, n) where {N}
    ks, Γ = p
    @inbounds for i in f.idxs

        xnew[i+N] = mod2pi(
            x[i+N] + ks[i]*sin(x[i]) -
            Γ*(sin(x[f.idxsp1[i]] - x[i]) + sin(x[f.idxsm1[i]] - x[i]))
        )

        xnew[i] = mod2pi(x[i] + xnew[i+N])
    end
    return nothing
end</code></pre><p>We will use <em>the same</em> <code>struct</code> to create a function for the Jacobian:</p><pre><code class="language-julia">function (f::CoupledStandardMaps{M})(
    J::AbstractMatrix, x, p, n) where {M}

    ks, Γ = p
    # x[i] ≡ θᵢ
    # x[[idxsp1[i]]] ≡ θᵢ+₁
    # x[[idxsm1[i]]] ≡ θᵢ-₁
    @inbounds for i in f.idxs
        cosθ = cos(x[i])
        cosθp= cos(x[f.idxsp1[i]] - x[i])
        cosθm= cos(x[f.idxsm1[i]] - x[i])
        J[i+M, i] = ks[i]*cosθ + Γ*(cosθp + cosθm)
        J[i+M, f.idxsm1[i]] = - Γ*cosθm
        J[i+M, f.idxsp1[i]] = - Γ*cosθp
        J[i, i] = 1 + J[i+M, i]
        J[i, f.idxsm1[i]] = J[i+M, f.idxsm1[i]]
        J[i, f.idxsp1[i]] = J[i+M, f.idxsp1[i]]
    end
    return nothing
end</code></pre><p>The only reason that this is possible, is because the <code>eom</code> always takes a <code>AbstractVector</code> as first argument, while the Jacobian always takes an <code>AbstractMatrix</code>. Therefore we can take advantage of multiple dispatch!</p><p>Notice in addition, that the Jacobian function accesses <em>only half the elements of the matrix</em>. This is intentional, and takes advantage of the fact that the other half is constant. We can leverage this further, by making the Jacobian a sparse matrix. Because the <code>DynamicalSystem</code> constructors allow us to give in a pre-initialized Jacobian matrix, we take advantage of that and create:</p><pre><code class="language-julia">J = zeros(eltype(u0), 2M, 2M)
# Set ∂/∂p entries (they are eye(M,M))
# And they dont change they are constants
for i in idxs
    J[i, i+M] = 1
    J[i+M, i+M] = 1
end
sparseJ = sparse(J)

csm(sparseJ, u0, p, 0) # apply Jacobian to initial state</code></pre><p>And finally, we are ready to create our dynamical system:</p><pre><code class="language-julia">ds = DiscreteDynamicalSystem(csm, u0, p, csm, sparseJ)</code></pre><pre><code class="language-none">10-dimensional discrete dynamical system
 state:       [0.000803001, 0.00092095, 0.000313022, …, 3.07769e-5, 0.000670152]
 e.o.m.:      CoupledStandardMaps
 in-place?    true
 jacobian:    CoupledStandardMaps
 parameters:  Tuple</code></pre><h3 id="A-comment-on-using-automatic-Jacobians-1"><a class="docs-heading-anchor" href="#A-comment-on-using-automatic-Jacobians-1">A comment on using automatic Jacobians</a><a class="docs-heading-anchor-permalink" href="#A-comment-on-using-automatic-Jacobians-1" title="Permalink"></a></h3><p>Notice that if you are using automatic differentiation for the Jacobian, you should take care to not define your equations of motion so that they explicitly use, or return, <code>Float64</code> numbers. This is because <code>ForwardDiff</code> uses <code>DualNumbers</code> for differentiation. For example, if you did</p><pre><code class="language-julia">function lorenz(u,p,t)
    σ, ρ, β = p
    dx = zeros(3)
    du1 = σ*(u[2] - u[1]) +
    du2 = u[1]*(ρ - u[3]) - u[2]
    du3 = u[1]*u[2] - β*u[3]
    return SVector{Float64, 3}(du1, du2, du3)
end</code></pre><p>this function could not be used to autodifferentiate, as you would get an error when adding dual numbers to <code>SVector{Float64}</code>. Instead, leave the number type untyped, or use <code>eltype(u)</code> as the number type.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../embedding/estimate/">« Estimating Delay Embedding Parameters</a><a class="docs-footer-nextpage" href="../evolve/">Time Evolution »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 22 March 2020 13:31">Sunday 22 March 2020</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
