<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Estimating Delay Embedding Parameters · DynamicalSystems.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/logo.ico" rel="icon" type="image/x-icon"/><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="DynamicalSystems.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">DynamicalSystems.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../../contents/">Contents</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3"><span class="docs-label">DelayEmbeddings</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../dataset/">Numerical Data</a></li><li><a class="tocitem" href="../reconstruction/">Delay Coordinates Embedding</a></li><li class="is-active"><a class="tocitem" href>Estimating Delay Embedding Parameters</a><ul class="internal"><li><a class="tocitem" href="#Delay-Time-1"><span>Delay Time</span></a></li><li><a class="tocitem" href="#Embedding-Dimension-1"><span>Embedding Dimension</span></a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">DynamicalSystemsBase</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../ds/general/">Dynamical System Definition</a></li><li><a class="tocitem" href="../../ds/evolve/">Time Evolution</a></li><li><a class="tocitem" href="../../ds/predefined/">Predefined Dynamical Systems</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">ChaosTools</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../chaos/orbitdiagram/">Orbit Diagrams &amp; PSOS</a></li><li><a class="tocitem" href="../../chaos/lyapunovs/">Lyapunov Exponents</a></li><li><a class="tocitem" href="../../chaos/chaos_detection/">Detecting &amp; Categorizing Chaos</a></li><li><a class="tocitem" href="../../chaos/entropies/">Entropies and Dimensions</a></li><li><a class="tocitem" href="../../chaos/nlts/">Nonlinear Timeseries Analysis</a></li><li><a class="tocitem" href="../../chaos/periodicity/">Periodicity</a></li><li><a class="tocitem" href="../../chaos/choosing/">Choosing a solver</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">RecurrenceAnalysis</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../rqa/rplots/">Recurrence Plots</a></li><li><a class="tocitem" href="../../rqa/quantification/">Recurrence Quantification Analysis</a></li><li><a class="tocitem" href="../../rqa/windowed/">Windowed RQA</a></li></ul></li><li><a class="tocitem" href="../../advanced/">Advanced Documentation</a></li><li><a class="tocitem" href="../../contributors_guide/">Contributor Guide</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">DelayEmbeddings</a></li><li class="is-active"><a href>Estimating Delay Embedding Parameters</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Estimating Delay Embedding Parameters</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDynamics/DynamicalSystems.jl/blob/master/docs/src/embedding/estimate.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Estimating-Delay-Embedding-Parameters-1"><a class="docs-heading-anchor" href="#Estimating-Delay-Embedding-Parameters-1">Estimating Delay Embedding Parameters</a><a class="docs-heading-anchor-permalink" href="#Estimating-Delay-Embedding-Parameters-1" title="Permalink"></a></h1><p>The following functions can estimate good values that can be used in <a href="../reconstruction/#DelayEmbeddings.reconstruct"><code>reconstruct</code></a> for either the delay time or the number of temporal neighbors.</p><h2 id="Delay-Time-1"><a class="docs-heading-anchor" href="#Delay-Time-1">Delay Time</a><a class="docs-heading-anchor-permalink" href="#Delay-Time-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DelayEmbeddings.estimate_delay" href="#DelayEmbeddings.estimate_delay"><code>DelayEmbeddings.estimate_delay</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">estimate_delay(s, method::String [, τs = 1:2:100]; kwargs...) -&gt; τ</code></pre><p>Estimate an optimal delay to be used in <a href="../reconstruction/#DelayEmbeddings.reconstruct"><code>reconstruct</code></a> or <a href="../reconstruction/#DelayEmbeddings.embed"><code>embed</code></a>. The <code>method</code> can be one of the following:</p><ul><li><code>&quot;ac_zero&quot;</code> : first delay at which the auto-correlation function becomes &lt;0.</li><li><code>&quot;ac_min&quot;</code> : delay of first minimum of the auto-correlation function.</li><li><code>&quot;mi_min&quot;</code> : delay of first minimum of mutual information of <code>s</code> with itself (shifted for various <code>τs</code>). Keywords <code>nbins, binwidth</code> are propagated into <a href="#DelayEmbeddings.mutualinformation"><code>mutualinformation</code></a>.</li><li><code>&quot;exp_decay&quot;</code> : <a href="#DelayEmbeddings.exponential_decay_fit"><code>exponential_decay_fit</code></a> of the correlation function rounded  to an integer (uses least squares on <code>c(t) = exp(-t/τ)</code> to find <code>τ</code>).</li><li><code>&quot;exp_extrema&quot;</code> : same as above but the exponential fit is done to the absolute value of the local extrema of the correlation function.</li></ul><p>Both the mutual information and correlation function (<code>autocor</code>) are computed <em>only</em> for delays <code>τs</code>. This means that the <code>min</code> methods can never return the first value of <code>τs</code>!</p><p>The method <code>mi_min</code> is significantly more accurate than the others and also returns good results for most timeseries. It is however the slowest method (but still quite fast!).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="DelayEmbeddings.exponential_decay_fit" href="#DelayEmbeddings.exponential_decay_fit"><code>DelayEmbeddings.exponential_decay_fit</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">exponential_decay_fit(x, y, weight = :equal) -&gt; τ</code></pre><p>Perform a least square fit of the form <code>y = exp(-x/τ)</code> and return <code>τ</code>. Taken from:  http://mathworld.wolfram.com/LeastSquaresFittingExponential.html. Assumes equal lengths of <code>x, y</code> and that <code>y ≥ 0</code>.</p><p>To use the method that gives more weight to small values of <code>y</code>, use <code>weight = :small</code>.</p></div></section></article><h3 id="Mutual-Information-1"><a class="docs-heading-anchor" href="#Mutual-Information-1">Mutual Information</a><a class="docs-heading-anchor-permalink" href="#Mutual-Information-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="DelayEmbeddings.mutualinformation" href="#DelayEmbeddings.mutualinformation"><code>DelayEmbeddings.mutualinformation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">mutualinformation(s, τs[; nbins, binwidth])</code></pre><p>Calculate the mutual information between the time series <code>s</code> and its images delayed by <code>τ</code> points for <code>τ</code> ∈ <code>τs</code>, using an <em>improvement</em> of the method outlined by Fraser &amp; Swinney in [1].</p><p><strong>Description</strong></p><p>The joint space of <code>s</code> and its <code>τ</code>-delayed image (<code>sτ</code>) is partitioned as a rectangular grid, and the mutual information is computed from the joint and marginal frequencies of <code>s</code> and <code>sτ</code> in the grid as defined in [1]. The mutual information values are returned in a vector of the same length as <code>τs</code>.</p><p>If any of the optional keyword parameters is given, the grid will be a homogeneous partition of the space where <code>s</code> and <code>sτ</code> are defined. The margins of that partition will be divided in a number of bins equal to <code>nbins</code>, such that the width of each bin will be <code>binwidth</code>, and the range of nonzero values of <code>s</code> will be in the centre. If only of those two parameters is given, the other will be automatically calculated to adjust the size of the grid to the area where <code>s</code> and <code>sτ</code> are nonzero.</p><p>If no parameter is given, the space will be partitioned by a recursive bisection algorithm based on the method given in [1].</p><p>Notice that the recursive method of [1] evaluates the joint frequencies of <code>s</code> and <code>sτ</code> in each cell resulting from a partition, and stops when the data points are uniformly distributed across the sub-partitions of the following levels. For performance and stability reasons, the automatic partition method implemented in this function is only used to divide the axes of the grid, using the marginal frequencies of <code>s</code>.</p><p><strong>References</strong></p><p>[1]: Fraser A.M. &amp; Swinney H.L. &quot;Independent coordinates for strange attractors from mutual information&quot; <em>Phys. Rev. A 33</em>(2), 1986, 1134:1140.</p></div></section></article><hr/><p>Besides the above method, there also exists code that computes mutual information in two other ways. Both ways are in the file <code>DelayEmbedding\src\old_mutual_info.jl</code>. The first way is the original algorithm of Fraser, while the second is the algorithm of Kraskov. Both of these implementations are inferior to the one exposed here (performance-wise).</p><h2 id="Embedding-Dimension-1"><a class="docs-heading-anchor" href="#Embedding-Dimension-1">Embedding Dimension</a><a class="docs-heading-anchor-permalink" href="#Embedding-Dimension-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DelayEmbeddings.estimate_dimension" href="#DelayEmbeddings.estimate_dimension"><code>DelayEmbeddings.estimate_dimension</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">estimate_dimension(s::AbstractVector, τ::Int, γs = 1:5, method = &quot;afnn&quot;; kwargs...)</code></pre><p>Compute a quantity that can estimate an optimal amount of temporal neighbors <code>γ</code> to be used in <a href="../reconstruction/#DelayEmbeddings.reconstruct"><code>reconstruct</code></a> or <a href="../reconstruction/#DelayEmbeddings.embed"><code>embed</code></a>.</p><p><strong>Description</strong></p><p>Given the scalar timeseries <code>s</code> and the embedding delay <code>τ</code> compute a quantity for each <code>γ ∈ γs</code> based on the &quot;nearest neighbors&quot; in the embedded time series.</p><p>The quantity that is calculated depends on the algorithm defined by the string <code>method</code>:</p><ul><li><code>&quot;afnn&quot;</code> (default) is Cao&#39;s &quot;Averaged False Nearest Neighbors&quot; method [1], which   gives a ratio of distances between nearest neighbors. This ratio saturates   around <code>1.0</code> near the optimal value of <code>γ</code> (see <a href="#DelayEmbeddings.afnn"><code>afnn</code></a>).</li><li><code>&quot;fnn&quot;</code> is Kennel&#39;s &quot;False Nearest Neighbors&quot; method [2], which gives the   number of points that cease to be &quot;nearest neighbors&quot; when the dimension   increases. This number drops down to zero near the optimal value of <code>γ</code>.   This method accepts the keyword arguments <code>rtol</code> and <code>atol</code>, which stand   for the &quot;tolerances&quot; required by Kennel&#39;s algorithm (see <a href="#DelayEmbeddings.fnn"><code>fnn</code></a>).</li><li><code>&quot;f1nn&quot;</code> is Krakovská&#39;s &quot;False First Nearest Neighbors&quot; method [3], which   gives the ratio of pairs of points that cease to be &quot;nearest neighbors&quot;   when the dimension increases. This number drops down to zero near the   optimal value of <code>γ</code> (see <a href="#DelayEmbeddings.f1nn"><code>f1nn</code></a>).</li></ul><p><code>&quot;afnn&quot;</code> and <code>&quot;f1nn&quot;</code> also support the <code>metric</code> keyword, which can be any of <code>Cityblock(), Euclidean(), Chebyshev()</code>. This metric is used both for computing the nearest neighbors (<code>KDTree</code>s) as well as the distances necessary for Cao&#39;s method (eqs. (2, 3) of [1]). Defaults to <code>Euclidean()</code> (note that [1] used <code>Chebyshev</code>).</p><p>Please be aware that in <strong>DynamicalSystems.jl</strong> <code>γ</code> stands for the amount of temporal neighbors and not the embedding dimension (<code>D = γ + 1</code>, see also <a href="../reconstruction/#DelayEmbeddings.embed"><code>embed</code></a>).</p><p><strong>References</strong></p><p>[1] : Liangyue Cao, <a href="https://www.sciencedirect.com/science/article/pii/S0167278997001188?via%3Dihub">Physica D, pp. 43-50 (1997)</a></p><p>[2] : M. Kennel <em>et al.</em>, <a href="https://journals.aps.org/pra/abstract/10.1103/PhysRevA.45.3403">Phys. Review A <strong>45</strong>(6), 3403-3411</a> (1992).</p><p>[3] : Anna Krakovská <em>et al.</em>, <a href="https://doi.org/10.1155/2015/932750">J. Complex Sys. 932750 (2015)</a></p></div></section></article><h3 id="Example-1"><a class="docs-heading-anchor" href="#Example-1">Example</a><a class="docs-heading-anchor-permalink" href="#Example-1" title="Permalink"></a></h3><pre><code class="language-julia">using DynamicalSystems, PyPlot

ds = Systems.roessler()
tr = trajectory(ds, 1000.0; dt = 0.05)

τ = estimate_delay(tr[:, 1], &quot;mi_min&quot;) # first minimum of mutual information

figure();
for method in [&quot;afnn&quot;, &quot;fnn&quot;, &quot;f1nn&quot;]
    Ds = estimate_dimension(tr[:, 1], τ, 1:6, method)
    plot(1:6, Ds ./ maximum(Ds), label = method, marker = &quot;o&quot;)
end
legend(); xlabel(&quot;\$\\gamma\$ (temporal neighbors)&quot;)
tight_layout()</code></pre><p><img src="../estimateD.png" alt/></p><h3 id="Functions-1"><a class="docs-heading-anchor" href="#Functions-1">Functions</a><a class="docs-heading-anchor-permalink" href="#Functions-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="DelayEmbeddings.fnn" href="#DelayEmbeddings.fnn"><code>DelayEmbeddings.fnn</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fnn(s::AbstractVector, τ:Int, γs = 1:5; rtol=10.0, atol=2.0)</code></pre><p>Calculate the number of &quot;false nearest neighbors&quot; (FNN) of the datasets created from <code>s</code> with a sequence of <code>τ</code>-delayed temporal neighbors.</p><p><strong>Description</strong></p><p>Given a dataset made by embedding <code>s</code> with <code>γ</code> temporal neighbors and delay <code>τ</code>, the &quot;false nearest neighbors&quot; (FNN) are the pairs of points that are nearest to each other at dimension <code>γ</code>, but are separated at dimension <code>γ+1</code>. Kennel&#39;s criteria for detecting FNN are based on a threshold for the relative increment of the distance between the nearest neighbors (<code>rtol</code>, eq. 4 in [1]), and another threshold for the ratio between the increased distance and the &quot;size of the attractor&quot; (<code>atol</code>, eq. 5 in [1]). These thresholds are given as keyword arguments.</p><p>The returned value is a vector with the number of FNN for each <code>γ ∈ γs</code>. The optimal value for <code>γ</code> is found at the point where the number of FNN approaches zero.</p><p>See also: <a href="#DelayEmbeddings.estimate_dimension"><code>estimate_dimension</code></a>, <a href="#DelayEmbeddings.afnn"><code>afnn</code></a>, <a href="#DelayEmbeddings.f1nn"><code>f1nn</code></a>.</p><p><strong>References</strong></p><p>[1] : M. Kennel <em>et al.</em>, &quot;Determining embedding dimension for phase-space reconstruction using a geometrical construction&quot;, <em>Phys. Review A 45</em>(6), 3403-3411 (1992).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="DelayEmbeddings.afnn" href="#DelayEmbeddings.afnn"><code>DelayEmbeddings.afnn</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">afnn(s::AbstractVector, τ:Int, γs = 1:5, metric=Euclidean())</code></pre><p>Compute the parameter E₁ of Cao&#39;s &quot;averaged false nearest neighbors&quot; method for determining the minimum embedding dimension of the time series <code>s</code>, with a sequence of <code>τ</code>-delayed temporal neighbors [1].</p><p><strong>Description</strong></p><p>Given the scalar timeseries <code>s</code> and the embedding delay <code>τ</code> compute the values of <code>E₁</code> for each <code>γ ∈ γs</code>, according to Cao&#39;s Method (eq. 3 of [1]).</p><p>This quantity is a ratio of the averaged distances between the nearest neighbors of the reconstructed time series, which quantifies the increment of those distances when the number of temporal neighbors changes from <code>γ</code> to <code>γ+1</code>.</p><p>Return the vector of all computed <code>E₁</code>s. To estimate a good value for <code>γ</code> from this, find <code>γ</code> for which the value <code>E₁</code> saturates at some value around 1.</p><p><em>Note: This method does not work for datasets with perfectly periodic signals.</em></p><p>See also: <a href="#DelayEmbeddings.estimate_dimension"><code>estimate_dimension</code></a>, <a href="#DelayEmbeddings.fnn"><code>fnn</code></a>, <a href="#DelayEmbeddings.f1nn"><code>f1nn</code></a>.</p><p><strong>References</strong></p><p>[1] : Liangyue Cao, <a href="https://www.sciencedirect.com/science/article/pii/S0167278997001188?via%3Dihub">Physica D, pp. 43-50 (1997)</a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="DelayEmbeddings.f1nn" href="#DelayEmbeddings.f1nn"><code>DelayEmbeddings.f1nn</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">f1nn(s::AbstractVector, τ:Int, γs = 1:5, metric = Euclidean())</code></pre><p>Calculate the ratio of &quot;false first nearest neighbors&quot; (FFNN) of the datasets created from <code>s</code> with a sequence of <code>τ</code>-delayed temporal neighbors.</p><p><strong>Description</strong></p><p>Given a dataset made by embedding <code>s</code> with <code>γ</code> temporal neighbors and delay <code>τ</code>, the &quot;first nearest neighbors&quot; (FFNN) are the pairs of points that are nearest to each other at dimension <code>γ</code> that cease to be nearest neighbors at dimension <code>γ+1</code> [1].</p><p>The returned value is a vector with the ratio between the number of FFNN and the number of points in the dataset for each <code>γ ∈ γs</code>. The optimal value for <code>γ</code> is found at the point where this ratio approaches zero.</p><p>See also: <a href="#DelayEmbeddings.estimate_dimension"><code>estimate_dimension</code></a>, <a href="#DelayEmbeddings.afnn"><code>afnn</code></a>, <a href="#DelayEmbeddings.fnn"><code>fnn</code></a>.</p><p><strong>References</strong></p><p>[1] : Anna Krakovská <em>et al.</em>, &quot;Use of false nearest neighbours for selecting variables and embedding parameters for state space reconstruction&quot;, <em>J Complex Sys</em> 932750 (2015), DOI: 10.1155/2015/932750</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="DelayEmbeddings.stochastic_indicator" href="#DelayEmbeddings.stochastic_indicator"><code>DelayEmbeddings.stochastic_indicator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">stochastic_indicator(s::AbstractVector, τ:Int, γs = 1:4) -&gt; E₂s</code></pre><p>Compute an estimator for apparent randomness in a reconstruction with <code>γs</code> temporal neighbors.</p><p><strong>Description</strong></p><p>Given the scalar timeseries <code>s</code> and the embedding delay <code>τ</code> compute the values of <code>E₂</code> for each <code>γ ∈ γs</code>, according to Cao&#39;s Method (eq. 5 of [1]).</p><p>Use this function to confirm that the input signal is not random and validate the results of <a href="#DelayEmbeddings.estimate_dimension"><code>estimate_dimension</code></a>. In the case of random signals, it should be <code>E₂ ≈ 1 ∀ γ</code>.</p><p><strong>References</strong></p><p>[1] : Liangyue Cao, <a href="https://www.sciencedirect.com/science/article/pii/S0167278997001188?via%3Dihub">Physica D, pp. 43-50 (1997)</a></p></div></section></article><hr/></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../reconstruction/">« Delay Coordinates Embedding</a><a class="docs-footer-nextpage" href="../../ds/general/">Dynamical System Definition »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 22 March 2020 13:31">Sunday 22 March 2020</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
