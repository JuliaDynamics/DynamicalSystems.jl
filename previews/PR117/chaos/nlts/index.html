<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Nonlinear Timeseries Analysis · DynamicalSystems.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/logo.ico" rel="icon" type="image/x-icon"/><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="DynamicalSystems.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">DynamicalSystems.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../../contents/">Contents</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Dynamical systems</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../ds/general/">Dynamical System Definition</a></li><li><a class="tocitem" href="../../ds/predefined/">Predefined Dynamical Systems</a></li><li><a class="tocitem" href="../../embedding/dataset/">Numerical Data</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">DelayEmbeddings</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../embedding/reconstruction/">Delay Coordinates Embedding</a></li><li><a class="tocitem" href="../../embedding/estimate/">Optimal DCE Parameters</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox" checked/><label class="tocitem" for="menuitem-5"><span class="docs-label">ChaosTools</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../orbitdiagram/">Orbit Diagrams &amp; PSOS</a></li><li><a class="tocitem" href="../lyapunovs/">Lyapunov Exponents</a></li><li><a class="tocitem" href="../chaos_detection/">Detecting &amp; Categorizing Chaos</a></li><li><a class="tocitem" href="../entropies/">Entropies and Dimensions</a></li><li class="is-active"><a class="tocitem" href>Nonlinear Timeseries Analysis</a><ul class="internal"><li><a class="tocitem" href="#Numerical-Lyapunov-Exponent-1"><span>Numerical Lyapunov Exponent</span></a></li><li><a class="tocitem" href="#Broomhead-King-Coordinates-1"><span>Broomhead-King Coordinates</span></a></li><li><a class="tocitem" href="#Nearest-Neighbor-Prediction-1"><span>Nearest Neighbor Prediction</span></a></li></ul></li><li><a class="tocitem" href="../periodicity/">Periodicity &amp; Ergodicity</a></li><li><a class="tocitem" href="../choosing/">Choosing a solver</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">RecurrenceAnalysis</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../rqa/rplots/">Recurrence Plots</a></li><li><a class="tocitem" href="../../rqa/quantification/">Recurrence Quantification Analysis</a></li><li><a class="tocitem" href="../../rqa/windowed/">Windowed RQA</a></li></ul></li><li><a class="tocitem" href="../../advanced/">Advanced Documentation</a></li><li><a class="tocitem" href="../../contributors_guide/">Contributor Guide</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">ChaosTools</a></li><li class="is-active"><a href>Nonlinear Timeseries Analysis</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Nonlinear Timeseries Analysis</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDynamics/DynamicalSystems.jl/blob/master/docs/src/chaos/nlts.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Nonlinear-Timeseries-Analysis-1"><a class="docs-heading-anchor" href="#Nonlinear-Timeseries-Analysis-1">Nonlinear Timeseries Analysis</a><a class="docs-heading-anchor-permalink" href="#Nonlinear-Timeseries-Analysis-1" title="Permalink"></a></h1><h2 id="Numerical-Lyapunov-Exponent-1"><a class="docs-heading-anchor" href="#Numerical-Lyapunov-Exponent-1">Numerical Lyapunov Exponent</a><a class="docs-heading-anchor-permalink" href="#Numerical-Lyapunov-Exponent-1" title="Permalink"></a></h2><p>Given any timeseries, one can first <a href="../../embedding/reconstruction/#DelayEmbeddings.embed"><code>embed</code></a> it using delay coordinates, and then calculate a maximum Lyapunov exponent for it. This is done with</p><article class="docstring"><header><a class="docstring-binding" id="ChaosTools.numericallyapunov" href="#ChaosTools.numericallyapunov"><code>ChaosTools.numericallyapunov</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">numericallyapunov(R::Dataset, ks;  refstates, w, distance, ntype)</code></pre><p>Return <code>E = [E(k) for k ∈ ks]</code>, where <code>E(k)</code> is the average logarithmic distance between states of a <a href="../../embedding/dataset/#DelayEmbeddings.neighborhood"><code>neighborhood</code></a> that are evolved in time for <code>k</code> steps (<code>k</code> must be integer). Typically <code>R</code> is the result of delay coordinates of a single timeseries.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>refstates = 1:(length(R) - ks[end])</code> : Vector of indices that notes which states of the reconstruction should be used as &quot;reference states&quot;, which means that the algorithm is applied for all state indices contained in <code>refstates</code>.</li><li><code>w::Int = 1</code> : The Theiler window, which determines whether points are separated enough in time to be considered separate trajectories (see<sup class="footnote-reference"><a id="citeref-Skokos2016" href="#footnote-Skokos2016">[Skokos2016]</a></sup> and <a href="../../embedding/dataset/#DelayEmbeddings.neighborhood"><code>neighborhood</code></a>).</li><li><code>ntype::AbstractNeighborhood = FixedMassNeighborhood(1)</code> : The method to be used when evaluating the neighborhood of each reference state. See <a href="../../embedding/dataset/#DelayEmbeddings.AbstractNeighborhood"><code>AbstractNeighborhood</code></a> or <a href="../../embedding/dataset/#DelayEmbeddings.neighborhood"><code>neighborhood</code></a> for more info.</li><li><code>distance::Metric = Cityblock()</code> : The distance function used in the logarithmic distance of nearby states. The allowed distances are <code>Cityblock()</code> and <code>Euclidean()</code>. See below for more info.</li></ul><p><strong>Description</strong></p><p>If the dataset/reconstruction exhibits exponential divergence of nearby states, then it should clearly hold</p><div>\[E(k) \approx \lambda\cdot k \cdot \Delta t + E(0)\]</div><p>for a <em>well defined region</em> in the <code>k</code> axis, where <span>$\lambda$</span> is the approximated maximum Lyapunov exponent. <span>$\Delta t$</span> is the time between samples in the original timeseries. You can use <a href="../entropies/#ChaosTools.linear_region"><code>linear_region</code></a> with arguments <code>(ks .* Δt, E)</code> to identify the slope (= <span>$\lambda$</span>) immediatelly, assuming you have choosen sufficiently good <code>ks</code> such that the linear scaling region is bigger than the saturated region.</p><p>The algorithm used in this function is due to Parlitz<sup class="footnote-reference"><a id="citeref-Skokos2016" href="#footnote-Skokos2016">[Skokos2016]</a></sup>, which itself expands upon Kantz <sup class="footnote-reference"><a id="citeref-Kantz1994" href="#footnote-Kantz1994">[Kantz1994]</a></sup>. In sort, for each reference state a neighborhood is evaluated. Then, for each point in this neighborhood, the logarithmic distance between reference state and neighborhood state is calculated as the &quot;time&quot; index <code>k</code> increases. The average of the above over all neighborhood states over all reference states is the returned result.</p><p>If the <code>Metric</code> is <code>Euclidean()</code> then use the Euclidean distance of the full <code>D</code>-dimensional points (distance <span>$d_E$</span> in ref.<sup class="footnote-reference"><a id="citeref-Skokos2016" href="#footnote-Skokos2016">[Skokos2016]</a></sup>). If however the <code>Metric</code> is <code>Cityblock()</code>, calculate the absolute distance of <em>only the first elements</em> of the <code>m+k</code> and <code>n+k</code> points of the reconstruction <code>R</code> (distance <span>$d_F$</span> in ref.<sup class="footnote-reference"><a id="citeref-Skokos2016" href="#footnote-Skokos2016">[Skokos2016]</a></sup>).</p></div></section></article><hr/><p>The function <code>numericallyapunov</code> has a total of 4 different approaches for the algorithmic process, by combining 2 types of distances with 2 types of neighborhoods.</p><h3 id="Example-of-Numerical-Lyapunov-computation-1"><a class="docs-heading-anchor" href="#Example-of-Numerical-Lyapunov-computation-1">Example of Numerical Lyapunov computation</a><a class="docs-heading-anchor-permalink" href="#Example-of-Numerical-Lyapunov-computation-1" title="Permalink"></a></h3><pre><code class="language-julia">using DynamicalSystems, PyPlot

ds = Systems.henon()
data = trajectory(ds, 100000)
x = data[:, 1] #fake measurements for the win!

ks = 1:20
ℜ = 1:10000
fig = figure(figsize=(10,6))

for (i, di) in enumerate([Euclidean(), Cityblock()])
    subplot(1, 2, i)
    ntype = FixedMassNeighborhood(2)
    title(&quot;Distance: $(di)&quot;, size = 18)
    for D in [2, 4, 7]
        R = embed(x, D, 1)
        E = numericallyapunov(R, ks;
        refstates = ℜ, distance = di, ntype = ntype)
        Δt = 1
        λ = linear_region(ks.*Δt, E)[2]
        # gives the linear slope, i.e. the Lyapunov exponent
        plot(ks .- 1, E .- E[1], label = &quot;D=$D, λ=$(round(λ, digits = 3))&quot;)
        legend()
        tight_layout()
    end
end</code></pre><p><img src="../numerlyap.png" alt/></p><h3 id="Bad-Time-axis-(ks)-length-1"><a class="docs-heading-anchor" href="#Bad-Time-axis-(ks)-length-1">Bad Time-axis (<code>ks</code>) length</a><a class="docs-heading-anchor-permalink" href="#Bad-Time-axis-(ks)-length-1" title="Permalink"></a></h3><div class="admonition is-danger"><header class="admonition-header">Large `ks`</header><div class="admonition-body"><p>This simply cannot be stressed enough! It is just too easy to overshoot the range at which the exponential expansion region is valid!</p></div></div><p>Let&#39;s revisit the example of the previous section:</p><pre><code class="language-julia">ds = Systems.henon()
data = trajectory(ds, 100000)
x = data[:, 1]
length(x)</code></pre><pre><code class="language-none">100001</code></pre><p>The timeseries of such length could be considered big. A time length of 100 seems very small. Yet it turns out it is way too big! The following</p><pre><code class="language-julia">ks = 1:100
R = embed(x, 2, 1)
E = numericallyapunov(R, ks, ntype = FixedMassNeighborhood(2))
fig = figure()
plot(ks .- 1, E .- E[1])
title(&quot;Lyappunov: $(linear_region(ks, E)[2])&quot;)</code></pre><p><img src="../badlyap.png" alt/></p><p>Notice that even though this value for the Lyapunov exponent is correct, it happened to be correct simply due to the jitter of the saturated region. Since the saturated region is much bigger than the linear scaling region, if it wasn&#39;t that jittery the function <a href="../entropies/#ChaosTools.linear_region"><code>linear_region</code></a> would not give the scaling of the linear region, but instead a slope near 0! (or if you were to give bigger tolerance as a keyword argument)</p><h3 id="Case-of-a-Continuous-system-1"><a class="docs-heading-anchor" href="#Case-of-a-Continuous-system-1">Case of a Continuous system</a><a class="docs-heading-anchor-permalink" href="#Case-of-a-Continuous-system-1" title="Permalink"></a></h3><p>The process for continuous systems works identically with discrete, but one must be a bit more thoughtful when choosing parameters. The following example helps the users get familiar with the process:</p><pre><code class="language-julia">using DynamicalSystems, PyPlot

ntype = FixedMassNeighborhood(5) #5 nearest neighbors of each state

ds = Systems.lorenz()
# create a timeseries of 1 dimension
dt = 0.05
x = trajectory(ds, 1000.0; dt = dt)[:, 1]</code></pre><pre><code class="language-none">20001-element Array{Float64,1}:
   0.0
   4.285178117517708
   8.924780522479637
  15.012203311102235
  20.05533894475613
  18.062350952804728
   9.898343637398332
   2.199113375749754
  -2.6729722259323863
  -5.33812377718313
   ⋮
  -3.810825689423999
  -4.900396720248087
  -6.241066898514638
  -7.940150591858717
  -9.900960829002475
 -11.678879507784437
 -12.495362895268917
 -11.76970885072464
  -9.786325967697445</code></pre><p>We know that we have to use much bigger <code>ks</code> than <code>1:20</code>, because this is a continuous case! (See reference given in <code>numericallyapunovs</code>)</p><pre><code class="language-julia">ks1 = 0:200</code></pre><pre><code class="language-none">0:200</code></pre><p>and in fact it is even better to not increment the <code>ks</code> one by one but instead do</p><pre><code class="language-julia">ks2 = 0:4:200</code></pre><pre><code class="language-none">0:4:200</code></pre><p>Now we plot some example computations</p><pre><code class="language-julia">figure()
for D in [4, 8], τ in [7, 15]
    r = embed(x, D, τ)

    # E1 = numericallyapunov(r, ks1; ntype = ntype)
    # λ1 = linear_region(ks1 .* dt, E1)[2]
    E2 = numericallyapunov(r, ks2; ntype = ntype)
    λ2 = linear_region(ks2 .* dt, E2)[2]

    # plot(ks1,E1.-E1[1], label = &quot;dense, D=$(D), τ=$(τ), λ=$(round(λ1, 3))&quot;)
    plot(ks2,E2.-E2[1], label = &quot;D=$(D), τ=$(τ), λ=$(round(λ2, digits = 3))&quot;)
end

legend()
xlabel(&quot;k (0.05×t)&quot;)
ylabel(&quot;E - E(0)&quot;)
title(&quot;Continuous Reconstruction Lyapunov&quot;)
tight_layout()</code></pre><p><img src="../continuousnumlyap.png" alt/></p><p>As you can see, using <code>τ = 15</code> is not a great choice! The estimates with <code>τ = 7</code> though are very good (the actual value is around <code>λ ≈ 0.89...</code>).</p><h2 id="Broomhead-King-Coordinates-1"><a class="docs-heading-anchor" href="#Broomhead-King-Coordinates-1">Broomhead-King Coordinates</a><a class="docs-heading-anchor-permalink" href="#Broomhead-King-Coordinates-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ChaosTools.broomhead_king" href="#ChaosTools.broomhead_king"><code>ChaosTools.broomhead_king</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">broomhead_king(s::AbstractVector, d::Int) -&gt; U, S, Vtr</code></pre><p>Return the Broomhead-King coordinates of a timeseries <code>s</code> by performing <code>svd</code> on the so-called trajectory matrix with dimension <code>d</code>.</p><p><strong>Description</strong></p><p>Broomhead and King coordinates is an approach proposed in <sup class="footnote-reference"><a id="citeref-Broomhead1987" href="#footnote-Broomhead1987">[Broomhead1987]</a></sup> that applies the Karhunen–Loève theorem to delay coordinates embedding with smallest possible delay.</p><p>The function performs singular value decomposition on the <code>d</code>-dimensional trajectory matrix <span>$X$</span> of <span>$s$</span>,</p><div>\[X = \frac{1}{\sqrt{N}}\left(
\begin{array}{cccc}
x_1 &amp; x_2 &amp; \ldots &amp; x_d \\
x_2 &amp; x_3 &amp; \ldots &amp; x_{d+1}\\
\vdots &amp; \vdots &amp; \vdots &amp; \vdots \\
x_{N-d+1} &amp; x_{N-d+2} &amp;\ldots &amp; x_N
\end{array}
\right) = U\cdot S \cdot V^{tr}.\]</div><p>where <span>$x := s - \bar{s}$</span>. The columns of <span>$U$</span> can then be used as a new coordinate system, and by considering the values of the singular values <span>$S$</span> you can decide how many columns of <span>$U$</span> are &quot;important&quot;. See the documentation page for example application.</p></div></section></article><hr/><p>This alternative/improvement of the traditional delay coordinates can be a very powerful tool. An example where it shines is noisy data where there is the effect of superficial dimensions due to noise.</p><p>Take the following example where we produce noisy data from a system and then use Broomhead-King coordinates as an alternative to &quot;vanilla&quot; delay coordinates:</p><pre><code class="language-julia">using DynamicalSystems, PyPlot

ds = Systems.gissinger()
data = trajectory(ds, 1000.0, dt = 0.05)
x = data[:, 1]

L = length(x)
s = x .+ 0.5rand(L) #add noise

U, S = broomhead_king(s, 40)
summary(U)</code></pre><pre><code class="language-none">&quot;19962×40 Array{Float64,2}&quot;</code></pre><p>Now let&#39;s simply compare the above result with the one you get from doing a &quot;standard&quot; call to <a href="../../embedding/reconstruction/#DelayEmbeddings.embed"><code>embed</code></a>:</p><pre><code class="language-julia">fig=figure(figsize= (10,6))
subplot(1,2,1)
plot(U[:, 1], U[:, 2])
title(&quot;Broomhead-King of s&quot;)

subplot(1,2,2)
R = embed(s, 2, 30)
plot(columns(R)...; color = &quot;C3&quot;)
title(&quot;2D embedding of s&quot;)
tight_layout()</code></pre><p><img src="../broomhead_king.png" alt/></p><p>we have used the same system as in the <a href="../../embedding/reconstruction/#Delay-Coordinates-Embedding-1">Delay Coordinates Embedding</a> example, and picked the optimal delay time of <code>τ = 30</code> (for same <code>dt = 0.05</code>). Regardless, the vanilla delay coordinates is much worse than the Broomhead-King coordinates.</p><h2 id="Nearest-Neighbor-Prediction-1"><a class="docs-heading-anchor" href="#Nearest-Neighbor-Prediction-1">Nearest Neighbor Prediction</a><a class="docs-heading-anchor-permalink" href="#Nearest-Neighbor-Prediction-1" title="Permalink"></a></h2><p>Nearest neighbor timeseries prediction is a method commonly listed under nonlinear timeseries analysis. This is not part of DynamicalSystems.jl, because in JuliaDynamics we have a dedicated package for this, <a href="https://juliadynamics.github.io/TimeseriesPrediction.jl/dev/">TimeseriesPrediction.jl</a>.</p><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-Skokos2016"><a class="tag is-link" href="#citeref-Skokos2016">Skokos2016</a>Skokos, C. H. <em>et al.</em>, <em>Chaos Detection and Predictability</em> - Chapter 1 (section 1.3.2), Lecture Notes in Physics <strong>915</strong>, Springer (2016)</li><li class="footnote" id="footnote-Kantz1994"><a class="tag is-link" href="#citeref-Kantz1994">Kantz1994</a>Kantz, H., Phys. Lett. A <strong>185</strong>, pp 77–87 (1994)</li><li class="footnote" id="footnote-Broomhead1987"><a class="tag is-link" href="#citeref-Broomhead1987">Broomhead1987</a>D. S. Broomhead, R. Jones and G. P. King, J. Phys. A <strong>20</strong>, 9, pp L563 (1987)</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../entropies/">« Entropies and Dimensions</a><a class="docs-footer-nextpage" href="../periodicity/">Periodicity &amp; Ergodicity »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 19 November 2020 22:37">Thursday 19 November 2020</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
