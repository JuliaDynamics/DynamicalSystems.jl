<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Recurrence Quantification Analysis · DynamicalSystems.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/logo.ico" rel="icon" type="image/x-icon"/><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="DynamicalSystems.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">DynamicalSystems.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../../contents/">Contents</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Dynamical systems</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../ds/general/">Dynamical System Definition</a></li><li><a class="tocitem" href="../../ds/predefined/">Predefined Dynamical Systems</a></li><li><a class="tocitem" href="../../embedding/dataset/">Numerical Data</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Entropies</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../entropies/api/">Entropies &amp; Probabilities</a></li><li><a class="tocitem" href="../../entropies/estimators/">Probabilities Estimators</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">DelayEmbeddings</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../embedding/reconstruction/">Delay Coordinates Embedding</a></li><li><a class="tocitem" href="../../embedding/traditional/">Traditional Optimal Embedding</a></li><li><a class="tocitem" href="../../embedding/unified/">Unified Optimal Embedding</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">ChaosTools</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../chaos/orbitdiagram/">Orbit Diagrams &amp; PSOS</a></li><li><a class="tocitem" href="../../chaos/lyapunovs/">Lyapunov Exponents</a></li><li><a class="tocitem" href="../../chaos/chaos_detection/">Detecting &amp; Categorizing Chaos</a></li><li><a class="tocitem" href="../../chaos/fractaldim/">Fractal Dimension</a></li><li><a class="tocitem" href="../../chaos/nlts/">Nonlinear Timeseries Analysis</a></li><li><a class="tocitem" href="../../chaos/periodicity/">Periodicity &amp; Ergodicity</a></li><li><a class="tocitem" href="../../chaos/choosing/">Choosing a solver</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox" checked/><label class="tocitem" for="menuitem-7"><span class="docs-label">RecurrenceAnalysis</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../rplots/">Recurrence Plots</a></li><li class="is-active"><a class="tocitem" href>Recurrence Quantification Analysis</a><ul class="internal"><li><a class="tocitem" href="#RQA-Measures"><span>RQA Measures</span></a></li><li><a class="tocitem" href="#Keyword-table"><span>Keyword table</span></a></li><li><a class="tocitem" href="#Recurrence-Structures-Histograms"><span>Recurrence Structures Histograms</span></a></li></ul></li><li><a class="tocitem" href="../windowed/">Windowed RQA</a></li><li><a class="tocitem" href="../networks/">Recurrence Network Analysis</a></li></ul></li><li><a class="tocitem" href="../../advanced/">Advanced Documentation</a></li><li><a class="tocitem" href="../../contributors_guide/">Contributor Guide</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">RecurrenceAnalysis</a></li><li class="is-active"><a href>Recurrence Quantification Analysis</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Recurrence Quantification Analysis</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDynamics/DynamicalSystems.jl/blob/master/docs/src/rqa/quantification.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Recurrence-Quantification-Analysis"><a class="docs-heading-anchor" href="#Recurrence-Quantification-Analysis">Recurrence Quantification Analysis</a><a id="Recurrence-Quantification-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Recurrence-Quantification-Analysis" title="Permalink"></a></h1><p>A <a href="../rplots/#RecurrenceAnalysis.RecurrenceMatrix"><code>RecurrenceMatrix</code></a> can be analyzed in several ways to yield information about the dynamics of the trajectory. All these various <em>measures</em> and functions are collectively called &quot;Recurrence Quantification Analysis&quot; (RQA).</p><p>To understand how each measure can be useful, we suggest to see the review articles listed in our documentation strings, namely:</p><ol><li>N. Marwan <em>et al.</em>, &quot;Recurrence plots for the analysis of complex systems&quot;, <em>Phys. Reports 438</em>(5-6), 237-329 (2007).</li><li>N. Marwan &amp; C.L. Webber, &quot;Mathematical and computational foundations of recurrence quantifications&quot;, in: Webber, C.L. &amp; N. Marwan (eds.), <em>Recurrence Quantification Analysis. Theory and Best Practices</em>, Springer, pp. 3-43 (2015).</li></ol><p>You can also check the wikipedia page for <a href="https://en.wikipedia.org/wiki/Recurrence_quantification_analysis">Recurrence quantification analysis</a>.</p><p>The functions described in this page all accept a recurrence matrix (<code>x</code>), see <a href="../rplots/#RecurrenceAnalysis.RecurrenceMatrix"><code>RecurrenceMatrix</code></a>.</p><h2 id="RQA-Measures"><a class="docs-heading-anchor" href="#RQA-Measures">RQA Measures</a><a id="RQA-Measures-1"></a><a class="docs-heading-anchor-permalink" href="#RQA-Measures" title="Permalink"></a></h2><h3 id="All-in-one-Bundle"><a class="docs-heading-anchor" href="#All-in-one-Bundle">All-in-one Bundle</a><a id="All-in-one-Bundle-1"></a><a class="docs-heading-anchor-permalink" href="#All-in-one-Bundle" title="Permalink"></a></h3><p>In case you need all of the RQA-related functions (see below) and you don&#39;t want to write 10 lines of code to compute them all (since they are so many) we provide an all-in-one function that computes all of them and returns a dictionary with the results!</p><article class="docstring"><header><a class="docstring-binding" id="RecurrenceAnalysis.rqa" href="#RecurrenceAnalysis.rqa"><code>RecurrenceAnalysis.rqa</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rqa(R; kwargs...)</code></pre><p>Calculate all RQA parameters of a recurrence matrix <code>R</code>. See the functions referred to below for the definition of the different parameters and the default values of the arguments. Using this function is much more efficient than calling all individual functions one by one.</p><p><strong>Return</strong></p><p>The returned value contains the following entries, which can be retrieved as from a dictionary (e.g. <code>results[:RR]</code>, etc.):</p><ul><li><code>:RR</code>: recurrence rate (see <a href="#RecurrenceAnalysis.recurrencerate"><code>recurrencerate</code></a>)</li><li><code>:DET</code>: determinsm (see <a href="#RecurrenceAnalysis.determinism"><code>determinism</code></a>)</li><li><code>:L</code>: average length of diagonal structures (see <a href="#RecurrenceAnalysis.dl_average"><code>dl_average</code></a>)</li><li><code>:Lmax</code>: maximum length of diagonal structures (see <a href="#RecurrenceAnalysis.dl_max"><code>dl_max</code></a>)</li><li><code>:DIV</code>: divergence (see <a href="#RecurrenceAnalysis.divergence"><code>divergence</code></a>)</li><li><code>:ENTR</code>: entropy of diagonal structures (see <a href="#RecurrenceAnalysis.dl_entropy"><code>dl_entropy</code></a>)</li><li><code>:TREND</code>: trend of recurrences (see <a href="#RecurrenceAnalysis.trend"><code>trend</code></a>)</li><li><code>:LAM</code>: laminarity (see <a href="#RecurrenceAnalysis.laminarity"><code>laminarity</code></a>)</li><li><code>:TT</code>: trapping time (see <a href="#RecurrenceAnalysis.trappingtime"><code>trappingtime</code></a>)</li><li><code>:Vmax</code>: maximum length of vertical structures (see <a href="#RecurrenceAnalysis.vl_max"><code>vl_max</code></a>)</li><li><code>:VENTR</code>: entropy of vertical structures (see <a href="#RecurrenceAnalysis.vl_entropy"><code>vl_entropy</code></a>)</li><li><code>:MRT</code>: mean recurrence time (see <a href="#RecurrenceAnalysis.meanrecurrencetime"><code>meanrecurrencetime</code></a>)</li><li><code>:RTE</code> recurrence time entropy (see <a href="#RecurrenceAnalysis.rt_entropy"><code>rt_entropy</code></a>)</li><li><code>:NMPRT</code>: number of the most probable recurrence time (see <a href="#RecurrenceAnalysis.nmprt"><code>nmprt</code></a>)</li></ul><p>All the parameters returned by <code>rqa</code> are <code>Float64</code> numbers, even for parameters like <code>:Lmax</code>, <code>:Vmax</code> or <code>:NMPRT</code> which are integer values. In the case of empty histograms (e.g. no existing vertical lines less than the keyword <code>lminvert</code>) the average and maximum values (<code>:L</code>, <code>:Lmax</code>, <code>:TT</code>, <code>:Vmax</code>, <code>:MRT</code>) are returned as <code>0.0</code> but their respective entropies (<code>:ENTR</code>, <code>:VENTR</code>, <code>:RTE</code>) are returned as <code>NaN</code>.</p><p><strong>Keyword Arguments</strong></p><p>Standard keyword arguments are the ones accepted by the functions listed below, i.e. <code>theiler</code>, <code>lmin</code>, and <code>border</code>:</p><ul><li><p><code>theiler</code> is used to define a &quot;Theiler window&quot; around the central diagonal or &quot;line of identity&quot; (LOI): a region of points that are excluded in the calculation of RQA parameters, in order to rule out self-recurrences and apparent recurrences for smooth or high resolution data. The LOI is excluded by default for matrices of the types <code>RecurrenceMatrix</code> or <code>JointRecurrenceMatrix</code>, but it is included for matrices of the type <code>CrossRecurrenceMatrix</code>. <code>theiler=0</code> means that the whole matrix is scanned for lines. <code>theiler=1</code> means that the LOI is excluded. In general, <code>theiler=n</code> means that the <code>n</code> central diagonals are excluded (at both sides of the LOI, i.e. actually <code>2n-1</code> diagonals are excluded).</p></li><li><p><code>lmin</code> is used to define the minimum line length in the parameters that describe the distributions of diagonal or vertical lines (it is set as 2 by default).</p></li><li><p><code>border</code> is used to avoid border effects in the calculation of <code>:TREND</code> (cf. <a href="#RecurrenceAnalysis.trend"><code>trend</code></a>).</p></li></ul><p>In addition <code>theilerdiag</code>, <code>lmindiag</code> may be used to declare specific values that override the values of <code>theiler</code> and <code>lmin</code> in the calculation of parameters related to diagonal structures. Likewise, <code>theilervert</code> and <code>lminvert</code> can be used for the calculation of parameters related to vertical structures.</p><p>The keyword argument <code>onlydiagonal</code> (<code>false</code> by default) can be set to <code>true</code> in order to restrict the analysis to the recurrence rate and the parameters related to diagonal structures (<code>:RR</code>, <code>:DET</code>, <code>:L</code>, <code>:Lmax</code>, <code>:DIV</code> and <code>:ENTR</code>), which makes this function slightly faster.</p><p><strong>Transitional note on the returned type</strong></p><p>In older versions, the <code>rqa</code> function returned a <code>NamedTuple</code>, and in future versions it is planned to return a <code>Dict</code> instead. In both cases, the results can be indexed with square brackets and <code>Symbol</code> keys, as <code>result[:RR]</code>, <code>result[:DET]</code>, etc. However, named tuples can also be indexed with &quot;dot syntax&quot;, e.g. <code>result.RR</code>, whereas this will not be possible with dictionaries, and there are other differences in the indexing and iteration of those two types.</p><p>In order to facilitate the transition between versions, this function currently returns a <code>RQA</code> object that essentially works as a dictionary, but can also be indexed with the dot syntax (logging a deprecation warning). The returned type can also be specified as a first argument of <code>rqa</code> in order to replicate the output of different versions:</p><ul><li><code>rqa(NamedTuple, R...)</code> to obtain the output of the older version (as in 1.3).</li><li><code>rqa(Dict, R...)</code> to obtain the output of the planned future version.</li><li><code>rqa(RQA, R...)</code> to obtain the default current output (same as <code>rqa(R...)</code>)</li></ul></div></section></article><hr/><div class="admonition is-info"><header class="admonition-header">Return values for empty histograms</header><div class="admonition-body"><p>It may be the case that for a given recurrence matrix some structures do not exist at all. For example there are recurrence matrices that have no vertical lengths (or no vertical lengths with length less than <code>lmin</code>). In such cases the behavior of our RQA pipeline is the following:</p><ol><li>Quantities that represent maximum or average values are <code>0.0</code>.</li><li>Quantities that represent entropies are <code>NaN</code>.</li></ol></div></div><hr/><p>See also the <a href="../windowed/#RecurrenceAnalysis.@windowed"><code>@windowed</code></a> macro for a windowed version of <code>rqa</code>.</p><h3 id="Classical-RQA-Measures"><a class="docs-heading-anchor" href="#Classical-RQA-Measures">Classical RQA Measures</a><a id="Classical-RQA-Measures-1"></a><a class="docs-heading-anchor-permalink" href="#Classical-RQA-Measures" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="RecurrenceAnalysis.recurrencerate" href="#RecurrenceAnalysis.recurrencerate"><code>RecurrenceAnalysis.recurrencerate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">recurrencerate(R[; theiler])</code></pre><p>Calculate the recurrence rate of the recurrence matrix <code>R</code>.</p><p><strong>Description</strong></p><p>The recurrence rate is calculated as:</p><p class="math-container">\[RR = \frac{1}{S} \sum R\]</p><p>where <span>$S$</span> is the size of <code>R</code> or the region of <code>R</code> with potential recurrent points. There is not a unique definition of that denominator, which is defined as the full size of the matrix in many sources (e.g. [1]), whereas in others it is adjusted to remove the points of the LOI when they are excluded from the count [2,3].</p><p>For matrices of type <code>RecurrenceMatrix</code> or <code>JointRecurrenceMatrix</code>, where the points around the central diagonal are usually excluded, the denominator is adjusted to the size of the matrix outside the Theiler window (by default equal to the LOI, and adjustable with the keyword argument <code>theiler</code>; see <a href="#RecurrenceAnalysis.rqa"><code>rqa</code></a> for details). For matrices of type <code>CrossRecurrenceMatrix</code>, where normally all points are analyzed, the denominator is always the full size of the matrix, regardless of the Theiler window that might be defined (none by default).</p><p><em>Hint</em>: to reproduce the calculations done following the formulas that use the full size of the matrix in the denominator, use <code>CrossRecurrenceMatrix(s,s,ε)</code> to define the recurrence matrix, instead of <code>RecurrenceMatrix(s,ε)</code>, setting <code>theiler=1</code> (or <code>theiler=n</code> in general) to explicitly exclude the LOI or other diagonals around it.</p><p><strong>References</strong></p><p>[1] : N. Marwan <em>et al.</em>, &quot;Recurrence plots for the analysis of complex systems&quot;, <em>Phys. Reports 438</em>(5-6), 237-329 (2007). <a href="https://doi.org/10.1016/j.physrep.2006.11.001">DOI:10.1016/j.physrep.2006.11.001</a></p><p>[2] : C.L. Webber &amp; J.P. Zbilut, &quot;Recurrence Quantification Analysis of Nonlinear Dynamical Systems&quot;, in: Riley MA &amp; Van Orden GC, Tutorials in Contemporary Nonlinear Methods for the Behavioral Sciences, 26-94 (2005). URL: https://www.nsf.gov/pubs/2005/nsf05057/nmbs/nmbs.pdf</p><p>[3] : N. Marwan &amp; C.L. Webber, &quot;Mathematical and computational foundations of recurrence quantifications&quot;, in: Webber, C.L. &amp; N. Marwan (eds.), <em>Recurrence Quantification Analysis. Theory and Best Practices</em>, Springer, pp. 3-43 (2015).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RecurrenceAnalysis.determinism" href="#RecurrenceAnalysis.determinism"><code>RecurrenceAnalysis.determinism</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">determinism(R[; lmin=2, theiler])</code></pre><p>Calculate the determinism of the recurrence matrix <code>R</code>:</p><p><strong>Description</strong></p><p>The determinism is calculated as:</p><p class="math-container">\[DET = \frac{\sum_{l=lmin}{l P(l)}}{\sum_{l=1}{l P(l)}} =
\frac{\sum_{l=lmin}{l P(l)}}{\sum R}\]</p><p>where <span>$l$</span> stands for the lengths of diagonal lines in the matrix, and <span>$P(l)$</span> is the number of lines of length equal to <span>$l$</span>.</p><p><code>lmin</code> is set to 2 by default, and this calculation rules out all the points inside the Theiler window (see <a href="#RecurrenceAnalysis.rqa"><code>rqa</code></a> for the default values and usage of the keyword argument <code>theiler</code>).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RecurrenceAnalysis.dl_average" href="#RecurrenceAnalysis.dl_average"><code>RecurrenceAnalysis.dl_average</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dl_average(R[; lmin=2, theiler])</code></pre><p>Calculate the average of the diagonal lines contained in the recurrence matrix <code>R</code>, ruling out the lines shorter than <code>lmin</code> (2 by default) and all the points inside the Theiler window (see <a href="#RecurrenceAnalysis.rqa"><code>rqa</code></a> for the default values and usage of the keyword argument <code>theiler</code>).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RecurrenceAnalysis.dl_max" href="#RecurrenceAnalysis.dl_max"><code>RecurrenceAnalysis.dl_max</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dl_max(R[; lmin=2, theiler])</code></pre><p>Calculate the longest diagonal line contained in the recurrence matrix <code>R</code>, ruling out the lines shorter than <code>lmin</code> (2 by default) and all the points inside the Theiler window (see <a href="#RecurrenceAnalysis.rqa"><code>rqa</code></a> for the default values and usage of the keyword argument <code>theiler</code>).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RecurrenceAnalysis.dl_entropy" href="#RecurrenceAnalysis.dl_entropy"><code>RecurrenceAnalysis.dl_entropy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dl_entropy(R[; lmin=2, theiler])</code></pre><p>Calculate the Shannon entropy of the diagonal lines contained in the recurrence matrix <code>R</code>, ruling out the lines shorter than <code>lmin</code> (2 by default) and all the points inside the Theiler window (see <a href="#RecurrenceAnalysis.rqa"><code>rqa</code></a> for the default values and usage of the keyword argument <code>theiler</code>).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RecurrenceAnalysis.divergence" href="#RecurrenceAnalysis.divergence"><code>RecurrenceAnalysis.divergence</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">divergence(R[; theiler])</code></pre><p>Calculate the divergence of the recurrence matrix <code>R</code> (actually the inverse of <a href="#RecurrenceAnalysis.dl_max"><code>dl_max</code></a>).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RecurrenceAnalysis.trend" href="#RecurrenceAnalysis.trend"><code>RecurrenceAnalysis.trend</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">trend(R[; border=10, theiler])</code></pre><p>Calculate the trend of recurrences in the recurrence matrix <code>R</code>.</p><p><strong>Description</strong></p><p>The trend is the slope of the linear regression that relates the density of recurrent points in the diagonals parallel to the LOI and the distance between those diagonals and the LOI. It quantifies the degree of system stationarity, such that in recurrence plots where points &quot;fade away&quot; from the central diagonal, the trend will have a negative value.</p><p>It is calculated as:</p><p class="math-container">\[TREND = 10^3\frac{\sum_{d=\tau}^{\tilde{N}}\delta[d]\left(RR[d]-\langle RR[d]\rangle\right)}{\sum_{d=\tau}^{\tilde{N}}\delta[d]^2}\]</p><p>where <span>$RR[d]$</span> is the local recurrence rate of the diagonal <span>$d$</span>, <span>$\delta[d]$</span> is a balanced measure of the distance between that diagonal and the LOI, <span>$\tau$</span> is the Theiler window (number of central diagonals that are excluded), and <span>$\tilde{N}$</span> is the number of the outmost diagonal that is included.</p><p>This parameter is expressed in units of variation recurrence rate every 1000 data points, hence the factor <span>$10^3$</span> in the formula [1].</p><p>The 10 outermost diagonals (counting from the corners of the matrix) are excluded by default to avoid &quot;border effects&quot;. Use the keyword argument <code>border</code> to define a different number of excluded lines, and <code>theiler</code> to define the size of the Theiler window (see <a href="#RecurrenceAnalysis.rqa"><code>rqa</code></a> for details).</p><p><em>Note</em>: In rectangular cross-recurrence plots (i.e. when the time series that originate them are not of the same length), the limits of the formula for TREND are not clearly defined. For the sake of consistency, this function limits the calculations to the biggest square matrix that contains the LOI.</p><p><strong>References</strong></p><p>[1] C.L. Webber &amp; J.P. Zbilut, &quot;Recurrence Quantification Analysis of Nonlinear Dynamical Systems&quot;, in: Riley MA &amp; Van Orden GC, <em>Tutorials in Contemporary Nonlinear Methods for the Behavioral Sciences</em>, 2005, 26-94. https://www.nsf.gov/pubs/2005/nsf05057/nmbs/nmbs.pdf</p></div></section></article><h3 id="Extended-RQA-Measures"><a class="docs-heading-anchor" href="#Extended-RQA-Measures">Extended RQA Measures</a><a id="Extended-RQA-Measures-1"></a><a class="docs-heading-anchor-permalink" href="#Extended-RQA-Measures" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="RecurrenceAnalysis.laminarity" href="#RecurrenceAnalysis.laminarity"><code>RecurrenceAnalysis.laminarity</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">laminarity(R[; lmin=2, theiler])</code></pre><p>Calculate the laminarity of the recurrence matrix <code>R</code>.</p><p><strong>Description</strong></p><p>The laminarity is calculated as:</p><p class="math-container">\[LAM = \frac{\sum_{v=lmin}{v P(l)}}{\sum_{v=1}{v P(v)}} =
\frac{\sum_{v=lmin}{v P(l)}}{\sum R}\]</p><p>where <span>$v$</span> stands for the lengths of vertical lines in the matrix, and <span>$P(v)$</span> is the number of lines of length equal to <span>$v$</span>.</p><p><code>lmin</code> is set to 2 by default, and this calculation rules out all the points inside the Theiler window (see <a href="#RecurrenceAnalysis.rqa"><code>rqa</code></a> for the default values and usage of the keyword argument <code>theiler</code>).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RecurrenceAnalysis.trappingtime" href="#RecurrenceAnalysis.trappingtime"><code>RecurrenceAnalysis.trappingtime</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">trappingtime(R[; lmin=2, theiler])</code></pre><p>Calculate the trapping time of the recurrence matrix <code>R</code>, ruling out the lines shorter than <code>lmin</code> (2 by default) and all the points inside the Theiler window (see <a href="#RecurrenceAnalysis.rqa"><code>rqa</code></a> for the default values and usage of the keyword argument <code>theiler</code>).</p><p>The trapping time is the average of the vertical line structures and thus equal to <a href="#RecurrenceAnalysis.vl_average"><code>vl_average</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RecurrenceAnalysis.vl_average" href="#RecurrenceAnalysis.vl_average"><code>RecurrenceAnalysis.vl_average</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">vl_average(R[; lmin=2, theiler])</code></pre><p>Calculate the average of the vertical lines contained in the recurrence matrix <code>R</code>, ruling out the lines shorter than <code>lmin</code> (2 by default) and all the points inside the Theiler window (see <a href="#RecurrenceAnalysis.rqa"><code>rqa</code></a> for the default values and usage of the keyword argument <code>theiler</code>).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RecurrenceAnalysis.vl_max" href="#RecurrenceAnalysis.vl_max"><code>RecurrenceAnalysis.vl_max</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">vl_max(R[; lmin=2, theiler])</code></pre><p>Calculate the longest vertical line contained in the recurrence matrix <code>R</code>, ruling out the lines shorter than <code>lmin</code> (2 by default) and all the points inside the Theiler window (see <a href="#RecurrenceAnalysis.rqa"><code>rqa</code></a> for the default values and usage of the keyword argument <code>theiler</code>).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RecurrenceAnalysis.vl_entropy" href="#RecurrenceAnalysis.vl_entropy"><code>RecurrenceAnalysis.vl_entropy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">vl_entropy(R[; lmin=2, theiler])</code></pre><p>Calculate the Shannon entropy of the vertical lines contained in the recurrence matrix <code>R</code>, ruling out the lines shorter than <code>lmin</code> (2 by default) and all the points inside the Theiler window (see <a href="#RecurrenceAnalysis.rqa"><code>rqa</code></a> for the default values and usage of the keyword argument <code>theiler</code>).</p></div></section></article><h3 id="Recurrence-Time-Measures"><a class="docs-heading-anchor" href="#Recurrence-Time-Measures">Recurrence Time Measures</a><a id="Recurrence-Time-Measures-1"></a><a class="docs-heading-anchor-permalink" href="#Recurrence-Time-Measures" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="RecurrenceAnalysis.meanrecurrencetime" href="#RecurrenceAnalysis.meanrecurrencetime"><code>RecurrenceAnalysis.meanrecurrencetime</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">meanrecurrencetime(R[; lmin=2, theiler])</code></pre><p>Calculate the mean recurrence time of the recurrence matrix <code>R</code>, ruling out the lines shorter than <code>lmin</code> (2 by default) and all the points inside the Theiler window (see <a href="#RecurrenceAnalysis.rqa"><code>rqa</code></a> for the default values and usage of the keyword argument <code>theiler</code>).</p><p>Equivalent to <a href="#RecurrenceAnalysis.rt_average"><code>rt_average</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RecurrenceAnalysis.nmprt" href="#RecurrenceAnalysis.nmprt"><code>RecurrenceAnalysis.nmprt</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nmprt(R[; lmin=2, theiler])</code></pre><p>Calculate the number of the most probable recurrence time (NMPRT), ruling out the lines shorter than <code>lmin</code> (2 by default) and all the points inside the Theiler window (see <a href="#RecurrenceAnalysis.rqa"><code>rqa</code></a> for the default values and usage of the keyword argument <code>theiler</code>).</p><p>This number indicates how many times the system has recurred using the recurrence time that appears most frequently, i.e it is the maximum value of the histogram of recurrence times [1].</p><p><strong>References</strong></p><p>[1] : E.J. Ngamga <em>et al.</em> &quot;Recurrence analysis of strange nonchaotic dynamics&quot;, <em>Physical Review E</em>, 75(3), 036222(1-8) (2007) <a href="https://doi.org/10.1103/physreve.75.036222">DOI:10.1103/physreve.75.036222</a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RecurrenceAnalysis.rt_entropy" href="#RecurrenceAnalysis.rt_entropy"><code>RecurrenceAnalysis.rt_entropy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rt_entropy(R[; lmin=2, theiler])</code></pre><p>Calculate the Shannon entropy of the recurrence times contained in the recurrence matrix <code>R</code>, ruling out the lines shorter than <code>lmin</code> (2 by default) and all the points inside the Theiler window (see <a href="#RecurrenceAnalysis.rqa"><code>rqa</code></a> for the default values and usage of the keyword argument <code>theiler</code>).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="RecurrenceAnalysis.rt_average" href="#RecurrenceAnalysis.rt_average"><code>RecurrenceAnalysis.rt_average</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rt_average(R[; lmin=2, theiler])</code></pre><p>Calculate the average of the recurrence times contained in the recurrence matrix <code>R</code>, ruling out the lines shorter than <code>lmin</code> (2 by default) and all the points inside the Theiler window (see <a href="#RecurrenceAnalysis.rqa"><code>rqa</code></a> for the default values and usage of the keyword argument <code>theiler</code>).</p></div></section></article><h2 id="Keyword-table"><a class="docs-heading-anchor" href="#Keyword-table">Keyword table</a><a id="Keyword-table-1"></a><a class="docs-heading-anchor-permalink" href="#Keyword-table" title="Permalink"></a></h2><p>Since most of the above functions can be fined tuned with keyword arguments, here is a table summarizing them that could be of use:</p><table><tr><th style="text-align: right">Argument</th><th style="text-align: right">Default</th><th style="text-align: right">Functions</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>theiler</code></td><td style="text-align: right">0 for <code>CrossRecurrenceMatrix</code>, 1 otherwise.</td><td style="text-align: right"><code>recurrencerate</code>&lt;br/&gt;<code>determinism</code>&lt;br/&gt;<code>*_average</code>&lt;br/&gt;<code>*_max</code>&lt;br/&gt;<code>*_entropy</code>&lt;br/&gt;<code>divergence</code>&lt;br/&gt;<code>trend</code>&lt;br/&gt;<code>laminarity</code>&lt;br/&gt;<code>trappingtime</code>&lt;br/&gt; <code>meanrecurrencetime</code>&lt;br/&gt;<code>nmprt</code></td><td style="text-align: right">Theiler window: number of diagonals around the LOI <strong>excluded</strong> from the analysis. The value <code>0</code> means that the LOI is <em>included</em> in the analysis. Use <code>1</code> to exclude the LOI.</td></tr><tr><td style="text-align: right"><code>lmin</code></td><td style="text-align: right">2</td><td style="text-align: right"><code>determinism</code>&lt;br/&gt;<code>*_average</code>&lt;br/&gt;<code>*_max</code>&lt;br/&gt;<code>*_entropy</code>&lt;br/&gt;<code>divergence</code>&lt;br/&gt;<code>laminarity</code>&lt;br/&gt;<code>trappingtime</code>&lt;br/&gt; <code>meanrecurrencetime</code>&lt;br/&gt;<code>nmprt</code></td><td style="text-align: right">Minimum length of the recurrent structures (diagonal or vertical) considered in the analysis.</td></tr><tr><td style="text-align: right"><code>border</code></td><td style="text-align: right">10</td><td style="text-align: right"><code>trend</code></td><td style="text-align: right">Number of diagonals excluded from the analysis near the border of the matrix.</td></tr></table><h2 id="Recurrence-Structures-Histograms"><a class="docs-heading-anchor" href="#Recurrence-Structures-Histograms">Recurrence Structures Histograms</a><a id="Recurrence-Structures-Histograms-1"></a><a class="docs-heading-anchor-permalink" href="#Recurrence-Structures-Histograms" title="Permalink"></a></h2><p>The functions that we list in this page internally compute histograms of some recurrence structures, like e.g. the vertical lengths. You can access these values directly with the following function:</p><article class="docstring"><header><a class="docstring-binding" id="RecurrenceAnalysis.recurrencestructures" href="#RecurrenceAnalysis.recurrencestructures"><code>RecurrenceAnalysis.recurrencestructures</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">recurrencestructures(x::AbstractRecurrenceMatrix;
                         diagonal=true,
                         vertical=true,
                         recurrencetimes=true,
                         kwargs...)</code></pre><p>Return a dictionary with the histograms of the recurrence structures contained in the recurrence matrix <code>x</code>, with the keys <code>&quot;diagonal&quot;</code>, <code>&quot;vertical&quot;</code> or <code>&quot;recurrencetimes&quot;</code>, depending on what keyword arguments are given as <code>true</code>.</p><p><strong>Description</strong></p><p>Each item of the dictionary is a vector of integers, such that the <code>i</code>-th element of the vector is the number of lines of length <code>i</code> contained in <code>x</code>.</p><ul><li><code>&quot;diagonal&quot;</code> counts the diagonal lines, i.e. the recurrent trajectories.</li><li><code>&quot;vertical&quot;</code> counts the vertical lines, i.e. the laminar states.</li><li><code>&quot;recurrencetimes&quot;</code> counts the vertical distances between recurrent states,   i.e. the recurrence times.</li></ul><p>All the points of the matrix are counted by default. The keyword argument <code>theiler</code> can be passed to rule out the lines around the main diagonal. See the arguments of the function <a href="#RecurrenceAnalysis.rqa"><code>rqa</code></a> for further details.</p><p>&quot;Empty&quot; histograms are represented always as <code>[0]</code>.</p><p><em>Notice</em>: There is not a unique operational definition of &quot;recurrence times&quot;. In the analysis of recurrence plots, usually the  &quot;second type&quot; of recurrence times as defined by Gao and Cai [1] are considered, i.e. the distance between consecutive (but separated) recurrent structures in the vertical direction of the matrix. But that distance is not uniquely defined when the vertical recurrent structures are longer than one point. The recurrence times calculated here are the distance between the midpoints of consecutive lines, which is a balanced estimator of the Poincaré recurrence times [2].</p><p><strong>References</strong></p><p>[1] J. Gao &amp; H. Cai. &quot;On the structures and quantification of recurrence plots&quot;. <a href="https://www.sciencedirect.com/science/article/pii/S0375960100003042?via%3Dihub"><em>Physics Letters A</em>, 270(1-2), 75–87 (2000)</a>.</p><p>[2] N. Marwan &amp; C.L. Webber, &quot;Mathematical and computational foundations of recurrence quantifications&quot;, in: Webber, C.L. &amp; N. Marwan (eds.), <em>Recurrence Quantification Analysis. Theory and Best Practices</em>, Springer, pp. 3-43 (2015).</p></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../rplots/">« Recurrence Plots</a><a class="docs-footer-nextpage" href="../windowed/">Windowed RQA »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 19 January 2021 16:30">Tuesday 19 January 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
