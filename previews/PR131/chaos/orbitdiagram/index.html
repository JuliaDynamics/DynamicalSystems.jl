<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Orbit Diagrams &amp; PSOS · DynamicalSystems.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/logo.ico" rel="icon" type="image/x-icon"/><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="DynamicalSystems.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">DynamicalSystems.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../../contents/">Contents</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Dynamical systems</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../ds/general/">Dynamical System Definition</a></li><li><a class="tocitem" href="../../ds/predefined/">Predefined Dynamical Systems</a></li><li><a class="tocitem" href="../../embedding/dataset/">Numerical Data</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Entropies</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../entropies/api/">Entropies &amp; Probabilities</a></li><li><a class="tocitem" href="../../entropies/estimators/">Probabilities Estimators</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">DelayEmbeddings</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../embedding/reconstruction/">Delay Coordinates Embedding</a></li><li><a class="tocitem" href="../../embedding/traditional/">Traditional Optimal Embedding</a></li><li><a class="tocitem" href="../../embedding/unified/">Unified Optimal Embedding</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox" checked/><label class="tocitem" for="menuitem-6"><span class="docs-label">ChaosTools</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Orbit Diagrams &amp; PSOS</a><ul class="internal"><li><a class="tocitem" href="#Orbit-Diagrams-of-Maps"><span>Orbit Diagrams of Maps</span></a></li><li><a class="tocitem" href="#Poincaré-Surface-of-Section"><span>Poincaré Surface of Section</span></a></li><li><a class="tocitem" href="#Producing-Orbit-Diagrams-for-Flows"><span>Producing Orbit Diagrams for Flows</span></a></li></ul></li><li><a class="tocitem" href="../lyapunovs/">Lyapunov Exponents</a></li><li><a class="tocitem" href="../chaos_detection/">Detecting &amp; Categorizing Chaos</a></li><li><a class="tocitem" href="../fractaldim/">Fractal Dimension</a></li><li><a class="tocitem" href="../nlts/">Nonlinear Timeseries Analysis</a></li><li><a class="tocitem" href="../periodicity/">Periodicity &amp; Ergodicity</a></li><li><a class="tocitem" href="../choosing/">Choosing a solver</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">RecurrenceAnalysis</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../rqa/rplots/">Recurrence Plots</a></li><li><a class="tocitem" href="../../rqa/quantification/">Recurrence Quantification Analysis</a></li><li><a class="tocitem" href="../../rqa/windowed/">Windowed RQA</a></li><li><a class="tocitem" href="../../rqa/networks/">Recurrence Network Analysis</a></li></ul></li><li><a class="tocitem" href="../../advanced/">Advanced Documentation</a></li><li><a class="tocitem" href="../../contributors_guide/">Contributor Guide</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">ChaosTools</a></li><li class="is-active"><a href>Orbit Diagrams &amp; PSOS</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Orbit Diagrams &amp; PSOS</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDynamics/DynamicalSystems.jl/blob/master/docs/src/chaos/orbitdiagram.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Orbit-Diagrams-and-PSOS"><a class="docs-heading-anchor" href="#Orbit-Diagrams-and-PSOS">Orbit Diagrams &amp; PSOS</a><a id="Orbit-Diagrams-and-PSOS-1"></a><a class="docs-heading-anchor-permalink" href="#Orbit-Diagrams-and-PSOS" title="Permalink"></a></h1><h2 id="Orbit-Diagrams-of-Maps"><a class="docs-heading-anchor" href="#Orbit-Diagrams-of-Maps">Orbit Diagrams of Maps</a><a id="Orbit-Diagrams-of-Maps-1"></a><a class="docs-heading-anchor-permalink" href="#Orbit-Diagrams-of-Maps" title="Permalink"></a></h2><p>An orbit diagram (also called bifurcation diagram) is a way to visualize the asymptotic behavior of a map, when a parameter of the system is changed</p><article class="docstring"><header><a class="docstring-binding" id="ChaosTools.orbitdiagram" href="#ChaosTools.orbitdiagram"><code>ChaosTools.orbitdiagram</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">orbitdiagram(ds::DiscreteDynamicalSystem, i, p_index, pvalues; kwargs...)</code></pre><p>Compute the orbit diagram (also called bifurcation diagram) of the given system, saving the <code>i</code> variable(s) for parameter values <code>pvalues</code>. The <code>p_index</code> specifies which parameter of the equations of motion is to be changed.</p><p><code>i</code> can be <code>Int</code> or <code>AbstractVector{Int}</code>. If <code>i</code> is <code>Int</code>, returns a vector of vectors. Else it returns vectors of vectors of vectors. Each entry are the points at each parameter value.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>Ttr::Int = 1000</code> : Transient steps; each orbit is evolved for <code>Ttr</code> first before saving output.</li><li><code>n::Int = 100</code> : Amount of points to save for each initial condition.</li><li><code>dt = 1</code> : Stepping time. Changing this will give you the orbit diagram of the <code>dt</code> order map.</li><li><code>u0 = nothing</code> : Specify an initial state. If <code>nothing</code>, the previous state after each parameter is used to seed the new initial condition at the new parameter (with the very first state being the system&#39;s state). This makes convergence to the attractor faster, necessitating smaller <code>Ttr</code>. Otherwise <code>u0</code> can be a standard state, or a vector of states, so that a specific state is used for each parameter.</li><li><code>ulims = (-Inf, Inf)</code> : only record system states within <code>ulims</code> (only valid if <code>i isa Int</code>).</li></ul><p>See also <a href="#ChaosTools.poincaresos"><code>poincaresos</code></a> and <a href="#ChaosTools.produce_orbitdiagram"><code>produce_orbitdiagram</code></a>.</p></div></section></article><hr/><p>For example, let&#39;s compute the famous orbit diagram of the logistic map:</p><pre><code class="language-julia">using DynamicalSystems
using PyPlot

ds = Systems.logistic()
i = 1
pvalues = 3:0.001:4
ics = [rand() for m in 1:10]
n = 2000
Ttr = 2000
p_index = 1
output = orbitdiagram(ds, i, p_index, pvalues; n = n, Ttr = Ttr)

L = length(pvalues)
x = Vector{Float64}(undef, n*L)
y = copy(x)
for j in 1:L
    x[(1 + (j-1)*n):j*n] .= pvalues[j]
    y[(1 + (j-1)*n):j*n] .= output[j]
end

figure()
PyPlot.title(&quot;total points: $(L*n)&quot;)
plot(x, y, ls = &quot;None&quot;, ms = 0.5, color = &quot;black&quot;, marker = &quot;o&quot;, alpha = 0.05)
xlim(pvalues[1], pvalues[end]); ylim(0,1)
xlabel(&quot;\$r\$&quot;); ylabel(&quot;\$x\$&quot;)
tight_layout()</code></pre><p><img src="../logostic_od.png" alt/></p><p>Notice that if you are using <code>PyPlot</code>, the plotting process will be slow, since it is slow at plotting big numbers of points.</p><p>The function is not limited to 1D maps, and can be applied just as well to any discrete system.</p><h2 id="Poincaré-Surface-of-Section"><a class="docs-heading-anchor" href="#Poincaré-Surface-of-Section">Poincaré Surface of Section</a><a id="Poincaré-Surface-of-Section-1"></a><a class="docs-heading-anchor-permalink" href="#Poincaré-Surface-of-Section" title="Permalink"></a></h2><p>Also called <a href="https://en.wikipedia.org/wiki/Poincar%C3%A9_map">Poincaré map</a> is a technique to reduce a continuous system into a discrete map with 1 less dimension. We are doing this using the function:</p><article class="docstring"><header><a class="docstring-binding" id="ChaosTools.poincaresos" href="#ChaosTools.poincaresos"><code>ChaosTools.poincaresos</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">poincaresos(ds::ContinuousDynamicalSystem, plane, tfinal = 1000.0; kwargs...)</code></pre><p>Calculate the Poincaré surface of section (also called Poincaré map)<sup class="footnote-reference"><a id="citeref-Tabor1989" href="#footnote-Tabor1989">[Tabor1989]</a></sup> of the given system with the given <code>plane</code>. The system is evolved for total time of <code>tfinal</code>. Return a <a href="../../embedding/dataset/#DelayEmbeddings.Dataset"><code>Dataset</code></a> of the points that are on the surface of section.</p><p>If the state of the system is <span>$\mathbf{u} = (u_1, \ldots, u_D)$</span> then the equation defining a hyperplane is</p><p class="math-container">\[a_1u_1 + \dots + a_Du_D = \mathbf{a}\cdot\mathbf{u}=b\]</p><p>where <span>$\mathbf{a}, b$</span> are the parameters of the hyperplane.</p><p>In code, <code>plane</code> can be either:</p><ul><li>A <code>Tuple{Int, &lt;: Number}</code>, like <code>(j, r)</code> : the plane is defined as when the <code>j</code> variable of the system equals the value <code>r</code>.</li><li>A vector of length <code>D+1</code>. The first <code>D</code> elements of the vector correspond to <span>$\mathbf{a}$</span> while the last element is <span>$b$</span>.</li></ul><p>This function uses <code>ds</code> and higher order interpolation from DifferentialEquations.jl to create a high accuracy estimate of the section. See also <a href="#ChaosTools.produce_orbitdiagram"><code>produce_orbitdiagram</code></a>.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>direction = -1</code> : Only crossings with <code>sign(direction)</code> are considered to belong to the surface of section. Positive direction means going from less than <span>$b$</span> to greater than <span>$b$</span>.</li><li><code>idxs = 1:dimension(ds)</code> : Optionally you can choose which variables to save. Defaults to the entire state.</li><li><code>Ttr = 0.0</code> : Transient time to evolve the system before starting to compute the PSOS.</li><li><code>u0 = get_state(ds)</code> : Specify an initial state.</li><li><code>warning = true</code> : Throw a warning if the Poincaré section was empty.</li><li><code>rootkw = (xrtol = 1e-6, atol = 1e-6)</code> : A <code>NamedTuple</code> of keyword arguments passed to <code>find_zero</code> from <a href="https://github.com/JuliaMath/Roots.jl">Roots.jl</a>.</li><li><code>diffeq...</code> : All other extra keyword arguments are propagated into <code>init</code> of DifferentialEquations.jl. See <a href="../../ds/general/#DynamicalSystemsBase.trajectory"><code>trajectory</code></a> for examples.</li></ul><p><strong>Performance Notes</strong></p><p>This function uses a standard <a href="../../advanced/#DynamicalSystemsBase.integrator"><code>integrator</code></a>. For loops over initial conditions and/or parameters you should use the low level method that accepts an integrator and <code>reinit!</code> to new initial conditions. See the &quot;advanced documentation&quot; for more.</p><p>The low level call signature is:</p><pre><code class="language-julia">poincaresos(integ, planecrossing, tfinal, Ttr, idxs, rootkw)</code></pre><p>where</p><pre><code class="language-julia">planecrossing = PlaneCrossing(plane, direction &gt; 0)</code></pre><p>and <code>idxs</code> must be <code>Int</code> or <code>SVector{Int}</code>.</p></div></section><section><div><pre><code class="language-none">poincaresos(A::Dataset, plane; kwargs...)</code></pre><p>Calculate the Poincaré surface of section of the given dataset with the given <code>plane</code> by performing linear interpolation betweeen points that sandwich the hyperplane.</p><p>Argument <code>plane</code> and keywords <code>direction, warning, idxs</code> are the same as above.</p></div></section></article><hr/><p>Here is an example of the <a href="https://en.wikipedia.org/wiki/H%C3%A9non%E2%80%93Heiles_system">Henon-Heiles</a> system showing the mixed nature of the phase space</p><pre><code class="language-julia">using DynamicalSystems, PyPlot

hh = Systems.henonheiles()

plane = (1, 0.0)
u0s = [[0.0, -0.25, 0.42081, 0.0],
[0.0, -0.31596, 0.354461, 0.0591255],
[0.0, 0.1, 0.5, 0.0],
[0.0, -0.0910355, 0.459522, -0.173339],
[0.0, -0.205144, 0.449328, -0.0162098]]

figure()
for u0 in u0s
    psos = poincaresos(hh, plane, 20000.0; u0 = u0)
    scatter(psos[:, 2], psos[:, 4], s = 2.0)
end
xlabel(&quot;\$q_2\$&quot;); ylabel(&quot;\$p_2\$&quot;)</code></pre><p><img src="../hhpsos.png" alt/></p><p>Here the surface of section was the (hyper-) plane that <span>$q_1 = 0$</span>. Some chaotic and regular orbits can be seen in the plot. You can tell the regular orbits apart because they look like a single connected curve. This is the result of cutting a 2-torus by a plane!</p><hr/><p>Finally here is one more example with a more complex hyperplane:</p><pre><code class="language-julia">gis = Systems.gissinger([2.32865, 2.02514, 1.98312])

# Define appropriate hyperplane for gissinger system
const ν = 0.1
const Γ = 0.9 # default parameters of the system

# I want hyperperplane defined by these two points:
Np(μ) = SVector{3}(sqrt(ν + Γ*sqrt(ν/μ)), -sqrt(μ + Γ*sqrt(μ/ν)), -sqrt(μ*ν))
Nm(μ) = SVector{3}(-sqrt(ν + Γ*sqrt(ν/μ)), sqrt(μ + Γ*sqrt(μ/ν)), -sqrt(μ*ν))

# Create hyperplane passing through Np, Nm and 0:
using LinearAlgebra
gis_plane(μ) = [cross(Np(μ), Nm(μ))..., 0]

μ = 0.119
set_parameter!(gis, 1, μ)
figure(figsize = (8,6))
psos = poincaresos(gis, gis_plane(μ), 10000.0, Ttr = 200.0,)
plot3D(columns(psos)..., marker = &quot;o&quot;, ls = &quot;None&quot;, ms = 2.0);
xlabel(&quot;Q&quot;); ylabel(&quot;D&quot;); zlabel(&quot;V&quot;);</code></pre><p><img src="../gispsos.png" alt/></p><h3 id="Stroboscopic-Map"><a class="docs-heading-anchor" href="#Stroboscopic-Map">Stroboscopic Map</a><a id="Stroboscopic-Map-1"></a><a class="docs-heading-anchor-permalink" href="#Stroboscopic-Map" title="Permalink"></a></h3><p>A special case of a PSOS is a stroboscopic map, which is defined for non-autonomous systems with periodic time dependence, like e.g. the <a href="../../ds/predefined/#DynamicalSystemsBase.Systems.duffing"><code>Systems.duffing</code></a> oscillator.</p><p>A &quot;cut&quot; through the phase-space can be produced at every period <span>$T = 2\pi/\omega$</span>. There is no reason to use <code>poincaresos</code> for this though, because you can simply use <a href="../../ds/general/#DynamicalSystemsBase.trajectory"><code>trajectory</code></a> and get the solution with a certain time sampling rate. For example, this piece of code:</p><pre><code class="language-julia">using DynamicalSystems, Plots

ds = Systems.duffing(β = -1, ω = 1, f = 0.3) # non-autonomous chaotic system

frames=120
a = trajectory(ds, 100000.0, dt = 2π/frames, Ttr=20π) # every period T = 2π/ω

orbit_length = div(size(a)[1], frames)
a = Matrix(a)

@gif for i in 1:frames
    orbit_points = i:frames:(orbit_length*frames)
    scatter(a[orbit_points, 1], a[orbit_points, 2], markersize=1, html_output_format=:png,
        leg=false, framestyle=:none, xlims=extrema(a[:,1]), ylims=extrema(a[:,2]))
end</code></pre><p>Produces this nice animation:</p><p><img src="https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/chaos/Duffing_stroboscopic_plot.gif?raw=true" alt/></p><h2 id="Producing-Orbit-Diagrams-for-Flows"><a class="docs-heading-anchor" href="#Producing-Orbit-Diagrams-for-Flows">Producing Orbit Diagrams for Flows</a><a id="Producing-Orbit-Diagrams-for-Flows-1"></a><a class="docs-heading-anchor-permalink" href="#Producing-Orbit-Diagrams-for-Flows" title="Permalink"></a></h2><p>The <a href="#ChaosTools.orbitdiagram"><code>orbitdiagram</code></a> does not make much sense for continuous systems, besides the trivial case where the system is at a fixed point. In order for <a href="#ChaosTools.orbitdiagram"><code>orbitdiagram</code></a> to have meaning one must have a map.</p><p>If only there was a way to turn a continuous system into a map... <strong>OH WAIT!</strong> That is what <a href="#ChaosTools.poincaresos"><code>poincaresos</code></a> does! By performing successive surfaces of section at different parameter values, one can indeed &quot;produce&quot; an orbit diagram for a flow.</p><p>We have bundled this process in the following function:</p><article class="docstring"><header><a class="docstring-binding" id="ChaosTools.produce_orbitdiagram" href="#ChaosTools.produce_orbitdiagram"><code>ChaosTools.produce_orbitdiagram</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">produce_orbitdiagram(ds::ContinuousDynamicalSystem, plane, i::Int,
                     p_index, pvalues; kwargs...)</code></pre><p>Produce an orbit diagram (also called bifurcation diagram) for the <code>i</code> variable(s) of the given continuous system by computing Poincaré surfaces of section using <code>plane</code> for the given parameter values (see <a href="#ChaosTools.poincaresos"><code>poincaresos</code></a>).</p><p><code>i</code> can be <code>Int</code> or <code>AbstractVector{Int}</code>. If <code>i</code> is <code>Int</code>, returns a vector of vectors. Else it returns a vector of vectors of vectors. Each entry are the points at each parameter value.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>printparams::Bool = false</code> : Whether to print the parameter used during computation in order to keep track of running time.</li><li><code>direction, warning, Ttr, rootkw, diffeq...</code> : Propagated into <a href="#ChaosTools.poincaresos"><code>poincaresos</code></a>.</li><li><code>u0 = nothing</code> : Specify an initial state. If <code>nothing</code>, the previous state after each parameter is used to seed the new initial condition at the new parameter (with the very first state being the system&#39;s state). This makes convergence to the attractor faster, necessitating smaller <code>Ttr</code>. Otherwise <code>u0</code> can be a standard state, or a vector of states, so that a specific state is used for each parameter.</li></ul><p><strong>Description</strong></p><p>For each parameter, a PSOS reduces the system from a flow to a map. This then allows the formal computation of an &quot;orbit diagram&quot; for the <code>i</code> variable of the system, just like it is done in <a href="#ChaosTools.orbitdiagram"><code>orbitdiagram</code></a>.</p><p>The parameter change is done as <code>p[p_index] = value</code> taking values from <code>pvalues</code> and thus you must use a parameter container that supports this (either <code>Array</code>, <code>LMArray</code>, dictionary or other).</p><p>See also <a href="#ChaosTools.poincaresos"><code>poincaresos</code></a>, <a href="#ChaosTools.orbitdiagram"><code>orbitdiagram</code></a>.</p></div></section></article><hr/><p>For example, we will calculate the orbit diagram of the Shinriki oscillator, a continuous system that undergoes a period doubling route to chaos, much like the logistic map!</p><pre><code class="language-julia">ds = Systems.shinriki([-2, 0, 0.2])

pvalues = range(19, stop = 22, length = 401)
i = 1
plane = (2, 0.0)
tf = 200.0
p_index = 1

output = produce_orbitdiagram(ds, plane, i, p_index, pvalues;
                              tfinal = tf, Ttr = 200.0)

figure()
for (j, p) in enumerate(pvalues)
    plot(fill(p, length(output[j])), output[j], lw = 0,
    marker = &quot;o&quot;, ms = 0.2, color = &quot;black&quot;)
end
xlabel(&quot;\$R_1\$&quot;); ylabel(&quot;\$V_1\$&quot;)
tight_layout()</code></pre><p><img src="../shinriki.png" alt/></p><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-Tabor1989"><a class="tag is-link" href="#citeref-Tabor1989">Tabor1989</a>M. Tabor, <em>Chaos and Integrability in Nonlinear Dynamics: An Introduction</em>, §4.1, in pp. 118-126, New York: Wiley (1989)</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../embedding/unified/">« Unified Optimal Embedding</a><a class="docs-footer-nextpage" href="../lyapunovs/">Lyapunov Exponents »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 19 January 2021 16:30">Tuesday 19 January 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
