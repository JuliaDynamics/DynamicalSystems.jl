var documenterSearchIndex = {"docs":
[{"location":"contributors_guide/#Contributor-Guide","page":"Contributor Guide","title":"Contributor Guide","text":"","category":"section"},{"location":"contributors_guide/","page":"Contributor Guide","title":"Contributor Guide","text":"TL;DR: To contribute via pull requests you can check issues that have labels \"wanted feature\" or \"good first issue\" in the GitHub repositories of the subpackages of DynamicalSystems.jl","category":"page"},{"location":"contributors_guide/","page":"Contributor Guide","title":"Contributor Guide","text":"","category":"page"},{"location":"contributors_guide/","page":"Contributor Guide","title":"Contributor Guide","text":"The ultimate goal for DynamicalSystems.jl is to be a useful library for scientists working on nonlinear dynamics and to make nonlinear dynamics accessible and reproducible.","category":"page"},{"location":"contributors_guide/","page":"Contributor Guide","title":"Contributor Guide","text":"Of course, for such an ambitious goal to be achieved, many of us should try to work together to improve the library! If you want to help the cause, there are many ways to contribute to the DynamicalSystems.jl library:","category":"page"},{"location":"contributors_guide/","page":"Contributor Guide","title":"Contributor Guide","text":"Just use it. If you encountered unexpected behavior simply report it either on our gitter chatroom or using the DynamicalSystems.jl Issues page.\nSuggest methods that you think should be included in our library. This should be done by opening a new issue that describes the method, gives references to papers using the method and also justifies why the method should be included.\nContribute code by solving issues. The easiest issues to tackle are the ones with label \"good first issue\".\nContribute code by implementing new methods! That is the most awesome way to contribute! The individual packages that compose DynamicalSystems.jl have plenty of issues with the tag \"wanted feature\", which can get you started on a big contribution!\nContribute code by defining a new pre-defined dynamical system that you found useful.","category":"page"},{"location":"contributors_guide/#Contributing-Code","page":"Contributor Guide","title":"Contributing Code","text":"","category":"section"},{"location":"contributors_guide/","page":"Contributor Guide","title":"Contributor Guide","text":"When contributing code, you should keep these things in mind:","category":"page"},{"location":"contributors_guide/","page":"Contributor Guide","title":"Contributor Guide","text":"In general, the speed of the implementation is important, but not as important as the clarity of the implementation. One of cornerstones of all of DynamicalSystems.jl is to have clear and readable source code. Fortunately, Julia allows you to have perfectly readable code but also super fast ;) If necessary add comments to the code, so that somebody that knows the method, can also understand the code immediately.\nTry to design general, extendable functions instead of unnecessarily specialized to the case at hand.\nFor the documentation strings of new methods and systems please follow the convention of the documentation strings of DynamicalSystems.jl. Specifically, the first section should describe the function in a couple of sentences, its positional arguments and its return value. The next section ## Keyword Arguments describes the keywords. The next section ## Description describes the algorithm in detail if need be. Lastly, papers that are relevant to the method must be cited. Have a look at the documentation strings of lyapunov and lyapunovspectrum to get an idea.","category":"page"},{"location":"contributors_guide/#Documentation-string-style","page":"Contributor Guide","title":"Documentation string style","text":"","category":"section"},{"location":"contributors_guide/","page":"Contributor Guide","title":"Contributor Guide","text":"Documentation strings are the most important thing in your pull request/code. The number 1 priority of DynamicalSystems.jl is highest possible quality of documentation and utmost transparency, and the best way to achieve this is with good documentation strings. In DynamicalSystems.jl we recommend that documentation strings are structured in the following way (and this is also the recommendation we give in the Good Scientific Code Workshop).","category":"page"},{"location":"contributors_guide/","page":"Contributor Guide","title":"Contributor Guide","text":"Clear call signature in code syntax, including expected input types if necessary. The call signature should ONLY include only the most important information, not list out in detail every keyword!\nBrief summary of the function\n[Optional] Return value and type if not obvious\n[Optional] References to related functions if sensible\n[Optional] Keyword arguments list if the function has some\n[Optional] Detailed discussion of functionality if function behavior is scientifically involved\n[Optional] Citations to relevant scientific papers!","category":"page"},{"location":"contributors_guide/","page":"Contributor Guide","title":"Contributor Guide","text":"The syntax of the documentation strings follows Documenter.jl protocol. Please see the documentation string of the lyapunov function and use the same structure.","category":"page"},{"location":"contents/#contents","page":"Contents","title":"Contents","text":"","category":"section"},{"location":"contents/","page":"Contents","title":"Contents","text":"When you do using DynamicalSystems in your Julia session, the module re-exports and brings into scope all packages listed in this session. Of course, you could be using these packages directly instead of adding DynamicalSystems. However, doing using DynamicalSystems provides the environment all these packages were designed to work together in, and so we recommend to simply install DynamicalSystems and use that.","category":"page"},{"location":"contents/","page":"Contents","title":"Contents","text":"Re-exported packages:","category":"page"},{"location":"contents/","page":"Contents","title":"Contents","text":"Core","category":"page"},{"location":"contents/","page":"Contents","title":"Contents","text":"StateSpaceSets\nDynamicalSystemsBase","category":"page"},{"location":"contents/","page":"Contents","title":"Contents","text":"For observed/measured data","category":"page"},{"location":"contents/","page":"Contents","title":"Contents","text":"ComplexityMeasures\nRecurrenceAnalysis\nDelayEmbeddings\nFractalDimensions\nTimeseriesSurrogates","category":"page"},{"location":"contents/","page":"Contents","title":"Contents","text":"For dynamical system instances","category":"page"},{"location":"contents/","page":"Contents","title":"Contents","text":"PredefinedDynamicalSystems\nChaosTools\nAttractors","category":"page"},{"location":"contents/#Core","page":"Contents","title":"Core","text":"","category":"section"},{"location":"contents/","page":"Contents","title":"Contents","text":"StateSpaceSets\r\nDynamicalSystemsBase","category":"page"},{"location":"contents/#StateSpaceSets.StateSpaceSets","page":"Contents","title":"StateSpaceSets.StateSpaceSets","text":"StateSpaceSets.jl\n\n(Image: ) (Image: ) (Image: ) (Image: CI) (Image: codecov) (Image: Package Downloads)\n\nA Julia package that provides functionality for state space sets. These are collections of points of fixed, and known by type, size (called dimension). It is used in several projects in the JuliaDynamics organization, such as DynamicalSystems.jl or CausalityTools.jl.\n\nThe main export of StateSpaceSets is the concrete type StateSpaceSet. The package also provides functionality for distances, neighbor searches, sampling, and normalization.\n\nTo install it you may run import Pkg; Pkg.add(\"StateSpaceSets\"), however, there is no real reason to install this package directly as it is re-exported by all downstream packages that use it.\n\npreviously StateSpaceSets.jl was part of DelayEmbeddings.jl\n\n\n\n\n\n","category":"module"},{"location":"contents/#DynamicalSystemsBase.DynamicalSystemsBase","page":"Contents","title":"DynamicalSystemsBase.DynamicalSystemsBase","text":"DynamicalSystemsBase.jl\n\n(Image: ) (Image: ) (Image: ) (Image: CI) (Image: codecov) (Image: Package Downloads)\n\nA Julia package that defines the DynamicalSystem interface and many concrete implementations used in the DynamicalSystems.jl ecosystem.\n\nTo install it, run import Pkg; Pkg.add(\"DynamicalSystemsBase\"). Typically, you do not want to use DynamicalSystemsBase directly, as downstream analysis packages re-export it.\n\nAll further information is provided in the documentation, which you can either find online or build locally by running the docs/make.jl file.\n\n\n\n\n\n","category":"module"},{"location":"contents/#For-observed/measured-data","page":"Contents","title":"For observed/measured data","text":"","category":"section"},{"location":"contents/","page":"Contents","title":"Contents","text":"ComplexityMeasures\r\nRecurrenceAnalysis\r\nDelayEmbeddings\r\nFractalDimensions\r\nTimeseriesSurrogates","category":"page"},{"location":"contents/#ComplexityMeasures.ComplexityMeasures","page":"Contents","title":"ComplexityMeasures.ComplexityMeasures","text":"ComplexityMeasures.jl\n\n(Image: Docs) (Image: CI) (Image: codecov) (Image: Package Downloads) (Image: Package Downloads) (Image: DOI)\n\nA Julia package that provides estimators for probabilities, entropies, and other complexity measures, in the context of nonlinear dynamics, nonlinear timeseries analysis, and complex systems. It can be used as a standalone package, or as part of other projects in the JuliaDynamics organization, such as DynamicalSystems.jl or CausalityTools.jl.\n\nTo install it, run import Pkg; Pkg.add(\"ComplexityMeasures\").\n\nAll further information is provided in the documentation, which you can either find online or build locally by running the docs/make.jl file.\n\nPreviously, this package was called Entropies.jl.\n\n\n\n\n\n","category":"module"},{"location":"contents/#RecurrenceAnalysis.RecurrenceAnalysis","page":"Contents","title":"RecurrenceAnalysis.RecurrenceAnalysis","text":"RecurrenceAnalysis.jl\n\n(Image: ) (Image: ) (Image: CI) (Image: codecov) (Image: Package Downloads)\n\nA Julia module that offers tools for computing Recurrence Plots and exploring them within the framework of Recurrence Quantification Analysis and Recurrence Network Analysis. It can be used as a standalone package, or as part of DynamicalSystems.jl.\n\nTo install it, run import Pkg; Pkg.add(\"RecurrenceAnalysis\").\n\nAll further information is provided in the documentation, which you can either find online or build locally by running the docs/make.jl file.\n\n\n\n\n\n","category":"module"},{"location":"contents/#DelayEmbeddings.DelayEmbeddings","page":"Contents","title":"DelayEmbeddings.DelayEmbeddings","text":"DelayEmbeddings.jl\n\n(Image: ) (Image: ) (Image: ) (Image: CI) (Image: codecov) (Image: Package Downloads)\n\nA Julia package that provides a generic interface for performing delay coordinate embeddings, as well as cutting edge algorithms for creating optimal embeddings given some data. It can be used as a standalone package, or as part of DynamicalSystems.jl.\n\nTo install it, run import Pkg; Pkg.add(\"DelayEmbeddings\").\n\nAll further information is provided in the documentation, which you can either find online or build locally by running the docs/make.jl file.\n\n\n\n\n\n","category":"module"},{"location":"contents/#FractalDimensions.FractalDimensions","page":"Contents","title":"FractalDimensions.FractalDimensions","text":"FractalDimensions.jl\n\n(Image: ) (Image: ) (Image: ) (Image: CI) (Image: codecov) (Image: Package Downloads) (Image: Package Downloads)\n\nA Julia package that estimates various definitions of fractal dimension from data. It can be used as a standalone package, or as part of DynamicalSystems.jl.\n\nTo install it, run import Pkg; Pkg.add(\"FractalDimensions\").\n\nAll further information is provided in the documentation, which you can either find online or build locally by running the docs/make.jl file.\n\nPreviously, this package was part of ChaosTools.jl.\n\nCitation\n\nIf you use this package in a publication, please cite the paper below:\n\n@ARTICLE{FractalDimensions.jl,\n  title     = \"Estimating the fractal dimension: a comparative review and open\n               source implementations\",\n  author    = \"Datseris, George and Kottlarz, Inga and Braun, Anton P and\n               Parlitz, Ulrich\",\n  publisher = \"arXiv\",\n  year      =  2021,\n  doi = {10.48550/ARXIV.2109.05937},\n  url = {https://arxiv.org/abs/2109.05937},\n}\n\n\n\n\n\n","category":"module"},{"location":"contents/#TimeseriesSurrogates.TimeseriesSurrogates","page":"Contents","title":"TimeseriesSurrogates.TimeseriesSurrogates","text":"TimeseriesSurrogates.jl\n\n(Image: ) (Image: ) (Image: ) (Image: CI) (Image: codecov) (Image: Package Downloads)\n\nA Julia module that offers various tools for analysing nonlinear dynamics and chaotic behaviour. It can be used as a standalone package, or as part of DynamicalSystems.jl.\n\nTo install it, run import Pkg; Pkg.add(\"TimeseriesSurrogates\").\n\nAll further information is provided in the documentation, which you can either find online or build locally by running the docs/make.jl file.\n\nCiting\n\nPlease use the following BiBTeX entry, or DOI, to cite TimeseriesSurrogates.jl:\n\nDOI: https://doi.org/10.21105/joss.04414\n\nBiBTeX:\n\n@article{TimeseriesSurrogates.jl,\n    doi = {10.21105/joss.04414},\n    url = {https://doi.org/10.21105/joss.04414},\n    year = {2022},\n    publisher = {The Open Journal},\n    volume = {7},\n    number = {77},\n    pages = {4414},\n    author = {Kristian Agasøster Haaga and George Datseris},\n    title = {TimeseriesSurrogates.jl: a Julia package for generating surrogate data},\n    journal = {Journal of Open Source Software}\n}\n\n\n\n\n\n","category":"module"},{"location":"contents/#For-dynamical-system-instances","page":"Contents","title":"For dynamical system instances","text":"","category":"section"},{"location":"contents/","page":"Contents","title":"Contents","text":"PredefinedDynamicalSystems\r\nChaosTools\r\nAttractors","category":"page"},{"location":"contents/#PredefinedDynamicalSystems.PredefinedDynamicalSystems","page":"Contents","title":"PredefinedDynamicalSystems.PredefinedDynamicalSystems","text":"PredefinedDynamicalSystems.jl\n\n(Image: ) (Image: CI) (Image: Package Downloads)\n\nModule which contains pre-defined dynamical systems that can be used by the DynamicalSystems.jl library. To install it, run import Pkg; Pkg.add(\"PredefinedDynamicalSystems\").\n\nPredefined systems exist as functions that return a DynamicalSystem instance. They are accessed like:\n\nds = PredefinedDynamicalSystems.lorenz(u0; ρ = 32.0)\n\nThe alias Systems is also exported as a deprecation.\n\nThis module is provided purely as a convenience. It does not have any actual tests, and it is not guaranteed to be stable in future versions. It is not recommended to use this module for anything else besides on-the-spot demonstrative examples.\n\nFor some systems, a Jacobian function is also defined. The naming convention for the Jacobian function is \\$(name)_jacob. So, for the above example we have J = Systems.lorenz_jacob.\n\nAll available systems are provided in the documentation, which you can either find online or build locally by running the docs/make.jl file.\n\n\n\n\n\n","category":"module"},{"location":"contents/#ChaosTools.ChaosTools","page":"Contents","title":"ChaosTools.ChaosTools","text":"ChaosTools.jl\n\n(Image: ) (Image: ) (Image: ) (Image: CI) (Image: codecov) (Image: Package Downloads)\n\nA Julia module that offers various tools for analysing nonlinear dynamics and chaotic behaviour. It can be used as a standalone package, or as part of DynamicalSystems.jl.\n\nTo install it, run import Pkg; Pkg.add(\"ChaosTools\").\n\nAll further information is provided in the documentation, which you can either find online or build locally by running the docs/make.jl file.\n\nChaosTools.jl is the jack-of-all-trades package of the DynamicalSystems.jl library: methods that are not extensive enough to be a standalone package are added here. You should see the full DynamicalSystems.jl library for other packages that may contain functionality you are looking for but did not find in ChaosTools.jl.\n\n\n\n\n\n","category":"module"},{"location":"contents/#Attractors.Attractors","page":"Contents","title":"Attractors.Attractors","text":"Attractors.jl\n\n(Image: ) (Image: ) (Image: ) (Image: CI) (Image: codecov) (Image: Package Downloads) (Image: Package Downloads)\n\nA Julia module for finding attractors of dynamical systems, their basins and their boundaries, fractal properties of the boundaries, as well as continuing attractors and their basins across parameters. It can be used as a standalone package, or as part of DynamicalSystems.jl.\n\nTo install it, run import Pkg; Pkg.add(\"Attractors\").\n\nAll further information is provided in the documentation, which you can either find online or build locally by running the docs/make.jl file.\n\nPreviously, Attractors.jl was part of ChaosTools.jl\n\n\n\n\n\n","category":"module"},{"location":"","page":"Introduction","title":"Introduction","text":"DynamicalSystems","category":"page"},{"location":"#DynamicalSystems","page":"Introduction","title":"DynamicalSystems","text":"(Image: DynamicalSystems.jl logo: The Double Pendulum)\n\n(Image: ) (Image: DocBuild) (Image: DOI) (Image: Textbook) (Image: Package Downloads)\n\nDynamicalSystems.jl is an award-winning Julia software library for nonlinear dynamics and nonlinear timeseries analysis. The current repository holds the documentation and exports all packages composing DynamicalSystems.jl.\n\nTo install it, run import Pkg; Pkg.add(\"DynamicalSystems\").\n\nDynamicalSystems.jl is part of JuliaDynamics, an organization dedicated to creating high quality scientific software.\n\nAll further information is provided in the documentation, which you can either find online or build locally by running the docs/make.jl file.\n\n\n\n\n\n","category":"module"},{"location":"","page":"Introduction","title":"Introduction","text":"tip: Star us on GitHub!\nIf you have found this library useful, please consider starring it on GitHub. This gives us an accurate lower bound of the (satisfied) user count.","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Welcome to the documentation of DynamicalSystems.jl!","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The contents page gives a summary of all packages that are part of the library.\nIf you have not used the library before, and would like to get started, then please read the overarching tutorial for the library.\nSee the learning resources below to find out more resources about learning the library and using it in scientific research and/or education.\nThe remaining of this introduction page discusses our goals with the library, how to participate as a user or developer, how to cite, and other relevant information (see the sections of the sidebar on the left).","category":"page"},{"location":"#Latest-news","page":"Introduction","title":"Latest news","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The new major version, v3, of DynamicalSystems.jl has been released! This is a massive release, with a huge amount of new content, and a re-write of many of the fundamentals of the library!","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The full details of this release are too long to describe here, so please read more about it in our changelog!","category":"page"},{"location":"#learning","page":"Introduction","title":"Learning resources","text":"","category":"section"},{"location":"#Textbook-with-DynamicalSystems.jl","page":"Introduction","title":"Textbook with DynamicalSystems.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"We have written an undergraduate level textbook as an introduction to nonlinear dynamics. The text is written in an applied, hands-on manner, while still covering all fundamentals. The book pages are interlaced with real Julia code that uses DynamicalSystems.jl and is published in the Undergraduate Lecture Notes in Physics by Springer Nature:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Nonlinear Dynamics: A concise introduction interlaced with code by G. Datseris & U. Parlitz.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Additional textbooks on nonlinear dynamics worth having a look are:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Chaos in Dynamical Systems - E. Ott\nNonlinear Time series Analysis - H. Kantz & T. Schreiber","category":"page"},{"location":"#Course-on-applied-nonlinear-dynamics-and-complex-systems","page":"Introduction","title":"Course on applied nonlinear dynamics and complex systems","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"We are developing a full course (targeting a graduate or undergraduate semester long course) on applied nonlinear dynamics, nonlinear timeseries analysis, and complex systems, using the packages of JuliaDynamics. DynamicalSystems.jl is part of this course.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The materials of the course are on GitHub: https://github.com/JuliaDynamics/NonlinearDynamicsComplexSystemsCourses","category":"page"},{"location":"#goals","page":"Introduction","title":"Our Goals","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"DynamicalSystems.jl was created with three goals in mind. The first was to fill the missing gap of a high quality and general purpose software for nonlinear dynamics, which can make the field of nonlinear dynamics accessible and reproducible. The second goal was to create a useful library where students and scientists from different fields may come and learn about methods of nonlinear dynamics.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The third goal was to fundamentally change the perception of the role of code in both scientific education as well as research. It is rarely the case that real, runnable code is shown in the classroom, because it is often long and messy. This is especially hurtful for nonlinear dynamics, a field where computer-assisted exploration is critical. And published work in this field fares even worse, with the overwhelming majority of published research not sharing the code used to create the paper. This makes reproducing these papers difficult, while some times straight-out impossible.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"To achieve these goals we made DynamicalSystems.jl so that it is:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Transparent: extra care is taken so that the source code of all functions is clear and easy to follow, while remaining as small and concise as possible.\nIntuitive: a software simple to use and understand makes experimentation easier.\nEasy to extend: this makes contributions more likely, and can motivate researchers to implement their method here, instead of leaving it in a cryptic script stored in some data server, never-to-be-published with the paper.\nReliable: the algorithm implementations are tested extensively.\nWell-documented: all implemented algorithms provide a high-level scientific description of their functionality in their documentation string as well as references to scientific papers.\nGeneral: all algorithms work just as well with any system, whether it is a simple continuous chaotic system, like the Lorenz model, or a high dimensional discrete system like coupled standard maps.\nPerformant: written entirely in Julia, and taking advantage of some of the best packages within the language, DynamicalSystems.jl is really fast.","category":"page"},{"location":"#Citing","page":"Introduction","title":"Citing","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"There is a (small) paper associated with DynamicalSystems.jl. If we have helped you in research that led to a publication, please be kind enough to cite it, using the DOI 10.21105/joss.00598 or the following BiBTeX entry:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@article{Datseris2018,\n  doi = {10.21105/joss.00598},\n  url = {https://doi.org/10.21105/joss.00598},\n  year  = {2018},\n  month = {mar},\n  volume = {3},\n  number = {23},\n  pages = {598},\n  author = {George Datseris},\n  title = {DynamicalSystems.jl: A Julia software library for chaos and nonlinear dynamics},\n  journal = {Journal of Open Source Software}\n}","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"however, we would really appreciate it if you also cited the textbook we wrote that DynamicalSystems.jl accompanies:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@book{DatserisParlitz2022,\n  doi = {10.1007/978-3-030-91032-7},\n  url = {https://doi.org/10.1007/978-3-030-91032-7},\n  year = {2022},\n  publisher = {Springer Nature},\n  author = {George Datseris and Ulrich Parlitz},\n  title     = \"Nonlinear dynamics: A concise introduction interlaced with code\",\n  address   = \"Cham, Switzerland\",\n  language  = \"en\",\n}","category":"page"},{"location":"#Asking-questions","page":"Introduction","title":"Asking questions","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"There are three options for asking questions:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Join the official Julia discourse and ask a question under the category Specific Domains > Modelling & Simulations.\nJoin our channel #dynamics-bridged in the Julia Slack workplace.\nOpen an issue directly on the GitHub page of DynamicalSystems.jl while providing a Minimal Working Example.","category":"page"},{"location":"#Contributing-and-Donating","page":"Introduction","title":"Contributing & Donating","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Be sure to visit the Contributor Guide page, because you can help make this package better without having to write a single line of code! Also, if you find this package helpful please consider staring it on GitHub! This gives us an accurate lower bound of users that this package has already helped!","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Finally, you can donate for the development of DynamicalSystems.jl. You can do that by adding bounties to existing issues on the GitHub repositories (you can open new issues as well). Every issue has an automatic way to create a bounty using Bountysource, see the first comment of each issue.","category":"page"},{"location":"#Issues-with-Bounties","page":"Introduction","title":"Issues with Bounties","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Money that DynamicalSystems.jl obtains from awards, sponsors, or donators are converted into bounties for GitHub issues. The full list of issues that have a bounty is available here.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"By solving these issues you not only contribute to open source, but you also get some pocket money to boot :)","category":"page"},{"location":"#Maintainers-and-Contributors","page":"Introduction","title":"Maintainers and Contributors","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The DynamicalSystems.jl library is maintained by George Datseris, who is also curating and writing this documentation. The software code however is built from the contributions of several individuals. The list is too long to write and constantly update, so the best way to find out these contributions is to visit the GitHub page of each of the subpackages and checkout the \"contributors\" pages there.","category":"page"},{"location":"#Version-numbers","page":"Introduction","title":"Version numbers","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The version of DynamicalSystems by itself is a bit meaningless, because the module does not have any source code, besides re-exporting other modules. For transparency, the packages and versions used to build the documentation you are reading now are:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using CairoMakie, InteractiveDynamics, DynamicalSystems\ninclude(\"../style.jl\")","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using Pkg\nPkg.status([\n    \"DynamicalSystems\",\n    \"StateSpaceSets\", \"DynamicalSystemsBase\", \"RecurrenceAnalysis\", \"FractalDimensions\", \"DelayEmbeddings\", \"ComplexityMeasures\", \"TimeseriesSurrogates\", \"PredefinedDynamicalSystems\", \"Attractors\", \"ChaosTools\"\n    ];\n    mode = PKGMODE_MANIFEST\n)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"warn: Version numbers do not strictly follow SemVer2.0\nBecause of the nature of the DynamicalSystems.jl library, the exported API contains hundreds of algorithm implementations, most of which are independent of each other. Our development approach is that breaking changes to these individual algorithms (due to e.g., better API design or better performance implementations or better default keyword arguments) can be done without incrementing any major version numbers. We increment major version numbers only for breaking changes that have wide impact over most of the DynamicalSystems.jl library.","category":"page"},{"location":"#Other-NLD-relevant-packages","page":"Introduction","title":"Other NLD-relevant packages","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Besides DynamicalSystems.jl, the Julia programming language has a thriving ecosystem with plenty of functionality that is relevant for nonlinear dynamics. We list some useful references below:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"DifferentialEquations.jl - Besides providing solvers for standard ODE systems (infastructure already used in DynamicalSystems.jl), it also has much more features like SDE solvers or uncertainty quantification.\nDiffEqSensitivity.jl - Discrete and continuous local sensitivity analysis, i.e., derivatives of the solutions of ODEs, or functions of the solutions, versus parameters, hosting various forward and adjoint methods as well as methods tailored to chaotic systems.\nGlobalSensitivity.jl Global sensitivity analysis assessing the effect of any input variables over a larger domain on the output.\nBifurcationKit.jl - Featureful toolkit for automated bifurcation analysis.\nNetworkDynamics.jl - Package for easily simulating dynamics on networks and transforming network systems into ODEProblem (that can be made directly into a ContinuousDynamicalSystem).\nAgents.jl for agent based modelling.","category":"page"},{"location":"tutorial/#tutorial","page":"Overarching tutorial","title":"Overarching tutorial for DynamicalSystems.jl","text":"","category":"section"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"This page serves as a short, but to-the-point, introduction to the DynamicalSystems.jl library. It outlines the core components, and how they establish an interface that is used by the rest of the library. It also provides a couple of usage examples to connect the various packages of the library together.","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"Going through this tutorial should take you about 20 minutes.","category":"page"},{"location":"tutorial/#Installation","page":"Overarching tutorial","title":"Installation","text":"","category":"section"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"To install DynamicalSystems.jl, simply do:","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"using Pkg; Pkg.add(\"DynamicalSystems\")","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"As discussed in the contents page, this installs several packages for the Julia language, that are all exported under a common name. To use them, simply do:","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"using DynamicalSystems","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"in your Julia session.","category":"page"},{"location":"tutorial/#Core-components","page":"Overarching tutorial","title":"Core components","text":"","category":"section"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"The individual packages that compose DynamicalSystems interact flawlessly with each other because of the following two components:","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"The StateSpaceSet, which represents numerical data. They can be observed or measured from experiments, sampled trajectories of dynamical systems, or just unordered sets in a state space. A StateSpaceSet is a container of equally-sized points, representing multivariate timeseries or multivariate datasets. Timeseries, which are univariate sets, are represented by the AbstractVector{<:Real} Julia base type.\nThe DynamicalSystem, which is the abstract representation of a dynamical system with a known dynamic evolution rule. DynamicalSystem defines an extendable interface, but typically one uses concrete implementations such as DeterministicIteratedMap or CoupledODEs.","category":"page"},{"location":"tutorial/#Making-dynamical-systems","page":"Overarching tutorial","title":"Making dynamical systems","text":"","category":"section"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"In the majority of cases, to make a dynamical system one needs three things:","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"The dynamic rule f: A Julia function that provides the instructions of how to evolve the dynamical system in time.\nThe state u: An array-like container that contains the variables of the dynamical system and also defines the starting state of the system.\nThe parameters p: An arbitrary container that parameterizes f.","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"For most concrete implementations of DynamicalSystem there are two ways of defining f, u. The distinction is done on whether f is defined as an in-place (iip) function or out-of-place (oop) function.","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"oop : f must be in the form f(u, p, t) -> out   which means that given a state u::SVector{<:Real} and some parameter container   p it returns the output of f as an SVector{<:Real} (static vector).\niip : f must be in the form f!(out, u, p, t)   which means that given a state u::AbstractArray{<:Real} and some parameter container p,   it writes in-place the output of f in out::AbstractArray{<:Real}.   The function must return nothing as a final statement.","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"t stands for current time in both cases. iip is suggested for systems with high dimension and oop for small. The break-even point is between 10 to 100 dimensions but should be benchmarked on a case-by-case basis as it depends on the complexity of f.","category":"page"},{"location":"tutorial/#Example:-Henon-map","page":"Overarching tutorial","title":"Example: Henon map","text":"","category":"section"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"Let's make the Henon map, defined as","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"beginaligned\nx_n+1 = 1 - ax^2_n+y_n \ny_n+1  = bx_n\nendaligned","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"with parameters a = 14 b = 03.","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"First, we define the dynamic rule as a standard Julia function. Since the dynamical system is only two-dimensional, we should use the out-of-place form that returns an SVector with the next state:","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"using DynamicalSystems\n\nfunction henon_rule(u, p, n) # here `n` is \"time\", but we don't use it.\n    x, y = u # system state\n    a, b = p # system parameters\n    xn = 1.0 - a*x^2 + y\n    yn = b*x\n    return SVector(xn, yn)\nend","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"Then, we define initial state and parameters","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"u0 = [0.2, 0.3]\np0 = [1.4, 0.3]","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"Lastly, we give these three to the DeterministicIteratedMap:","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"henon = DeterministicIteratedMap(henon_rule, u0, p0)","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"henon is a DynamicalSystem, of the two core structures of the library. They can evolved interactively, and queried, using the interface defined by DynamicalSystem. The simplest thing you can do with a DynamicalSystem is to get its trajectory:","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"total_time = 10_000\nX, t = trajectory(henon, total_time)","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"X","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"X is a StateSpaceSet, the second of the core structures of the library. We'll see below how, and where, to use a StateSpaceset, but for now let's just do a scatter plot","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"using CairoMakie\nscatter(X[:, 1], X[:, 2])","category":"page"},{"location":"tutorial/#Example:-Lorenz96","page":"Overarching tutorial","title":"Example: Lorenz96","text":"","category":"section"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"Let's also make another dynamical system, the Lorenz96 model:","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"fracdx_idt = (x_i+1-x_i-2)x_i-1 - x_i + F","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"for i in 1 ldots N and N+j=j.","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"Here, instead of a discrete time map we have N coupled ordinary differential equations. However, creating the dynamical system works out just like above, but using CoupledODEs instead of DeterministicIteratedMap.","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"First, we make the dynamic rule function. Since this dynamical system can be arbitrarily high-dimensional, we prefer to use the in-place form for f, overwriting in place the rate of change in a pre-allocated container.","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"function lorenz96_rule(du, u, p, t)\n    F = p[1]; N = length(u)\n    # 3 edge cases\n    du[1] = (u[2] - u[N - 1]) * u[N] - u[1] + F\n    du[2] = (u[3] - u[N]) * u[1] - u[2] + F\n    du[N] = (u[1] - u[N - 2]) * u[N - 1] - u[N] + F\n    # then the general case\n    for n in 3:(N - 1)\n        du[n] = (u[n + 1] - u[n - 2]) * u[n - 1] - u[n] + F\n    end\n    return nothing # always `return nothing` for in-place form!\nend","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"then, like before, we define an initial state and parameters, and initialize the system","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"N = 6\nu0 = range(0.1, 1; length = N)\np0 = [8.0]\nlorenz96 = CoupledODEs(lorenz96_rule, u0, p0)","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"and, again like before, we may obtain a trajectory the same way","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"total_time = 12.5\nsampling_time = 0.02\nY, t = trajectory(lorenz96, total_time; Ttr = 2.2, Δt = sampling_time)\nY","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"We can't scatterplot something 6-dimensional but we can visualize all timeseries","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"fig = Figure()\nax = Axis(fig[1,1]; xlabel = \"time\", ylabel = \"variable\")\nfor var in columns(Y)\n    lines!(ax, t, var)\nend\nfig","category":"page"},{"location":"tutorial/#ODE-solving","page":"Overarching tutorial","title":"ODE solving","text":"","category":"section"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"Continuous time dynamical systems are evolved through DifferentialEquations.jl. When initializing a CoupledODEs you can tune the solver properties to your heart's content using any of the ODE solvers and any of the common solver options. For example:","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"using OrdinaryDiffEq # accessing the ODE solvers\ndiffeq = (alg = Vern9(), abstol = 1e-9, reltol = 1e-9)\nlorenz96_vern = ContinuousDynamicalSystem(lorenz96_rule, u0, p0; diffeq)","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"Y, t = trajectory(lorenz96_vern, total_time; Ttr = 2.2, Δt = sampling_time)\nY[end]","category":"page"},{"location":"tutorial/#Using-dynamical-systems","page":"Overarching tutorial","title":"Using dynamical systems","text":"","category":"section"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"You may use the DynamicalSystem interface to develop algorithms that utilize dynamical systems with a known evolution rule. The two main packages of the library that do this are ChaosTools and Attractors. For example, you may want to compute the Lyapunov spectrum of the Lorenz96 system from above. This is as easy as calling the lyapunovspectrum function with lorenz96","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"steps = 10_000\nlyapunovspectrum(lorenz96, steps)","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"As expected, there is at least one positive Lyapunov exponent (before the system is chaotic) and at least one zero Lyapunov exponent, because the system is continuous time.","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"Alternatively, you may want to estimate the basins of attraction of a multistable dynamical system. The Henon map is \"multistable\" in the sense that some initial conditions diverge to infinity, and some others converge to a chaotic attractor. Computing these basins of attraction is simple with Attractors, and would work as follows:","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"# define a state space grid to compute the basins on:\nxg = yg = range(-2, 2; length = 201)\n# find attractors using recurrences in state space:\nmapper = AttractorsViaRecurrences(henon, (xg, yg); sparse = false)\n# compute the full basins of attraction:\nbasins, attractors = basins_of_attraction(mapper; show_progress = false)","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"fig, ax = heatmap(xg, yg, basins)\nx, y = columns(X) # attractor of Henon map\nscatter!(ax, x, y; color = \"black\")\nfig","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"You could also be using a DynamicalSystem instance directly to build your own algorithm if it isn't already implemented (and then later contribute it so it is implemented ;) ). A dynamical system can be evolved forwards in time using step!:","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"henon","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"Notice how the time is not 0, because henon has already been stepped when we called the function basins_of_attraction with it. We can step it more:","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"step!(henon)","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"step!(henon, 2)","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"For more information on how to directly use DynamicalSystem instances, see the documentation of DynamicalSystemsBase.","category":"page"},{"location":"tutorial/#State-space-sets","page":"Overarching tutorial","title":"State space sets","text":"","category":"section"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"Let's recall that the output of the trajectory function is a StateSpaceSet:","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"X","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"It is printed like a matrix where each column is the timeseries of each dynamic variable. In reality, it is a vector of statically sized vectors (for performance reasons). When indexed with 1 index, it behaves like a vector of vectors","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"X[1]","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"X[2:5]","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"When indexed with two indices, it behaves like a matrix","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"X[2:5, 2]","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"When iterated, it iterates over the contained points","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"for (i, point) in enumerate(X)\n    @show point\n    i > 5 && break\nend","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"map(point -> point[1] + point[2], X)","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"The columns of the set are obtained with the convenience columns function","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"x, y = columns(X)\nsummary.((x, y))","category":"page"},{"location":"tutorial/#Using-state-space-sets","page":"Overarching tutorial","title":"Using state space sets","text":"","category":"section"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"Several packages of the library deal with StateSpaceSets.","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"You could use ComplexityMeasures to obtain the entropy, or other complexity measures, of a given set. Below, we obtain the entropy of the natural density of the chaotic attractor by partitioning into a histogram of approximately 50 bins per dimension:","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"prob_est = ValueHistogram(50)\nentropy(prob_est, X)","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"Alternatively, you could use FractalDimensions to get the fractal dimensions of the chaotic attractor of the henon map using the Grassberger-Procaccia algorithm:","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"grassberger_proccacia_dim(X)","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"Or, you could obtain a recurrence matrix of a state space set with RecurrenceAnalysis","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"R = RecurrenceMatrix(Y, 8.0)\nRg = grayscale(R)\nrr = recurrencerate(R)\nheatmap(Rg; colormap = :grays,\n    axis = (title = \"recurrence rate = $(rr)\", aspect = 1,)\n)","category":"page"},{"location":"tutorial/#More-nonlinear-timeseries-analysis","page":"Overarching tutorial","title":"More nonlinear timeseries analysis","text":"","category":"section"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"A trajectory of a known dynamical system is one way to obtain a StateSpaceSet. However, another common way is via a delay coordinates embedding of a measured/observed timeseries. For example, we could use optimal_traditional_de from DelayEmbeddings to create an optimized delay coordinates embedding of a timeseries","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"w = Y[:, 1] # first variable of Lorenz96\n𝒟, τ, e = optimal_traditional_de(w)\n𝒟","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"and compare","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"fig = Figure()\naxs = [Axis3(fig[1,i]) for i in 1:2]\nfor (S, ax) in zip((Y, 𝒟), axs)\n    lines!(ax, S[:, 1], S[:, 2], S[:, 3])\nend\nfig","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"Since 𝒟 is just another state space set, we could be using any of the above analysis pipelines on it just as easily.","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"The last package to mention here is TimeseriesSurrogates, which ties with all other observed/measured data analysis by providing a framework for confidence/hypothesis testing. For example, if we had a measured timeseries but we were not sure whether it represents a deterministic system with structure in the state space, or mostly noise, we could do a surrogate test. For this, we use surrogenerator and RandomFourier from TimeseriesSurrogates, and the generalized_dim from FractalDimensions (because it performs better in noisy sets)","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"x = X[:, 1] # Henon map timeseries\n# contaminate with noise\nusing Random: Xoshiro\nrng = Xoshiro(1234)\nx .+= randn(rng, length(x))/100\n# compute noise-contaminated fractal dim.\nΔ_orig = generalized_dim(embed(x, 2, 1))","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"And we do the surrogate test","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"surrogate_method = RandomFourier()\nsgen = surrogenerator(x, surrogate_method, rng)\n\nΔ_surr = map(1:1000) do i\n    s = sgen()\n    generalized_dim(embed(s, 2, 1))\nend","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"and visualize the test result","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"fig, ax = hist(Δ_surr)\nvlines!(ax, Δ_orig)\nfig","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"since the real value is outside the distribution we have confidence the data are not pure noise.","category":"page"},{"location":"tutorial/#Core-components-reference","page":"Overarching tutorial","title":"Core components reference","text":"","category":"section"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"StateSpaceSet\nDynamicalSystem","category":"page"},{"location":"tutorial/#StateSpaceSets.StateSpaceSet","page":"Overarching tutorial","title":"StateSpaceSets.StateSpaceSet","text":"StateSpaceSet{D, T} <: AbstractStateSpaceSet{D,T}\n\nA dedicated interface for sets in a state space. It is an ordered container of equally-sized points of length D. Each point is represented by SVector{D, T}. The data are a standard Julia Vector{SVector}, and can be obtained with vec(ssset::StateSpaceSet). Typically the order of points in the set is the time direction, but it doesn't have to be.\n\nWhen indexed with 1 index, StateSpaceSet is like a vector of points. When indexed with 2 indices it behaves like a matrix that has each of the columns be the timeseries of each of the variables. When iterated over, it iterates over its contained points. See description of indexing below for more.\n\nStateSpaceSet also supports almost all sensible vector operations like append!, push!, hcat, eachrow, among others.\n\nDescription of indexing\n\nIn the following let i, j be integers, typeof(X) <: AbstractStateSpaceSet and v1, v2 be <: AbstractVector{Int} (v1, v2 could also be ranges, and for performance benefits make v2 an SVector{Int}).\n\nX[i] == X[i, :] gives the ith point (returns an SVector)\nX[v1] == X[v1, :], returns a StateSpaceSet with the points in those indices.\nX[:, j] gives the jth variable timeseries (or collection), as Vector\nX[v1, v2], X[:, v2] returns a StateSpaceSet with the appropriate entries (first indices being \"time\"/point index, while second being variables)\nX[i, j] value of the jth variable, at the ith timepoint\n\nUse Matrix(ssset) or StateSpaceSet(matrix) to convert. It is assumed that each column of the matrix is one variable. If you have various timeseries vectors x, y, z, ... pass them like StateSpaceSet(x, y, z, ...). You can use columns(dataset) to obtain the reverse, i.e. all columns of the dataset in a tuple.\n\n\n\n\n\n","category":"type"},{"location":"tutorial/#DynamicalSystemsBase.DynamicalSystem","page":"Overarching tutorial","title":"DynamicalSystemsBase.DynamicalSystem","text":"DynamicalSystem\n\nDynamicalSystem is an abstract supertype encompassing all concrete implementations of what counts as a \"dynamical system\" in the DynamicalSystems.jl library.\n\nAll concrete implementations of DynamicalSystem can be iteratively evolved in time via the step! function. Hence, most library functions that evolve the system will mutate its current state and/or parameters. See the documentation online for implications this has on for parallelization.\n\nDynamicalSystem is further separated into two abstract types: ContinuousTimeDynamicalSystem, DiscreteTimeDynamicalSystem. The simplest and most common concrete implementations of a DynamicalSystem are DeterministicIteratedMap or CoupledODEs.\n\nDescription\n\nnote: Note\nThe documentation of DynamicalSystem follows chapter 1 of Nonlinear Dynamics, Datseris & Parlitz, Springer 2022.\n\nA ds::DynamicalSystem representes a flow Φ in a state space. It mainly encapsulates three things:\n\nA state, typically referred to as u, with initial value u0. The space that u occupies is the state space of ds and the length of u is the dimension of ds (and of the state space).\nA dynamic rule, typically referred to as f, that dictates how the state evolves/changes with time when calling the step! function. f is a standard Julia function, see below.\nA parameter container p that parameterizes f. p can be anything, but in general it is recommended to be a type-stable mutable container.\n\nIn sort, any set of quantities that change in time can be considered a dynamical system, however the concrete subtypes of DynamicalSystem are much more specific in their scope. Concrete subtypes typically also contain more information than the above 3 items.\n\nIn this scope dynamical systems have a known dynamic rule f defined as a standard Julia function. Observed or measured data from a dynamical system are represented using StateSpaceSet and are finite. Such data are obtained from the trajectory function or from an experimental measurement of a dynamical system with an unknown dynamic rule.\n\nConstruction instructions on f and u\n\nMost of the concrete implementations of DynamicalSystem, with the exception of ArbitrarySteppable, have two ways of implementing the dynamic rule f, and as a consequence the type of the state u. The distinction is done on whether f is defined as an in-place (iip) function or out-of-place (oop) function.\n\noop : f must be in the form f(u, p, t) -> out   which means that given a state u::SVector{<:Real} and some parameter container   p it returns the output of f as an SVector{<:Real} (static vector).\niip : f must be in the form f!(out, u, p, t)   which means that given a state u::AbstractArray{<:Real} and some parameter container p,   it writes in-place the output of f in out::AbstractArray{<:Real}.   The function must return nothing as a final statement.\n\nt stands for current time in both cases. iip is suggested for systems with high dimension and oop for small. The break-even point is between 10 to 100 dimensions but should be benchmarked on a case-by-case basis as it depends on the complexity of f.\n\nnote: Autonomous vs non-autonomous systems\nWhether the dynamical system is autonomous (f doesn't depend on time) or not, it is still necessary to include t as an argument to f. Some algorithms utilize this information, some do not, but we prefer to keep a consistent interface either way. You can also convert any system to autonomous by making time an additional variable. If the system is non-autonomous, its effective dimensionality is dimension(ds)+1.\n\nAPI\n\nThe API that the interface of DynamicalSystem employs is the functions listed below. Once a concrete instance of a subtype of DynamicalSystem is obtained, it can quieried or altered with the following functions.\n\nThe main use of a concrete dynamical system instance is to provide it to downstream functions such as lyapunovspectrum from ChaosTools.jl or basins_of_attraction from Attractors.jl. A typical user will likely not utilize directly the following API, unless when developing new algorithm implementations that use dynamical systems.\n\nAPI - information\n\nds(t) with ds an instance of DynamicalSystem: return the state of ds at time t. For continuous time systems this interpolates and extrapolates, while for discrete time systems it only works if t is the current time.\ncurrent_state\ninitial_state\ncurrent_parameters\ninitial_parameters\nisdeterministic\nisdiscretetime\ndynamic_rule\ncurrent_time\ninitial_time\nisinplace\n\nAPI - alter status\n\nreinit!\nset_state!\nset_parameter!\nset_parameters!\n\n\n\n\n\n","category":"type"},{"location":"tutorial/#Dynamical-system-implementations","page":"Overarching tutorial","title":"Dynamical system implementations","text":"","category":"section"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"DeterministicIteratedMap\nCoupledODEs\nStroboscopicMap\nPoincareMap\nProjectedDynamicalSystem\nArbitrarySteppable","category":"page"},{"location":"tutorial/#DynamicalSystemsBase.DeterministicIteratedMap","page":"Overarching tutorial","title":"DynamicalSystemsBase.DeterministicIteratedMap","text":"DeterministicIteratedMap <: DynamicalSystem\nDeterministicIteratedMap(f, u0, p = nothing; t0 = 0)\n\nA deterministic discrete time dynamical system defined by an iterated map as follows:\n\nvecu_n+1 = vecf(vecu_n p n)\n\nAn alias for DeterministicIteratedMap is DiscreteDynamicalSystem.\n\nOptionally configure the parameter container p and initial time t0.\n\nFor construction instructions regarding f, u0 see DynamicalSystem.\n\n\n\n\n\n","category":"type"},{"location":"tutorial/#DynamicalSystemsBase.CoupledODEs","page":"Overarching tutorial","title":"DynamicalSystemsBase.CoupledODEs","text":"CoupledODEs <: ContinuousTimeDynamicalSystem\nCoupledODEs(f, u0 [, p]; diffeq, t0 = 0.0)\n\nA deterministic continuous time dynamical system defined by a set of coupled ordinary differential equations as follows:\n\nfracdvecudt = vecf(vecu p t)\n\nAn alias for CoupledODE is ContinuousDynamicalSystem.\n\nOptionally provide the parameter container p and initial time as keyword t0.\n\nFor construction instructions regarding f, u0 see DynamicalSystem.\n\nDifferentialEquations.jl keyword arguments and interfacing\n\nThe ODEs are evolved via the solvers of DifferentialEquations.jl. When initializing a CoupledODEs, you can specify the solver that will integrate f in time, along with any other integration options, using the diffeq keyword. For example you could use diffeq = (abstol = 1e-9, reltol = 1e-9). If you want to specify a solver, do so by using the keyword alg, e.g.: diffeq = (alg = Tsit5(), reltol = 1e-6). This requires you to have been first using OrdinaryDiffEq to access the solvers. The default diffeq is:\n\n(alg = Tsit5(stagelimiter! = triviallimiter!, steplimiter! = triviallimiter!, thread = static(false)), abstol = 1.0e-6, reltol = 1.0e-6)\n\ndiffeq keywords can also include callback for event handling , however the majority of downstream functions in DynamicalSystems.jl assume that f is differentiable.\n\nThe convenience constructor CoupledODEs(prob::ODEProblem, diffeq) and CoupledODEs(ds::CoupledODEs, diffeq) are also available.\n\nDev note: CoupledODEs is a light wrapper of ODEIntegrator from DifferentialEquations.jl. The integrator is available as the field integ, and the ODEProblem is integ.sol.prob. The convenience syntax ODEProblem(ds::CoupledODEs, tspan = (t0, Inf)) is available.\n\n\n\n\n\n","category":"type"},{"location":"tutorial/#DynamicalSystemsBase.StroboscopicMap","page":"Overarching tutorial","title":"DynamicalSystemsBase.StroboscopicMap","text":"StroboscopicMap <: DiscreteTimeDynamicalSystem\nStroboscopicMap(ds::CoupledODEs, period::Real) → smap\nStroboscopicMap(period::Real, f, u0, p = nothing; kwargs...)\n\nA discrete time dynamical system that produces iterations of a time-dependent (non-autonomous) CoupledODEs system exactly over a given period. The second signature first creates a CoupledODEs and then calls the first.\n\nStroboscopicMap follows the DynamicalSystem interface. In addition, the function set_period!(smap, period) is provided, that sets the period of the system to a new value (as if it was a parameter). As this system is in discrete time, current_time and initial_time are integers. The initial time is always 0, because current_time counts elapsed periods. Call these functions on the parent of StroboscopicMap to obtain the corresponding continuous time. In contrast, reinit! expects t0 in continuous time.\n\nThe convenience constructor\n\nStroboscopicMap(T::Real, f, u0, p = nothing; diffeq, t0 = 0) → smap\n\nis also provided.\n\nSee also PoincareMap.\n\n\n\n\n\n","category":"type"},{"location":"tutorial/#DynamicalSystemsBase.PoincareMap","page":"Overarching tutorial","title":"DynamicalSystemsBase.PoincareMap","text":"PoincareMap <: DiscreteTimeDynamicalSystem\nPoincareMap(ds::CoupledODEs, plane; kwargs...) → pmap\n\nA discrete time dynamical system that produces iterations over the Poincaré map[DatserisParlitz2022] of the given continuous time ds. This map is defined as the sequence of points on the Poincaré surface of section, which is defined by the plane argument.\n\nSee also StroboscopicMap, poincaresos.\n\nKeyword arguments\n\ndirection = -1: Only crossings with sign(direction) are considered to belong to the surface of section. Positive direction means going from less than b to greater than b.\nu0 = nothing: Specify an initial state.\nrootkw = (xrtol = 1e-6, atol = 1e-8): A NamedTuple of keyword arguments passed to find_zero from Roots.jl.\nTmax = 1e3: The argument Tmax exists so that the integrator can terminate instead of being evolved for infinite time, to avoid cases where iteration would continue forever for ill-defined hyperplanes or for convergence to fixed points, where the trajectory would never cross again the hyperplane. If during one step! the system has been evolved for more than Tmax, then step!(pmap) will terminate and error.\n\nDescription\n\nThe Poincaré surface of section is defined as sequential transversal crossings a trajectory has with any arbitrary manifold, but here the manifold must be a hyperplane. PoincareMap iterates over the crossings of the section.\n\nIf the state of ds is mathbfu = (u_1 ldots u_D) then the equation defining a hyperplane is\n\na_1u_1 + dots + a_Du_D = mathbfacdotmathbfu=b\n\nwhere mathbfa b are the parameters of the hyperplane.\n\nIn code, plane can be either:\n\nA Tuple{Int, <: Real}, like (j, r): the plane is defined as when the jth variable of the system equals the value r.\nA vector of length D+1. The first D elements of the vector correspond to mathbfa while the last element is b.\n\nPoincareMap uses ds, higher order interpolation from DifferentialEquations.jl, and root finding from Roots.jl, to create a high accuracy estimate of the section.\n\nPoincareMap follows the DynamicalSystem interface with the following adjustments:\n\ndimension(pmap) == dimension(ds), even though the Poincaré map is effectively 1 dimension less.\nLike StroboscopicMap time is discrete and counts the iterations on the surface of section. initial_time is always 0 and current_time is current iteration number.\nA new function current_crossing_time returns the real time corresponding to the latest crossing of the hyperplane, which is what the current_state(ds) corresponds to as well.\nFor the special case of plane being a Tuple{Int, <:Real}, a special reinit! method is allowed with input state of length D-1 instead of D, i.e., a reduced state already on the hyperplane that is then converted into the D dimensional state.\n\nExample\n\nusing DynamicalSystemsBase\nds = Systems.rikitake(zeros(3); μ = 0.47, α = 1.0)\npmap = poincaremap(ds, (3, 0.0))\nstep!(pmap)\nnext_state_on_psos = current_state(pmap)\n\n[DatserisParlitz2022]: Datseris & Parlitz 2022, Nonlinear Dynamics: A Concise Introduction Interlaced with Code, Springer Nature, Undergrad. Lect. Notes In Physics\n\n\n\n\n\n","category":"type"},{"location":"tutorial/#DynamicalSystemsBase.ProjectedDynamicalSystem","page":"Overarching tutorial","title":"DynamicalSystemsBase.ProjectedDynamicalSystem","text":"ProjectedDynamicalSystem <: DynamicalSystem\nProjectedDynamicalSystem(ds::DynamicalSystem, projection, complete_state)\n\nA dynamical system that represents a projection of an existing ds on a (projected) space.\n\nThe projection defines the projected space. If projection isa AbstractVector{Int}, then the projected space is simply the variable indices that projection contains. Otherwise, projection can be an arbitrary function that given the state of the original system ds, returns the state in the projected space. In this case the projected space can be equal, or even higher-dimensional, than the original.\n\ncomplete_state produces the state for the original system from the projected state. complete_state can always be a function that given the projected state returns a state in the original space. However, if projection isa AbstractVector{Int}, then complete_state can also be a vector that contains the values of the remaining variables of the system, i.e., those not contained in the projected space. In this case the projected space needs to be lower-dimensional than the original.\n\nNotice that ProjectedDynamicalSystem does not require an invertible projection, complete_state is only used during reinit!. ProjectedDynamicalSystem is in fact a rather trivial wrapper of ds which steps it as normal in the original state space and only projects as a last step, e.g., during current_state.\n\nExamples\n\nCase 1: project 5-dimensional system to its last two dimensions.\n\nds = Systems.lorenz96(5)\nprojection = [4, 5]\ncomplete_state = [0.0, 0.0, 0.0] # completed state just in the plane of last two dimensions\npds = projected_integrator(ds, projection, complete_state)\nreinit!(pds, [0.2, 0.4])\nstep!(pds)\nget_state(pds)\n\nCase 2: custom projection to general functions of state. julia ds = Systems.lorenz96(5) projection(u) = [sum(u), sqrt(u[1]^2 + u[2]^2)] complete_state(y) = repeat(y[1]/5, 5) pds = # same as in above example...`\n\n\n\n\n\n","category":"type"},{"location":"tutorial/#DynamicalSystemsBase.ArbitrarySteppable","page":"Overarching tutorial","title":"DynamicalSystemsBase.ArbitrarySteppable","text":"ArbitrarySteppable <: DiscreteTimeDynamicalSystem\nArbitrarySteppable(\n    model, step!, extract_state, extract_parameters, reset_model!;\n    isdeterministic = true, set_state = reinit!,\n)\n\nA dynamical system generated by an arbitrary \"model\" that can be stepped in-place with some function step!(model) for 1 step. The state of the model is extracted by the extract_state(model) -> u function The parameters of the model are extracted by the extract_parameters(model) -> p function. The system may be re-initialized, via reinit!, with the reset_model! user-provided function that must have the call signature\n\nreset_model!(model, u, p)\n\ngiven a (potentially new) state u and parameter container p, both of which will default to the initial ones in the reinit! call.\n\nArbitrarySteppable exists to provide the DynamicalSystems.jl interface to models from other packages that could be used within the DynamicalSystems.jl library. ArbitrarySteppable follows the DynamicalSystem interface with the following adjustments:\n\ninitial_time is always 0, as time counts the steps the model has taken since creation or last reinit! call.\nset_state! is the same as reinit! by default. If not, the keyword argument set_state is a function set_state(model, u) that sets the state of the model to u.\nThe keyword isdeterministic should be set properly, as it decides whether downstream algorithms should error or not.\n\n\n\n\n\n","category":"type"},{"location":"tutorial/#Learn-more","page":"Overarching tutorial","title":"Learn more","text":"","category":"section"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"To learn more, you need to visit the documentation pages of the individual packages. See the contents page for more!","category":"page"}]
}
