{
    "docs": [
        {
            "location": "/", 
            "text": "Introduction\n\n\nDynamicalSystems.jl\n is a Julia package for the exploration of continuous and discrete dynamical systems. It aims to be a useful and powerful companion for students and scientists treading on the field of Chaos, nonlinear dynamics and dynamical systems in general. The package treats the following types of dynamical systems:\n\n\n\n\nDiscrete Maps\n\n\nContinuous Flows\n\n\nNumerical Data\n\n\n\n\nOne of a major goals of this package is to be completely transparent as to what is going on \"under the hood\". In scientific research, you never want to use \nblack boxes\n, e.g. functions that give a result without telling you how it was calculated. \nDynamicalSystems.jl\n battles this in 2 ways: Firstly, it is written entirely in Julia, making the source code clear and easy to understand for even novice users. Secondly, almost every documentation string gives \ndirect references to the original papers\n where the algorithm is taken from, in case some users don't understand (or simply don't want to read) the source code. For example, the documentation string of \n?lyapunovs\n will cite relevant publications for the definition and computation of the lyapunov spectrum.\n\n\n\n\nContents\n\n\nThis is the (non-final) list of what this package aims to offer:\n\n\n\n\nIntuitive, consistent APIs for the definition of general dynamical systems\n.\n\n\nAutomatic \"completion\" of the dynamics of the system with numerically computed Jacobians, in case they are not provided by the user\n.\n\n\nLyapunov exponent estimation\n.\n\n\nEntropy and Attractor Dimension estimation\n.\n\n\nEntropy/Attractor dimension/Lyapunov exponents for \nnumerical data\n.\n\n\nAttractor reconstruction, embedding and all that jazz\n.\n\n\nNumeric Computation of Kolmogorov-Sinai entropy.\n\n\nDefinition of chaos, by Ott.\n\n\nChaos control, TBA.\n\n\nOther stuff I have not yet decided upon, since this is like a pre-alpha version.\n\n\nSuggest or Contribute more stuff! (see \nContributor Guide\n).", 
            "title": "Introduction"
        }, 
        {
            "location": "/#introduction", 
            "text": "DynamicalSystems.jl  is a Julia package for the exploration of continuous and discrete dynamical systems. It aims to be a useful and powerful companion for students and scientists treading on the field of Chaos, nonlinear dynamics and dynamical systems in general. The package treats the following types of dynamical systems:   Discrete Maps  Continuous Flows  Numerical Data   One of a major goals of this package is to be completely transparent as to what is going on \"under the hood\". In scientific research, you never want to use  black boxes , e.g. functions that give a result without telling you how it was calculated.  DynamicalSystems.jl  battles this in 2 ways: Firstly, it is written entirely in Julia, making the source code clear and easy to understand for even novice users. Secondly, almost every documentation string gives  direct references to the original papers  where the algorithm is taken from, in case some users don't understand (or simply don't want to read) the source code. For example, the documentation string of  ?lyapunovs  will cite relevant publications for the definition and computation of the lyapunov spectrum.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#contents", 
            "text": "This is the (non-final) list of what this package aims to offer:   Intuitive, consistent APIs for the definition of general dynamical systems .  Automatic \"completion\" of the dynamics of the system with numerically computed Jacobians, in case they are not provided by the user .  Lyapunov exponent estimation .  Entropy and Attractor Dimension estimation .  Entropy/Attractor dimension/Lyapunov exponents for  numerical data .  Attractor reconstruction, embedding and all that jazz .  Numeric Computation of Kolmogorov-Sinai entropy.  Definition of chaos, by Ott.  Chaos control, TBA.  Other stuff I have not yet decided upon, since this is like a pre-alpha version.  Suggest or Contribute more stuff! (see  Contributor Guide ).", 
            "title": "Contents"
        }, 
        {
            "location": "/system_definition/", 
            "text": "System Definition\n\n\nFor \nDynamicalSystems.jl\n a system is simple a structure that contains the system's state, the equations of motion and the Jacobian. The last two are \nfunctions\n that take as an input a state.\n\n\nThis of course stands for systems where one already \nknows the equations of motion\n. if instead, your \"system\" is in the form of \nnumerical data\n, then see the appropriate section.\n\n\n\n\nNon-autonomous systems\n\n\nThis package does \nnot\n accept non-autonomous systems. To use such systems with this package increase the dimensionality of your system by 1, by introducing an additional variable \n\u03c4\n such that \nd\u03c4dt = 1\n (or \n\u03c4_next = \u03c4_prev + 1\n). This additional variable will serve as the \"time\" in your equations of motion.\n\n\n\n\n\n\nDiscrete Systems\n\n\nDiscrete systems are of the form:\n\n\n\n\n\n\\vec{x}_{n+1} = \\vec{f}(\\vec{x}_n).\n\n\n\n\n\nThe Type representing such systems is called \nDiscreteDS\n:\n\n\n#\n\n\nDynamicalSystems.DiscreteDS\n \n \nType\n.\n\n\nDiscreteDS(state, eom [, jacob]) \n: DynamicalSystem\n\n\n\n\n\nD\n-dimensional discrete dynamical system (used for \nD \u2264 10\n).\n\n\nFields:\n\n\n\n\nstate::SVector{D}\n : Current state-vector of the system, stored in the data format of \nStaticArray\n's \nSVector\n.\n\n\neom::F\n (function) : The function that represents the system's equations of motion (also called vector field). The function is of the format: \neom(u) -\n SVector\n which means that given a state-vector \nu\n it returns an \nSVector\n containing the next state.\n\n\njacob::J\n (function) : A function that calculates the system's jacobian matrix, based on the format: \njacob(u) -\n SMatrix\n which means that given a state-vector \nu\n it returns an \nSMatrix\n containing the Jacobian at that state. If the \njacob\n is not provided by the user, it is created with \ntremendous\n efficiency using the module \nForwardDiff\n. Most of the time, for low dimensional systems, this Jacobian is within a few % of speed of a user-defined one.\n\n\n\n\nsource\n\n\nThe documentation string of the constructor is perfectly self-contained, but for the sake of clarity we will go through all the steps in the following.\n\n\nstate\n is simply the state the system starts (a.k.a. initial conditions) and \neom\n is a \nfunction\n that takes a \nstate\n as an input and returns the next state as an output. The \njacob\n is also a \nfunction\n that takes a \nstate\n as an input and returns the Jacobian matrix of the system (at this state). This however is optional and if not provided by the user, will be calculated automatically using the package \nForwardDiff.jl\n.\n\n\n\n\nReturn form of the \neom\n function\n\n\nIt is \nheavily\n advised that the equations of motion \neom\n function returns an \nSVector\n from the julia package \nStaticArrays.jl\n and similarly the \njacob\n function returns an \nSMatrix\n. \nNumerous benchmarks\n have been made in order to deduce the most efficient possible way to define a system, and this way was proved to be the best when the system's dimension is small.\n\n\n\n\nFor example, let's create one of the \nPredefined Systems\n offered by this package, the H\u00e9non map:\n\n\nusing\n \nDynamicalSystems\n\n\nusing\n \nStaticArrays\n \n#only necessary when defining a system\n\n\n\neom_henon\n(\nx\n)\n \n=\n \nSVector\n{\n2\n}(\n1.0\n \n-\n \na\n*\nx\n[\n1\n]\n^\n2\n \n+\n \nx\n[\n2\n],\n \nb\n*\nx\n[\n1\n])\n\n\njacob_henon\n(\nx\n)\n \n=\n \n@SMatrix\n \n[\n-\n2\n*\na\n*\nx\n[\n1\n]\n \n1.0\n;\n \nb\n \n0.0\n]\n\n\n\nds\n \n=\n \nDiscreteDS\n(\nrand\n(\n2\n),\n \neom_henon\n,\n \njacob_henon\n)\n\n\n\n\n\n\nIf we did not want to write a Jacobian, we could do\n\n\nds_nojac\n \n=\n \nDiscreteDS\n(\nrand\n(\n2\n),\n \neom_henon\n)\n\n\n\n\n\n\nand the Jacobian function would be created automatically.\n\n\n\n\n1-dimensional Discrete Systems\n\n\nIn the case of maps, there a special structure for one-dimensional systems, since they are commonly used in scientific research. The syntax is \nDiscreteDS1D(state, eom [, deriv])\n. In this one-dimensional case, you don't need to worry about \nStaticArrays.jl\n because everything is in plain numbers. For example:\n\n\nusing\n \nDynamicalSystems\n\n\n\n@inline\n \neom_logistic\n(\nr\n)\n \n=\n \n(\nx\n)\n \n-\n \nr\n*\nx\n*\n(\n1\n-\nx\n)\n  \n# this is a closure\n\n\n@inline\n \nderiv_logistic\n(\nr\n)\n \n=\n \n(\nx\n)\n \n-\n \nr\n*\n(\n1\n-\n2\nx\n)\n \n# this is a closure\n\n\nr\n \n=\n \n3.7\n\n\nlogistic\n \n=\n \nDiscreteDS1D\n(\nrand\n(),\n \neom_logistic\n(\nr\n),\n \nderiv_logistic\n(\nr\n))\n\n\n\n\n\n\nOnce again, if you skip the derivative functions it will be calculated automatically using \nForwardDiff.jl\n.\n\n\n\n\nContinuous Systems\n\n\nContinuous systems of the form\n\n\n\n\n\n\\frac{d\\vec{u}}{dt} = \\vec{f}(\\vec{u}),\n\n\n\n\n\nare defined almost with the discrete systems:\n\n\n#\n\n\nDynamicalSystems.ContinuousDS\n \n \nType\n.\n\n\nContinuousDS(state, eom! [, jacob]) \n: DynamicalSystem\n\n\n\n\n\nD\n-dimensional continuous dynamical system.\n\n\nFields:\n\n\n\n\nstate::Vector{T}\n : Current state-vector of the system, stored in the data format of \nStaticArray\n's \nSVector\n.\n\n\neom!\n (function) : The function that represents the system's equations of motion (also called vector field). The function is of the format: \neom!(du, u)\n which means that it is \nin-place\n, with the Julian syntax (the mutated argument \ndu\n is the first).\n\n\njacob\n (function) : The function that represents the Jacobian of the system, given in the format: \njacob(u) =\n J\n (i.e. returns a matrix). If the matrix is an \nSMatrix\n from \nStaticArrays.jl\n there are major performance gains.\n\n\n\n\nBecause the \njacob\n function is only necessary for a small subset of algorithms, you do not have to provide it necessarily to the constructor (but then you can't use these functions).\n\n\nsource\n\n\nThere are two major differences compared to the discrete case:\n\n\n\n\nThe second field \neom!\n ends with an \n!\n to remind users that it is an in-place function.\n\n\nAutomated Jacobian function evaluation is not yet supported due to the dissonance of the interfaces of \nDifferentialEquations.jl\n and \nForwardDiff.jl\n\n\n\n\nNotice that providing a Jacobian is not necessary, as it is used by few methods (e.g. \nlyapunovs\n). If you do provide a Jacobian, it is best if it returns an \nSMatrix\n.\n\n\nFor example, the continuous R\u00f6ssler system can be defined as:\n\n\n@inline\n \n@inbounds\n \nfunction\n \neom_roessler!\n(\ndu\n,\n \nu\n)\n\n    \na\n \n=\n \n0.2\n;\n \nb\n \n=\n \n0.2\n;\n \nc\n \n=\n \n5.7\n\n    \ndu\n[\n1\n]\n \n=\n \n-\nu\n[\n2\n]\n-\nu\n[\n3\n]\n\n    \ndu\n[\n2\n]\n \n=\n \nu\n[\n1\n]\n \n+\n \na\n*\nu\n[\n2\n]\n\n    \ndu\n[\n3\n]\n \n=\n \nb\n \n+\n \nu\n[\n3\n]\n*\n(\nu\n[\n1\n]\n \n-\n \nc\n)\n\n\nend\n\n\n@inline\n \n@inbounds\n \nfunction\n \njacob_roessler\n(\nu\n)\n\n    \ni\n \n=\n \none\n(\neltype\n(\nu\n))\n\n    \no\n \n=\n \nzero\n(\neltype\n(\nu\n))\n\n    \n@SMatrix\n \n[\no\n     \n-\ni\n      \n-\ni\n;\n\n              \ni\n      \na\n       \no\n;\n\n              \nu\n[\n3\n]\n   \no\n       \nu\n[\n1\n]\n \n-\n \nc\n]\n\n\nend\n\n\n\nros\n \n=\n \nContinuousDS\n(\nrand\n(\n3\n),\n \neom_roessler!\n,\n \njacob_roessler\n)\n\n\n\n\n\n\n\n\nSystem evolution\n\n\nDynamicalSystems.jl\n provides convenient interfaces for the evolution of systems. Especially in the continuous case, an interface is provided to the module \nDifferentialEquations.jl\n, with an approach that fits more the structuring of the present package (e.g. time is never passed to the equations of motion).\n\n\nNotice that if you want to do repeated evolutions of a system, use the \nevolve!(::ODEProblem)\n interface, which does not create a new \nODEProblem\n every time.\n\n\nThese are the functions related to system-evolution:\n\n\n#\n\n\nDynamicalSystems.evolve\n \n \nFunction\n.\n\n\nevolve\n(\nds\n::\nDynamicalSystem\n,\n \nT\n=\n1\n;\n \ndiff_eq_kwargs\n \n=\n \nDict\n())\n \n-\n \nfinal_state\n\n\n\n\n\n\nEvolve a \nds\n for total \"time\" \nT\n and return the \nfinal_state\n (does not change \nds.state\n). For discrete systems \nT\n corresponds to steps and thus it must be integer. See \ntimeseries\n for using \ndiff_eq_kwargs\n.\n\n\nThis function \ndoes not store\n any information about intermediate steps. Use \ntimeseries\n if you want to produce timeseries of the system. If you want to perform step-by-step evolution use the struct \nODEIntegrator(ds, t_final)\n and the \nstep!(integrator)\n function provided by \nDifferentialEquations.jl\n.\n\n\nsource\n\n\n#\n\n\nDynamicalSystems.evolve!\n \n \nFunction\n.\n\n\nevolve!\n(\nds\n::\nDynamicalSystem\n,\n \nT\n;\n \ndiff_eq_kwargs\n \n=\n \nDict\n())\n \n-\n \nds\n\n\n\n\n\n\nEvolve (in-place) a dynamical system for total \"time\" \nT\n, setting the final state as the system's state. See \ntimeseries\n for using \ndiff_eq_kwargs\n.\n\n\nThis function \ndoes not store\n any information about intermediate steps. Use \ntimeseries\n if you want to produce timeseries of the system. If you want to perform step-by-step evolution use the struct \nODEIntegrator(ds, t_final)\n and the \nstep!(integrator)\n function provided by \nDifferentialEquations.jl\n.\n\n\nsource\n\n\n#\n\n\nDynamicalSystems.timeseries\n \n \nFunction\n.\n\n\ntimeseries\n(\nds\n::\nDynamicalSystem\n,\n \nT\n;\n \nkwargs\n...\n)\n \n-\n \nts\n\n\n\n\n\n\nCreate a matrix \nts\n that will contain the timeseries of the sytem, after evolving it for time \nT\n. \nEach column corresponds to one dynamic variable.\n\n\nFor the discrete case, \nT\n is an integer and a \nT\u00d7D\n matrix is returned (\nD\n is the system dimensionality). For the continuous case, a \nW\u00d7D\n matrix is returned, with \nW = length(0:dt:T)\n with \n0:dt:T\n representing the time vector (\nnot\n returned).\n\n\nKeywords:\n\n\n\n\ndt = 0.05\n : (only for continuous) Time step of value output during the solving of the continuous system.\n\n\ndiff_eq_kwargs = Dict()\n : (only for continuous) A dictionary \nDict{Symbol, ANY}\n of keyword arguments passed into the \nsolve\n of the \nDifferentialEquations.jl\n package, for example \nDict(:abstol =\n 1e-9)\n. If you want to specify a solver, do so by using the symbol \n:solver\n, e.g.: \nDict(:solver =\n DP5(), :maxiters =\n 1e9)\n. This requires you to have been first \nusing OrdinaryDiffEq\n to access the solvers.\n\n\n\n\nsource\n\n\nIn addition, interfaces are provided for usage directly with \nDifferentialEquations.jl\n, by giving additional constructors:\n\n\n#\n\n\nDiffEqBase.ODEProblem\n \n \nType\n.\n\n\nODEProblem\n(\nds\n::\nContinuousDS\n,\n \nt\n)\n\n\n\n\n\n\nReturn an \nODEProblem\n with the given system information (t0 is zero). This can be passed directly into \nsolve\n from \nDifferentialEquations\n.\n\n\nsource\n\n\n#\n\n\nOrdinaryDiffEq.ODEIntegrator\n \n \nType\n.\n\n\nODEIntegrator\n(\nds\n::\nContinuousDS\n,\n \nt\n;\n \ndiff_eq_kwargs\n)\n\n\n\n\n\n\nReturn an \nODEIntegrator\n, by first creating an \nODEProblem(ds, t)\n. This can be used directly with the interfaces of \nDifferentialEquations\n.\n\n\ndiff_eq_kwargs = Dict()\n is a dictionary \nDict{Symbol, ANY}\n of keyword arguments passed into the \ninit\n of the \nDifferentialEquations.jl\n package, for example \nDict(:abstol =\n 1e-9)\n. If you want to specify a solver, do so by using the symbol \n:solver\n, e.g.: \nDict(:solver =\n DP5(), :tstops =\n 0:0.01:t)\n. This requires you to have been first \nusing OrdinaryDiffEq\n to access the solvers.\n\n\nsource\n\n\n\n\nNumerical Data\n\n\nIn the most general case, the numerical data representing the evolution of a system are in the form of time-series. \nDynamicalSystems.jl\n offers many methods that accept numerical data. A general convention stated in the documentation string of all functions is the following: \nfoo(dataset)\n.\n\n\nThe dataset can be provided in two ways: firstly as a \nN\u00d7D\n matrix (\nfoo(matrix)\n) that contains \nN\n data points of a \nD\n dimensional system (each column represents a dynamical variable's timeseries). Secondly all functions can be also called as \nfoo(v1, v2, v3, ...)\n, passing vectors like a \nVararg\n. The \nvectors = v1, v2, ..., vD\n are simply the individual timeseries, so that \nmatrix \u2261 hcat(vectors...)\n.\n\n\n\n\nPredefined Systems\n\n\nPredefined systems exist in the \nSystems\n submodule exported by \nDynamicalSystems\n, in the form of functions that return a \nDynamicalSystem\n. They are accessed like:\n\n\nusing\n \nDynamicalSystems\n\n\nds\n \n=\n \nSystems\n.\nlorenz\n(\n\u03c1\n \n=\n \n32.0\n)\n\n\nts\n \n=\n \ntimeseries\n(\nds\n,\n \n10.0\n)\n\n\n\n\n\n\nAll of these functions have very similar documentation strings:\n\n\n\n\nCall signature (parameters of the system are always passed as keyword arguments).\n\n\nIntroductory text about what this system is and who introduced it first.\n\n\nCouple of sentences that contain cool science info about the system.\n\n\nReference to the original papers.\n\n\n\n\nSo far, the predefined systems that exist in the \nSystems\n sub-module are:\n\n\n#\n\n\nDynamicalSystems.Systems.henon\n \n \nFunction\n.\n\n\nhenon(u0=zeros(2); a = 1.4, b = 0.3)\n\n\n\n\n\nThe H\u00e9non map is a two-dimensional mapping due to H\u00e9non [1] that can display a strange attractor (at the default parameters). In addition, it also displays many other aspects of chaos, like period doubling or intermittency, for other parameters.\n\n\nAccording to the author, it is a system displaying all the properties of the Lorentz system (1963) while being as simple as possible.\n\n\nDefault values are the ones used in the original paper.\n\n\n[1] : M. H\u00e9non, Commun.Math. Phys. \n50\n, pp 69 (1976)\n\n\nsource\n\n\n#\n\n\nDynamicalSystems.Systems.logistic\n \n \nFunction\n.\n\n\nlogistic(x0 = rand(); r = 4.0)\n\n\n\n\n\nThe logistic map is an one dimensional unimodal mapping due to May [1] and is used by many as the archetypal example of how chaos can arise from very simple equations.\n\n\nOriginally intentend to be a discretized model of polulation dynamics, it is now famous for its bifurcation diagram, an immensly complex graph that that was shown be universal by Feigenbaum [2].\n\n\n[1] : R. M. May, Nature \n261\n, pp 459 (1976)\n\n\n[2] : M. J. Feigenbaum, J. Stat. Phys. \n19\n, pp 25 (1978)\n\n\nsource\n\n\n#\n\n\nDynamicalSystems.Systems.lorenz\n \n \nFunction\n.\n\n\nlorenz\n(\nu0\n=\n[\n0.0\n,\n \n10.0\n,\n \n0.0\n];\n \n\u03c3\n \n=\n \n10.0\n,\n \n\u03c1\n \n=\n \n28.0\n,\n \n\u03b2\n \n=\n \n8\n/\n3\n)\n\n\n\n\n\n\nThe famous three dimensional system due to Lorenz [1], shown to exhibit so-called \"deterministic nonperiodic flow\". It was originally invented to study a simplified form of atmospheric convection.\n\n\nCurrently, it is most famous for its strange attractor (occuring at the default parameters), which resembles a butterfly. For the same reason it is also associated with the term \"butterfly effect\" (a term which Lorenz himself disliked) even though the effect applies generally to dynamical systems.\n\n\nDefault values are the ones used in the original paper.\n\n\n[1] : E. N. Lorenz, J. atmos. Sci. \n20\n, pp 130 (1963)\n\n\nsource\n\n\n#\n\n\nDynamicalSystems.Systems.roessler\n \n \nFunction\n.\n\n\nroessler\n(\nu0\n=\nrand\n(\n3\n);\n \na\n \n=\n \n0.2\n,\n \nb\n \n=\n \n0.2\n,\n \nc\n \n=\n \n5.7\n)\n\n\n\n\n\n\nThis three-dimensional continuous system is due to R\u00f6ssler [1]. It is a system that by design behaves similarly to the \nlorenz\n system and displays a (fractal) strange attractor. However, it is easier to analyze qualitatively, as for example the attractor is composed of a single manifold.\n\n\nDefault values are the same as the original paper.\n\n\n[1] : O. E. R\u00f6ssler, Phys. Lett. \n57A\n, pp 397 (1976)\n\n\nsource\n\n\n#\n\n\nDynamicalSystems.Systems.standardmap\n \n \nFunction\n.\n\n\nstandardmap(u0=0.001rand(2); k = 0.971635)\n\n\n\n\n\nThe standard map (also known as Chirikov standard map) is a two dimensional, area-preserving chaotic mapping due to Chirikov [1]. It is one of the most studied chaotic systems and by far the most studied Hamiltonian (area-preserving) mapping.\n\n\nThe map corresponds to the  Poincar\u00e9's surface of section of the kicked rotor system. Changing the non-linearity parameter \nk\n transitions the system from completely periodic motion, to quasi-periodic, to local chaos (mixed phase-space) and finally to global chaos.\n\n\nThe default parameter \nk\n is the critical parameter where the golden-ratio torus is destroyed, as was calculated by Greene [2]. The e.o.m. considers the angle variable \n\u03b8\n to be the first, and the angular momentum \np\n to be the second variable, while both variables are always taken modulo 2\u03c0 (the mapping is on the [0,2\u03c0)\u00b2 torus).\n\n\n[1] : B. V. Chirikov, Preprint N. \n267\n, Institute of Nuclear Physics, Novosibirsk (1969)\n\n\n[2] : J. M. Greene, J. Math. Phys. \n20\n, pp 1183 (1979)\n\n\nsource\n\n\n#\n\n\nDynamicalSystems.Systems.towel\n \n \nFunction\n.\n\n\ntowel(u0 = [0.085, -0.121, 0.075])\n\n\n\n\n\nThe folded-towel map is a hyperchaotic mapping due to R\u00f6ssler [1]. It is famous for being a mapping that has the smallest possible dimensions necessary for hyperchaos, having two positive and one negative lyapunov exponent.\n\n\nThe name comes from the fact that when plotted looks like a folded towel, in every projection.\n\n\nDefault values are the ones used in the original paper.\n\n\n[1] : O. E. R\u00f6ssler, Phys. Lett. \n71A\n, pp 155 (1979)\n\n\nsource", 
            "title": "System Definition"
        }, 
        {
            "location": "/system_definition/#system-definition", 
            "text": "For  DynamicalSystems.jl  a system is simple a structure that contains the system's state, the equations of motion and the Jacobian. The last two are  functions  that take as an input a state.  This of course stands for systems where one already  knows the equations of motion . if instead, your \"system\" is in the form of  numerical data , then see the appropriate section.   Non-autonomous systems  This package does  not  accept non-autonomous systems. To use such systems with this package increase the dimensionality of your system by 1, by introducing an additional variable  \u03c4  such that  d\u03c4dt = 1  (or  \u03c4_next = \u03c4_prev + 1 ). This additional variable will serve as the \"time\" in your equations of motion.", 
            "title": "System Definition"
        }, 
        {
            "location": "/system_definition/#discrete-systems", 
            "text": "Discrete systems are of the form:   \n\\vec{x}_{n+1} = \\vec{f}(\\vec{x}_n).   The Type representing such systems is called  DiscreteDS :  #  DynamicalSystems.DiscreteDS     Type .  DiscreteDS(state, eom [, jacob])  : DynamicalSystem  D -dimensional discrete dynamical system (used for  D \u2264 10 ).  Fields:   state::SVector{D}  : Current state-vector of the system, stored in the data format of  StaticArray 's  SVector .  eom::F  (function) : The function that represents the system's equations of motion (also called vector field). The function is of the format:  eom(u) -  SVector  which means that given a state-vector  u  it returns an  SVector  containing the next state.  jacob::J  (function) : A function that calculates the system's jacobian matrix, based on the format:  jacob(u) -  SMatrix  which means that given a state-vector  u  it returns an  SMatrix  containing the Jacobian at that state. If the  jacob  is not provided by the user, it is created with  tremendous  efficiency using the module  ForwardDiff . Most of the time, for low dimensional systems, this Jacobian is within a few % of speed of a user-defined one.   source  The documentation string of the constructor is perfectly self-contained, but for the sake of clarity we will go through all the steps in the following.  state  is simply the state the system starts (a.k.a. initial conditions) and  eom  is a  function  that takes a  state  as an input and returns the next state as an output. The  jacob  is also a  function  that takes a  state  as an input and returns the Jacobian matrix of the system (at this state). This however is optional and if not provided by the user, will be calculated automatically using the package  ForwardDiff.jl .   Return form of the  eom  function  It is  heavily  advised that the equations of motion  eom  function returns an  SVector  from the julia package  StaticArrays.jl  and similarly the  jacob  function returns an  SMatrix .  Numerous benchmarks  have been made in order to deduce the most efficient possible way to define a system, and this way was proved to be the best when the system's dimension is small.   For example, let's create one of the  Predefined Systems  offered by this package, the H\u00e9non map:  using   DynamicalSystems  using   StaticArrays   #only necessary when defining a system  eom_henon ( x )   =   SVector { 2 }( 1.0   -   a * x [ 1 ] ^ 2   +   x [ 2 ],   b * x [ 1 ])  jacob_henon ( x )   =   @SMatrix   [ - 2 * a * x [ 1 ]   1.0 ;   b   0.0 ]  ds   =   DiscreteDS ( rand ( 2 ),   eom_henon ,   jacob_henon )   If we did not want to write a Jacobian, we could do  ds_nojac   =   DiscreteDS ( rand ( 2 ),   eom_henon )   and the Jacobian function would be created automatically.", 
            "title": "Discrete Systems"
        }, 
        {
            "location": "/system_definition/#1-dimensional-discrete-systems", 
            "text": "In the case of maps, there a special structure for one-dimensional systems, since they are commonly used in scientific research. The syntax is  DiscreteDS1D(state, eom [, deriv]) . In this one-dimensional case, you don't need to worry about  StaticArrays.jl  because everything is in plain numbers. For example:  using   DynamicalSystems  @inline   eom_logistic ( r )   =   ( x )   -   r * x * ( 1 - x )    # this is a closure  @inline   deriv_logistic ( r )   =   ( x )   -   r * ( 1 - 2 x )   # this is a closure  r   =   3.7  logistic   =   DiscreteDS1D ( rand (),   eom_logistic ( r ),   deriv_logistic ( r ))   Once again, if you skip the derivative functions it will be calculated automatically using  ForwardDiff.jl .", 
            "title": "1-dimensional Discrete Systems"
        }, 
        {
            "location": "/system_definition/#continuous-systems", 
            "text": "Continuous systems of the form   \n\\frac{d\\vec{u}}{dt} = \\vec{f}(\\vec{u}),   are defined almost with the discrete systems:  #  DynamicalSystems.ContinuousDS     Type .  ContinuousDS(state, eom! [, jacob])  : DynamicalSystem  D -dimensional continuous dynamical system.  Fields:   state::Vector{T}  : Current state-vector of the system, stored in the data format of  StaticArray 's  SVector .  eom!  (function) : The function that represents the system's equations of motion (also called vector field). The function is of the format:  eom!(du, u)  which means that it is  in-place , with the Julian syntax (the mutated argument  du  is the first).  jacob  (function) : The function that represents the Jacobian of the system, given in the format:  jacob(u) =  J  (i.e. returns a matrix). If the matrix is an  SMatrix  from  StaticArrays.jl  there are major performance gains.   Because the  jacob  function is only necessary for a small subset of algorithms, you do not have to provide it necessarily to the constructor (but then you can't use these functions).  source  There are two major differences compared to the discrete case:   The second field  eom!  ends with an  !  to remind users that it is an in-place function.  Automated Jacobian function evaluation is not yet supported due to the dissonance of the interfaces of  DifferentialEquations.jl  and  ForwardDiff.jl   Notice that providing a Jacobian is not necessary, as it is used by few methods (e.g.  lyapunovs ). If you do provide a Jacobian, it is best if it returns an  SMatrix .  For example, the continuous R\u00f6ssler system can be defined as:  @inline   @inbounds   function   eom_roessler! ( du ,   u ) \n     a   =   0.2 ;   b   =   0.2 ;   c   =   5.7 \n     du [ 1 ]   =   - u [ 2 ] - u [ 3 ] \n     du [ 2 ]   =   u [ 1 ]   +   a * u [ 2 ] \n     du [ 3 ]   =   b   +   u [ 3 ] * ( u [ 1 ]   -   c )  end  @inline   @inbounds   function   jacob_roessler ( u ) \n     i   =   one ( eltype ( u )) \n     o   =   zero ( eltype ( u )) \n     @SMatrix   [ o       - i        - i ; \n               i        a         o ; \n               u [ 3 ]     o         u [ 1 ]   -   c ]  end  ros   =   ContinuousDS ( rand ( 3 ),   eom_roessler! ,   jacob_roessler )", 
            "title": "Continuous Systems"
        }, 
        {
            "location": "/system_definition/#system-evolution", 
            "text": "DynamicalSystems.jl  provides convenient interfaces for the evolution of systems. Especially in the continuous case, an interface is provided to the module  DifferentialEquations.jl , with an approach that fits more the structuring of the present package (e.g. time is never passed to the equations of motion).  Notice that if you want to do repeated evolutions of a system, use the  evolve!(::ODEProblem)  interface, which does not create a new  ODEProblem  every time.  These are the functions related to system-evolution:  #  DynamicalSystems.evolve     Function .  evolve ( ds :: DynamicalSystem ,   T = 1 ;   diff_eq_kwargs   =   Dict ())   -   final_state   Evolve a  ds  for total \"time\"  T  and return the  final_state  (does not change  ds.state ). For discrete systems  T  corresponds to steps and thus it must be integer. See  timeseries  for using  diff_eq_kwargs .  This function  does not store  any information about intermediate steps. Use  timeseries  if you want to produce timeseries of the system. If you want to perform step-by-step evolution use the struct  ODEIntegrator(ds, t_final)  and the  step!(integrator)  function provided by  DifferentialEquations.jl .  source  #  DynamicalSystems.evolve!     Function .  evolve! ( ds :: DynamicalSystem ,   T ;   diff_eq_kwargs   =   Dict ())   -   ds   Evolve (in-place) a dynamical system for total \"time\"  T , setting the final state as the system's state. See  timeseries  for using  diff_eq_kwargs .  This function  does not store  any information about intermediate steps. Use  timeseries  if you want to produce timeseries of the system. If you want to perform step-by-step evolution use the struct  ODEIntegrator(ds, t_final)  and the  step!(integrator)  function provided by  DifferentialEquations.jl .  source  #  DynamicalSystems.timeseries     Function .  timeseries ( ds :: DynamicalSystem ,   T ;   kwargs ... )   -   ts   Create a matrix  ts  that will contain the timeseries of the sytem, after evolving it for time  T .  Each column corresponds to one dynamic variable.  For the discrete case,  T  is an integer and a  T\u00d7D  matrix is returned ( D  is the system dimensionality). For the continuous case, a  W\u00d7D  matrix is returned, with  W = length(0:dt:T)  with  0:dt:T  representing the time vector ( not  returned).  Keywords:   dt = 0.05  : (only for continuous) Time step of value output during the solving of the continuous system.  diff_eq_kwargs = Dict()  : (only for continuous) A dictionary  Dict{Symbol, ANY}  of keyword arguments passed into the  solve  of the  DifferentialEquations.jl  package, for example  Dict(:abstol =  1e-9) . If you want to specify a solver, do so by using the symbol  :solver , e.g.:  Dict(:solver =  DP5(), :maxiters =  1e9) . This requires you to have been first  using OrdinaryDiffEq  to access the solvers.   source  In addition, interfaces are provided for usage directly with  DifferentialEquations.jl , by giving additional constructors:  #  DiffEqBase.ODEProblem     Type .  ODEProblem ( ds :: ContinuousDS ,   t )   Return an  ODEProblem  with the given system information (t0 is zero). This can be passed directly into  solve  from  DifferentialEquations .  source  #  OrdinaryDiffEq.ODEIntegrator     Type .  ODEIntegrator ( ds :: ContinuousDS ,   t ;   diff_eq_kwargs )   Return an  ODEIntegrator , by first creating an  ODEProblem(ds, t) . This can be used directly with the interfaces of  DifferentialEquations .  diff_eq_kwargs = Dict()  is a dictionary  Dict{Symbol, ANY}  of keyword arguments passed into the  init  of the  DifferentialEquations.jl  package, for example  Dict(:abstol =  1e-9) . If you want to specify a solver, do so by using the symbol  :solver , e.g.:  Dict(:solver =  DP5(), :tstops =  0:0.01:t) . This requires you to have been first  using OrdinaryDiffEq  to access the solvers.  source", 
            "title": "System evolution"
        }, 
        {
            "location": "/system_definition/#numerical-data", 
            "text": "In the most general case, the numerical data representing the evolution of a system are in the form of time-series.  DynamicalSystems.jl  offers many methods that accept numerical data. A general convention stated in the documentation string of all functions is the following:  foo(dataset) .  The dataset can be provided in two ways: firstly as a  N\u00d7D  matrix ( foo(matrix) ) that contains  N  data points of a  D  dimensional system (each column represents a dynamical variable's timeseries). Secondly all functions can be also called as  foo(v1, v2, v3, ...) , passing vectors like a  Vararg . The  vectors = v1, v2, ..., vD  are simply the individual timeseries, so that  matrix \u2261 hcat(vectors...) .", 
            "title": "Numerical Data"
        }, 
        {
            "location": "/system_definition/#predefined-systems", 
            "text": "Predefined systems exist in the  Systems  submodule exported by  DynamicalSystems , in the form of functions that return a  DynamicalSystem . They are accessed like:  using   DynamicalSystems  ds   =   Systems . lorenz ( \u03c1   =   32.0 )  ts   =   timeseries ( ds ,   10.0 )   All of these functions have very similar documentation strings:   Call signature (parameters of the system are always passed as keyword arguments).  Introductory text about what this system is and who introduced it first.  Couple of sentences that contain cool science info about the system.  Reference to the original papers.   So far, the predefined systems that exist in the  Systems  sub-module are:  #  DynamicalSystems.Systems.henon     Function .  henon(u0=zeros(2); a = 1.4, b = 0.3)  The H\u00e9non map is a two-dimensional mapping due to H\u00e9non [1] that can display a strange attractor (at the default parameters). In addition, it also displays many other aspects of chaos, like period doubling or intermittency, for other parameters.  According to the author, it is a system displaying all the properties of the Lorentz system (1963) while being as simple as possible.  Default values are the ones used in the original paper.  [1] : M. H\u00e9non, Commun.Math. Phys.  50 , pp 69 (1976)  source  #  DynamicalSystems.Systems.logistic     Function .  logistic(x0 = rand(); r = 4.0)  The logistic map is an one dimensional unimodal mapping due to May [1] and is used by many as the archetypal example of how chaos can arise from very simple equations.  Originally intentend to be a discretized model of polulation dynamics, it is now famous for its bifurcation diagram, an immensly complex graph that that was shown be universal by Feigenbaum [2].  [1] : R. M. May, Nature  261 , pp 459 (1976)  [2] : M. J. Feigenbaum, J. Stat. Phys.  19 , pp 25 (1978)  source  #  DynamicalSystems.Systems.lorenz     Function .  lorenz ( u0 = [ 0.0 ,   10.0 ,   0.0 ];   \u03c3   =   10.0 ,   \u03c1   =   28.0 ,   \u03b2   =   8 / 3 )   The famous three dimensional system due to Lorenz [1], shown to exhibit so-called \"deterministic nonperiodic flow\". It was originally invented to study a simplified form of atmospheric convection.  Currently, it is most famous for its strange attractor (occuring at the default parameters), which resembles a butterfly. For the same reason it is also associated with the term \"butterfly effect\" (a term which Lorenz himself disliked) even though the effect applies generally to dynamical systems.  Default values are the ones used in the original paper.  [1] : E. N. Lorenz, J. atmos. Sci.  20 , pp 130 (1963)  source  #  DynamicalSystems.Systems.roessler     Function .  roessler ( u0 = rand ( 3 );   a   =   0.2 ,   b   =   0.2 ,   c   =   5.7 )   This three-dimensional continuous system is due to R\u00f6ssler [1]. It is a system that by design behaves similarly to the  lorenz  system and displays a (fractal) strange attractor. However, it is easier to analyze qualitatively, as for example the attractor is composed of a single manifold.  Default values are the same as the original paper.  [1] : O. E. R\u00f6ssler, Phys. Lett.  57A , pp 397 (1976)  source  #  DynamicalSystems.Systems.standardmap     Function .  standardmap(u0=0.001rand(2); k = 0.971635)  The standard map (also known as Chirikov standard map) is a two dimensional, area-preserving chaotic mapping due to Chirikov [1]. It is one of the most studied chaotic systems and by far the most studied Hamiltonian (area-preserving) mapping.  The map corresponds to the  Poincar\u00e9's surface of section of the kicked rotor system. Changing the non-linearity parameter  k  transitions the system from completely periodic motion, to quasi-periodic, to local chaos (mixed phase-space) and finally to global chaos.  The default parameter  k  is the critical parameter where the golden-ratio torus is destroyed, as was calculated by Greene [2]. The e.o.m. considers the angle variable  \u03b8  to be the first, and the angular momentum  p  to be the second variable, while both variables are always taken modulo 2\u03c0 (the mapping is on the [0,2\u03c0)\u00b2 torus).  [1] : B. V. Chirikov, Preprint N.  267 , Institute of Nuclear Physics, Novosibirsk (1969)  [2] : J. M. Greene, J. Math. Phys.  20 , pp 1183 (1979)  source  #  DynamicalSystems.Systems.towel     Function .  towel(u0 = [0.085, -0.121, 0.075])  The folded-towel map is a hyperchaotic mapping due to R\u00f6ssler [1]. It is famous for being a mapping that has the smallest possible dimensions necessary for hyperchaos, having two positive and one negative lyapunov exponent.  The name comes from the fact that when plotted looks like a folded towel, in every projection.  Default values are the ones used in the original paper.  [1] : O. E. R\u00f6ssler, Phys. Lett.  71A , pp 155 (1979)  source", 
            "title": "Predefined Systems"
        }, 
        {
            "location": "/lyapunovs/", 
            "text": "Lyapunov Exponents\n\n\nLyapunov exponents measure rates of separation of nearby trajectories in the flow of a dynamical system. The \nWikipedia\n and the \nScholarpedia\n entries have a lot of valuable information about the history and usage of these quantities.\n\n\nThe naming comes after Aleksandr M. Lyapunov, a Russian mathematician/physicist that had major impact on the analysis of the stability of systems.\n\n\n\n\nDynamical Systems\n\n\nFor systems where the equations of motion are known, there two functions related with the computation of lyapunov exponents: \nlyapunovs\n and \nlyapunov\n.\n\n\n\n\nLyapunov Spectrum\n\n\nThe function \nlyapunovs\n calculates the entire spectrum of the exponents of a system:\n\n\n#\n\n\nDynamicalSystems.lyapunovs\n \n \nFunction\n.\n\n\nlyapunovs\n(\nds\n::\nDynamicalSystem\n,\n \nN\n;\n \nkwargs\n...\n)\n \n-\n \n[\n\u03bb1\n,\n \n\u03bb2\n,\n \n...\n,\n \n\u03bbD\n]\n\n\n\n\n\n\nCalculate the spectrum of lyapunov [1] exponents of \nds\n by applying the QR-decomposition method \nN\n times (see method \"H2\" of [2], or directly the original paper(s) [3]). Returns a vector with the \nfinal\n values of the lyapunov exponents in descending order.\n\n\nKeyword Arguments:\n\n\n\n\nTtr = 0\n : Extra \"transient\" time to evolve the system before application of the algorithm. Should be \nInt\n for discrete systems.\n\n\ndt = 1.0\n : (only for continuous) Time of individual evolutions between sucessive orthonormalization steps.\n\n\ndiff_eq_kwargs = Dict()\n : (only for continuous) Keyword arguments passed into the solvers of the \nDifferentialEquations\n package (see \ntimeseries\n for more info).\n\n\n\n\n[1] : A. M. Lyapunov, \nThe General Problem of the Stability of Motion\n, Taylor \n Francis (1992)\n\n\n[2] : K. Geist \net al.\n, Progr. Theor. Phys. \n83\n, pp 875 (1990)\n\n\n[3] : G. Benettin \net al.\n, Meccanica \n15\n, pp 9-20 \n 21-30 (1980)\n\n\nsource\n\n\nAs you can see, the documentation string is detailed and self-contained. For example, the lyapunov spectrum of the \nfolded towel map\n is calculated as:\n\n\nusing\n \nDynamicalSystems\n\n\n\nds\n \n=\n \nSystems\n.\ntowel\n()\n\n\n\u03bb\u03bb\n \n=\n \nlyapunovs\n(\nds\n,\n \n10000\n)\n\n\n# result:\n\n\n[\n0.432253\n,\n \n0.371617\n,\n \n-\n3.29632\n]\n\n\n\n\n\n\nSimilarly, for a continuous system, e.g. the Lorenz system, you would do:\n\n\nusing\n \nDynamicalSystems\n\n\n\nlor\n \n=\n \nSystems\n.\nlorenz\n(\n\u03c1\n \n=\n \n32.0\n)\n \n#this is not the original parameter!\n\n\nissubtype\n(\ntypeof\n(\nds\n),\n \nContinuousDS\n)\n \n# true\n\n\n\n\u03bb\u03bb\n \n=\n \nlyapunovs\n(\nlor\n,\n \n10000\n,\n\n\ndt\n \n=\n \n0.1\n,\n \ndiff_eq_kwargs\n \n=\n \nDict\n(\n:\nabstol\n \n=\n \n1e-9\n,\n \n:\nreltol\n \n=\n \n1e-9\n))\n\n\n# result:\n\n\n[\n0.999176\n,\n \n0.000774754\n,\n \n-\n14.6666\n]\n\n\n\n\n\n\n\n\nMaximum Lyapunov Exponent\n\n\nThe function \nlyapunov\n calculates the maximum lyapunov exponent of a system, much more efficiently than getting the first result of \nlyapunovs\n:\n\n\n#\n\n\nDynamicalSystems.lyapunov\n \n \nFunction\n.\n\n\nlyapunov\n(\nds\n::\nDynamicalSystem\n,\n \n\u03a4\n;\n \nkwargs\n...\n)\n \n-\n \n\u03bb\n\n\n\n\n\n\nCalculate the maximum lyapunov exponent \n\u03bb\n using a method due to Benettin [1], which simply evolves two neighboring trajectories while constantly rescaling one of the two. \nT\n  denotes the total time of evolution (should be \nInt\n for discrete systems).\n\n\nKeyword Arguments:\n\n\n\n\nTtr = 0\n : Extra \"transient\" time to evolve the system before application of the algorithm. Should be \nInt\n for discrete systems.\n\n\nd0 = 1e-9\n : Initial \n rescaling distance between two neighboring trajectories.\n\n\nthreshold = 10^4*d0\n : Threshold to rescale the test trajectory.\n\n\ndiff_eq_kwargs = Dict()\n : (only for continuous) Keyword arguments passed into the solvers of the \nDifferentialEquations\n package (see \nevolve\n or \ntimeseries\n for more info).\n\n\ndt = 0.1\n : (only for continuous) Time of evolution between each check of distance exceeding the \nthreshold\n.\n\n\n\n\nWarning\n: Default values have been choosen to give accurate \n fast results for maximum lyapunov exponent expected between 0.1 to 1.0. Be sure to adjust them properly for your system. Specifically for the continuous systems, be sure that \nexp(\u03bb*dt) \n threshold/d0\n.\n\n\n[1] : G. Benettin \net al.\n, Phys. Rev. A \n14\n, pp 2338 (1976)\n\n\nsource\n\n\nFor example:\n\n\nusing\n \nDynamicalSystems\n\n\n\nhenon\n \n=\n \nSystems\n.\nhenon\n()\n\n\n\u03bb\n \n=\n \nlyapunov\n(\nhenon\n,\n \n10000\n,\n \nd0\n \n=\n \n1e-7\n,\n \nthreshold\n \n=\n \n1e-4\n,\n \nTtr\n \n=\n \n100\n)\n\n\n# result:\n\n\n0.42011626111385747\n\n\n\n\n\n\nThe same is done for continuous systems:\n\n\nusing\n \nDynamicalSystems\n,\n \nOrdinaryDiffEq\n\n\n\nross\n \n=\n \nSystems\n.\nroessler\n(\na\n \n=\n \n0.1\n,\n \nb\n \n=\n \n0.1\n,\n \nc\n \n=\n \n14.0\n)\n \n#not original parameters\n\n\n\u03bb\n \n=\n \nlyapunov\n(\nross\n,\n \n10000\n,\n \ndt\n \n=\n \n0.5\n,\n \ndiff_eq_kwargs\n \n=\n \nDict\n(\n:\nsolver\n \n=\n \nVern8\n()))\n\n\n# result:\n\n\n0.06957484163052223\n\n\n\n\n\n\n\n\nNumerical Data\n\n\nTBA", 
            "title": "Lyapunov Exponents"
        }, 
        {
            "location": "/lyapunovs/#lyapunov-exponents", 
            "text": "Lyapunov exponents measure rates of separation of nearby trajectories in the flow of a dynamical system. The  Wikipedia  and the  Scholarpedia  entries have a lot of valuable information about the history and usage of these quantities.  The naming comes after Aleksandr M. Lyapunov, a Russian mathematician/physicist that had major impact on the analysis of the stability of systems.", 
            "title": "Lyapunov Exponents"
        }, 
        {
            "location": "/lyapunovs/#dynamical-systems", 
            "text": "For systems where the equations of motion are known, there two functions related with the computation of lyapunov exponents:  lyapunovs  and  lyapunov .", 
            "title": "Dynamical Systems"
        }, 
        {
            "location": "/lyapunovs/#lyapunov-spectrum", 
            "text": "The function  lyapunovs  calculates the entire spectrum of the exponents of a system:  #  DynamicalSystems.lyapunovs     Function .  lyapunovs ( ds :: DynamicalSystem ,   N ;   kwargs ... )   -   [ \u03bb1 ,   \u03bb2 ,   ... ,   \u03bbD ]   Calculate the spectrum of lyapunov [1] exponents of  ds  by applying the QR-decomposition method  N  times (see method \"H2\" of [2], or directly the original paper(s) [3]). Returns a vector with the  final  values of the lyapunov exponents in descending order.  Keyword Arguments:   Ttr = 0  : Extra \"transient\" time to evolve the system before application of the algorithm. Should be  Int  for discrete systems.  dt = 1.0  : (only for continuous) Time of individual evolutions between sucessive orthonormalization steps.  diff_eq_kwargs = Dict()  : (only for continuous) Keyword arguments passed into the solvers of the  DifferentialEquations  package (see  timeseries  for more info).   [1] : A. M. Lyapunov,  The General Problem of the Stability of Motion , Taylor   Francis (1992)  [2] : K. Geist  et al. , Progr. Theor. Phys.  83 , pp 875 (1990)  [3] : G. Benettin  et al. , Meccanica  15 , pp 9-20   21-30 (1980)  source  As you can see, the documentation string is detailed and self-contained. For example, the lyapunov spectrum of the  folded towel map  is calculated as:  using   DynamicalSystems  ds   =   Systems . towel ()  \u03bb\u03bb   =   lyapunovs ( ds ,   10000 )  # result:  [ 0.432253 ,   0.371617 ,   - 3.29632 ]   Similarly, for a continuous system, e.g. the Lorenz system, you would do:  using   DynamicalSystems  lor   =   Systems . lorenz ( \u03c1   =   32.0 )   #this is not the original parameter!  issubtype ( typeof ( ds ),   ContinuousDS )   # true  \u03bb\u03bb   =   lyapunovs ( lor ,   10000 ,  dt   =   0.1 ,   diff_eq_kwargs   =   Dict ( : abstol   =   1e-9 ,   : reltol   =   1e-9 ))  # result:  [ 0.999176 ,   0.000774754 ,   - 14.6666 ]", 
            "title": "Lyapunov Spectrum"
        }, 
        {
            "location": "/lyapunovs/#maximum-lyapunov-exponent", 
            "text": "The function  lyapunov  calculates the maximum lyapunov exponent of a system, much more efficiently than getting the first result of  lyapunovs :  #  DynamicalSystems.lyapunov     Function .  lyapunov ( ds :: DynamicalSystem ,   \u03a4 ;   kwargs ... )   -   \u03bb   Calculate the maximum lyapunov exponent  \u03bb  using a method due to Benettin [1], which simply evolves two neighboring trajectories while constantly rescaling one of the two.  T   denotes the total time of evolution (should be  Int  for discrete systems).  Keyword Arguments:   Ttr = 0  : Extra \"transient\" time to evolve the system before application of the algorithm. Should be  Int  for discrete systems.  d0 = 1e-9  : Initial   rescaling distance between two neighboring trajectories.  threshold = 10^4*d0  : Threshold to rescale the test trajectory.  diff_eq_kwargs = Dict()  : (only for continuous) Keyword arguments passed into the solvers of the  DifferentialEquations  package (see  evolve  or  timeseries  for more info).  dt = 0.1  : (only for continuous) Time of evolution between each check of distance exceeding the  threshold .   Warning : Default values have been choosen to give accurate   fast results for maximum lyapunov exponent expected between 0.1 to 1.0. Be sure to adjust them properly for your system. Specifically for the continuous systems, be sure that  exp(\u03bb*dt)   threshold/d0 .  [1] : G. Benettin  et al. , Phys. Rev. A  14 , pp 2338 (1976)  source  For example:  using   DynamicalSystems  henon   =   Systems . henon ()  \u03bb   =   lyapunov ( henon ,   10000 ,   d0   =   1e-7 ,   threshold   =   1e-4 ,   Ttr   =   100 )  # result:  0.42011626111385747   The same is done for continuous systems:  using   DynamicalSystems ,   OrdinaryDiffEq  ross   =   Systems . roessler ( a   =   0.1 ,   b   =   0.1 ,   c   =   14.0 )   #not original parameters  \u03bb   =   lyapunov ( ross ,   10000 ,   dt   =   0.5 ,   diff_eq_kwargs   =   Dict ( : solver   =   Vern8 ()))  # result:  0.06957484163052223", 
            "title": "Maximum Lyapunov Exponent"
        }, 
        {
            "location": "/lyapunovs/#numerical-data", 
            "text": "TBA", 
            "title": "Numerical Data"
        }, 
        {
            "location": "/entropies/", 
            "text": "Entropies and Dimensions\n\n\n\n\nEntropies\n\n\nIn the study of dynamical systems there are many quantities that identify as \"entropy\". Notice that these quantities are not the more commonly known \nthermodynamic ones\n, used in Statistical Physics. Rather, they are more like the to the entropies of \ninformation theory\n, which represents information contained within a dataset, or information about the dimensional scaling of a dataset.\n\n\nDynamicalSystems.jl\n defines a lot entropies, summarized in the following sections.\n\n\n\n\nGeneralized Entropy \n Co.\n\n\nThe generalized entropy is a concept mainly attributed to R\u00e9nyi (see below).\n\n\n#\n\n\nDynamicalSystems.genentropy\n \n \nFunction\n.\n\n\ngenentropy\n(\n\u03b1\n,\n \n\u03b5\n,\n \ndataset\n)\n\n\n\n\n\n\nCompute the \n\u03b1\n order generalized (R\u00e9nyi) entropy [1] of a dataset, by first partitioning it into boxes of length \n\u03b5\n.\n\n\ngenentropy\n(\n\u03b1\n,\n \np\n::\nAbstractArray\n)\n\n\n\n\n\n\nCompute the entropy of an Array \np\n directly, assuming that \np\n is sum-normalized.\n\n\nlog base-e is used in both cases, i.e. units of \"nat\".\n\n\nThe R\u00e9nyi entropy \nR_\u03b1(p) = (1/1-\u03b1)*sum(pi^\u03b1 for pi \u2208 p)\n generalizes other known entropies, like e.g. the information entropy (\u03b1 = 1, see \nthe\n Shannon paper [2]), the maximum entropy (\u03b1 = 0, also known as Hartley entropy), or the correlation entropy (\u03b1 = 2, also known as collision entropy).\n\n\nThe following aliases are provided:\n\n\n\n\nrenyi = genentropy\n\n\nshannon(args...) = genentropy(1, args...)\n\n\nhartley(args...) = genentropy(0, args...)\n\n\n\n\n[1] : A. R\u00e9nyi, \nProceedings of the fourth Berkeley Symposium on Mathematics, Statistics and Probability\n, pp 547 (1960)\n\n\n[2] : C. E. Shannon, Bell Systems Technical Journal \n27\n, pp 379 (1948)\n\n\nsource\n\n\nBasically, given a dataset you can calculate an entropy by first partitioning it into boxes.\n\n\n\n\nWorried about memory overflow? Don't be!\n\n\nPartitioning the dataset (i.e. doing a \nhistogram\n) is in general a costly operation that depends exponentially on the number of dimensions of the system. However, in this specific case the partition process has some special aspects that can be taken advantage of, reducing tremendously the memory allocation and spent time.\n\n\n\n\nThe function used internally is \nnon0hist\n:\n\n\n#\n\n\nDynamicalSystems.non0hist\n \n \nFunction\n.\n\n\nnon0hist\n(\n\u03b5\n,\n \ndataset\n)\n\n\n\n\n\n\nPartition a data-set into tabulated intervals (boxes) of size \n\u03b5\n and return the \nsum-normalized\n histogram in an \nunordered 1D form\n, \ndiscarding all zero\n elements. This method is extremely effecient in both memory and speed, because it uses a dictionary to collect the information of bins with elements, while it completely disregards empty bins.\n\n\nUse e.g. \nfit(Histogram, ...)\n from \nStatsBase\n if you wish to keep information about the edges of the binning as well as the zero elements.\n\n\nsource\n\n\nIt typically outperforms traditional histograms by \nseveral orders of magnitude\n in both memory and speed. You can compare \nDynamicalSystems.perform_non0hist\n with \nDynamicalSystems.perform_non0hist_statsbase\n for specific numbers on your machine.\n\n\nFor example, the Shannon entropy of a coin-flip process should be one bit, \nby definition\n. Let's see...\n\n\nusing\n \nDynamicalSystems\n\n\ny\n \n=\n \nInt\n.\n(\nrand\n(\nBool\n,\n \n10000\n))\n \n# just some coin tosses\n\n\nsh\n \n=\n \nshannon\n(\n0.01\n,\n \ny\n)\n       \n# \u2261 genentropy(1, 0.01, y)\n\n\nisapprox\n(\nsh\n,\n \nlog\n(\n2\n),\n  \nrtol\n \n=\n \n1e-3\n)\n \n# true!\n\n\n\n\n\n\nBecause all entropies are calculated on base-e, the unit of measurement is \"nat\", and one bit is log(2)\u00d7nat.\n\n\n\n\nKolmogorov-Sinai Entropy\n\n\nTBA.\n\n\n\n\nAttractor Dimension Estimation\n\n\nThere are numerous methods that one can use to calculate a so-called \"dimension\" of a dataset, like for example the \nFractal dimension\n. This real number can offer a lot of information about the object that the dataset represents.\n\n\n\n\nGeneralized Dimensions \n Co.\n\n\nBased on the definition of the \ngeneralized entropy\n, one can calculate an appropriate dimension, called \ngeneralized dimension\n:\n\n\n#\n\n\nDynamicalSystems.generalized_dim\n \n \nFunction\n.\n\n\ngeneralized_dim(\u03b1, dataset) -\n D_\u03b1\n\n\n\n\n\nReturn the \n\u03b1\n order generalized dimension that corresponds to the given dataset. This quantity corresponds to the power law exponent of the scaling of the \ngenentropy\n versus the box size \n\u03b5\n.\n\n\nWARNING\n - This call performs a lot of automated steps:\n\n\n\n\nA vector of box sizes is decided by calling \nes = estimate_boxsizes(dataset)\n.\n\n\nFor each element of \nes\n the appropriate entropy is calculated, through \nd[i] = genentropy(\u03b1, es[i], dataset)\n. Let \nx = -log.(es)\n.\n\n\nThe curve d(x) is decomposed into linear regions, using \nlinear_regions(x, d)\n.\n\n\nThe biggest linear region is chosen, and a fit for the slope of that region is performed using the package \nLsqFit\n (see \nlinear_region\n).\n\n\nThis fitted slope is returned.\n\n\n\n\nBy doing these steps one by one yourself, you can adjust the keyword arguments given to each of these function calls, refining the accuracy of the result.\n\n\nThe following aliases are provided:\n\n\n\n\n\u03b1 = 0 : \nboxcounting_dim\n, \ncapacity_dim\n\n\n\u03b1 = 1 : \ninformation_dim\n\n\n\u03b1 = 2 : \ncorrelation_dim\n, \ncollision_dim\n\n\n\n\nsource\n\n\nAs stated clearly, this call performs a lot of automated steps. One is always better better of performing the steps one by one to attain maximum control. Nevertheless the automated steps are not \"bad\" and will give sensible results.\n\n\nFor example, we will calculate the dimensions of the strange attractors of the \nH\u00e9non map\n and the \nLorenz system\n:\n\n\nusing\n \nDynamicalSystems\n\n\nhen\n \n=\n \nSystems\n.\nhenon\n(\n-\nrand\n(\n2\n))\n\n\nts\n \n=\n \ntimeseries\n(\nhen\n,\n \n200000\n)\n\n\nD_hen\n \n=\n \ninformation_dim\n(\nts\n)\n\n\n\nlor\n \n=\n \nSystems\n.\nlorenz\n(\nrand\n(\n3\n))\n\n\nts\n \n=\n \ntimeseries\n(\nlor\n,\n \n5000\n,\n \ndt\n \n=\n \n0.05\n)\n\n\nD_lor\n \n=\n \ncapacity_dim\n(\nts\n)\n\n\n\n\n\n\nYou will find that \nD_hen\n is around \n1.2\n and \nD_lor\n is around \n1.95\n, both of which \nare correct values\n. As a side note, be sure that you have enough data points, otherwise the values you will get will never be correct, as is demonstrated by J.-P. Eckmann and D. Ruelle (see Physica D \n56\n, pp 185-187 (1992)).\n\n\n\n\nKaplan-Yorke Dimension (aka Lyapunov Dimension)\n\n\n#\n\n\nDynamicalSystems.kaplanyorke_dim\n \n \nFunction\n.\n\n\nkaplanyorke_dim\n(\nlyapunovs\n::\nAbstractVector\n)\n\n\n\n\n\n\nCalculate the Kaplan-Yorke dimension \n1\n. This simply is the point where \ncumsum(lyapunovs)\n becomes zero (interpolated). Returns the dimension of the system if the sum of the exponents never becomes negative.\n\n\n[1] :  J. Kaplan \n J. Yorke, \nChaotic behavior of multidimensional difference equations\n, Lecture Notes in Mathematics vol. \n730\n, Springer (1979)\n\n\nsource\n\n\nNotice that calling this function requires you to pass the lyapunov exponents in an ordered vector form (largest to smallest). Example:\n\n\nhen\n \n=\n \nSystems\n.\nhenon\n()\n\n\nD_kp\n \n=\n \nkaplanyorke_dim\n(\nlyapunovs\n(\nhen\n,\n \n200000\n))", 
            "title": "Entropies and Dimensions"
        }, 
        {
            "location": "/entropies/#entropies-and-dimensions", 
            "text": "", 
            "title": "Entropies and Dimensions"
        }, 
        {
            "location": "/entropies/#entropies", 
            "text": "In the study of dynamical systems there are many quantities that identify as \"entropy\". Notice that these quantities are not the more commonly known  thermodynamic ones , used in Statistical Physics. Rather, they are more like the to the entropies of  information theory , which represents information contained within a dataset, or information about the dimensional scaling of a dataset.  DynamicalSystems.jl  defines a lot entropies, summarized in the following sections.", 
            "title": "Entropies"
        }, 
        {
            "location": "/entropies/#generalized-entropy-co", 
            "text": "The generalized entropy is a concept mainly attributed to R\u00e9nyi (see below).  #  DynamicalSystems.genentropy     Function .  genentropy ( \u03b1 ,   \u03b5 ,   dataset )   Compute the  \u03b1  order generalized (R\u00e9nyi) entropy [1] of a dataset, by first partitioning it into boxes of length  \u03b5 .  genentropy ( \u03b1 ,   p :: AbstractArray )   Compute the entropy of an Array  p  directly, assuming that  p  is sum-normalized.  log base-e is used in both cases, i.e. units of \"nat\".  The R\u00e9nyi entropy  R_\u03b1(p) = (1/1-\u03b1)*sum(pi^\u03b1 for pi \u2208 p)  generalizes other known entropies, like e.g. the information entropy (\u03b1 = 1, see  the  Shannon paper [2]), the maximum entropy (\u03b1 = 0, also known as Hartley entropy), or the correlation entropy (\u03b1 = 2, also known as collision entropy).  The following aliases are provided:   renyi = genentropy  shannon(args...) = genentropy(1, args...)  hartley(args...) = genentropy(0, args...)   [1] : A. R\u00e9nyi,  Proceedings of the fourth Berkeley Symposium on Mathematics, Statistics and Probability , pp 547 (1960)  [2] : C. E. Shannon, Bell Systems Technical Journal  27 , pp 379 (1948)  source  Basically, given a dataset you can calculate an entropy by first partitioning it into boxes.   Worried about memory overflow? Don't be!  Partitioning the dataset (i.e. doing a  histogram ) is in general a costly operation that depends exponentially on the number of dimensions of the system. However, in this specific case the partition process has some special aspects that can be taken advantage of, reducing tremendously the memory allocation and spent time.   The function used internally is  non0hist :  #  DynamicalSystems.non0hist     Function .  non0hist ( \u03b5 ,   dataset )   Partition a data-set into tabulated intervals (boxes) of size  \u03b5  and return the  sum-normalized  histogram in an  unordered 1D form ,  discarding all zero  elements. This method is extremely effecient in both memory and speed, because it uses a dictionary to collect the information of bins with elements, while it completely disregards empty bins.  Use e.g.  fit(Histogram, ...)  from  StatsBase  if you wish to keep information about the edges of the binning as well as the zero elements.  source  It typically outperforms traditional histograms by  several orders of magnitude  in both memory and speed. You can compare  DynamicalSystems.perform_non0hist  with  DynamicalSystems.perform_non0hist_statsbase  for specific numbers on your machine.  For example, the Shannon entropy of a coin-flip process should be one bit,  by definition . Let's see...  using   DynamicalSystems  y   =   Int . ( rand ( Bool ,   10000 ))   # just some coin tosses  sh   =   shannon ( 0.01 ,   y )         # \u2261 genentropy(1, 0.01, y)  isapprox ( sh ,   log ( 2 ),    rtol   =   1e-3 )   # true!   Because all entropies are calculated on base-e, the unit of measurement is \"nat\", and one bit is log(2)\u00d7nat.", 
            "title": "Generalized Entropy &amp; Co."
        }, 
        {
            "location": "/entropies/#kolmogorov-sinai-entropy", 
            "text": "TBA.", 
            "title": "Kolmogorov-Sinai Entropy"
        }, 
        {
            "location": "/entropies/#attractor-dimension-estimation", 
            "text": "There are numerous methods that one can use to calculate a so-called \"dimension\" of a dataset, like for example the  Fractal dimension . This real number can offer a lot of information about the object that the dataset represents.", 
            "title": "Attractor Dimension Estimation"
        }, 
        {
            "location": "/entropies/#generalized-dimensions-co", 
            "text": "Based on the definition of the  generalized entropy , one can calculate an appropriate dimension, called  generalized dimension :  #  DynamicalSystems.generalized_dim     Function .  generalized_dim(\u03b1, dataset) -  D_\u03b1  Return the  \u03b1  order generalized dimension that corresponds to the given dataset. This quantity corresponds to the power law exponent of the scaling of the  genentropy  versus the box size  \u03b5 .  WARNING  - This call performs a lot of automated steps:   A vector of box sizes is decided by calling  es = estimate_boxsizes(dataset) .  For each element of  es  the appropriate entropy is calculated, through  d[i] = genentropy(\u03b1, es[i], dataset) . Let  x = -log.(es) .  The curve d(x) is decomposed into linear regions, using  linear_regions(x, d) .  The biggest linear region is chosen, and a fit for the slope of that region is performed using the package  LsqFit  (see  linear_region ).  This fitted slope is returned.   By doing these steps one by one yourself, you can adjust the keyword arguments given to each of these function calls, refining the accuracy of the result.  The following aliases are provided:   \u03b1 = 0 :  boxcounting_dim ,  capacity_dim  \u03b1 = 1 :  information_dim  \u03b1 = 2 :  correlation_dim ,  collision_dim   source  As stated clearly, this call performs a lot of automated steps. One is always better better of performing the steps one by one to attain maximum control. Nevertheless the automated steps are not \"bad\" and will give sensible results.  For example, we will calculate the dimensions of the strange attractors of the  H\u00e9non map  and the  Lorenz system :  using   DynamicalSystems  hen   =   Systems . henon ( - rand ( 2 ))  ts   =   timeseries ( hen ,   200000 )  D_hen   =   information_dim ( ts )  lor   =   Systems . lorenz ( rand ( 3 ))  ts   =   timeseries ( lor ,   5000 ,   dt   =   0.05 )  D_lor   =   capacity_dim ( ts )   You will find that  D_hen  is around  1.2  and  D_lor  is around  1.95 , both of which  are correct values . As a side note, be sure that you have enough data points, otherwise the values you will get will never be correct, as is demonstrated by J.-P. Eckmann and D. Ruelle (see Physica D  56 , pp 185-187 (1992)).", 
            "title": "Generalized Dimensions &amp; Co."
        }, 
        {
            "location": "/entropies/#kaplan-yorke-dimension-aka-lyapunov-dimension", 
            "text": "#  DynamicalSystems.kaplanyorke_dim     Function .  kaplanyorke_dim ( lyapunovs :: AbstractVector )   Calculate the Kaplan-Yorke dimension  1 . This simply is the point where  cumsum(lyapunovs)  becomes zero (interpolated). Returns the dimension of the system if the sum of the exponents never becomes negative.  [1] :  J. Kaplan   J. Yorke,  Chaotic behavior of multidimensional difference equations , Lecture Notes in Mathematics vol.  730 , Springer (1979)  source  Notice that calling this function requires you to pass the lyapunov exponents in an ordered vector form (largest to smallest). Example:  hen   =   Systems . henon ()  D_kp   =   kaplanyorke_dim ( lyapunovs ( hen ,   200000 ))", 
            "title": "Kaplan-Yorke Dimension (aka Lyapunov Dimension)"
        }, 
        {
            "location": "/nlts/", 
            "text": "Nonlinear Timeseries Analysis\n\n\n\n\nAttractor Reconstruction\n\n\nA timeseries can be used to gain information about the dynamics of the entire phase-space, by reconstructing a phase-space from the timeseries. One method that can do this is what is known as \ndelay coordinates embedding\n.\n\n\nIn \nDynamicalSystems.jl\n this is done through the \nreconstruct\n interface:\n\n\n#\n\n\nDynamicalSystems.reconstruct\n \n \nFunction\n.\n\n\nreconstruct(s::AbstractVector, \u03c4::Int, d::Int) -\n R\n\n\n\n\n\nCreate and return an efficient \nReconstruction\n data structure that serves as the delay-coordinates reconstruction of the signal \ns\n. The reconstuction has dimension \nd\n and delay \n\u03c4\n (measured in indeces). This object can have same invariant quantities (like e.g. lyapunov exponents) with the original system that the timeseries were recorded from [1, 2].\n\n\nThe returned \nR\n is a \nVectorOfArrays\n from \nRecursiveArrayTools.jl\n and stores all the information about the embedding without allocating new arrays. It can however be used as a normal matrix:\n\n\nR\n[\n:\n,\n \n2\n]\n \n# get the second column the reconstructed matrix\n\n\nR\n[\n5\n,\n \n1\n]\n \n# get the 5th element of the first column of the matrix\n\n\n\n\n\n\n[1] : F. Takens, \nDetecting Strange Attractors in Turbulence\u2014 Dynamical Systems and Turbulence\n, Lecture Notes in Mathematics \n366\n (1981)\n\n\n[2] : T. Sauer \net al.\n, J. Stat. Phys. \n65\n, pp 579 (1991)\n\n\nsource\n\n\nThe returned object can be immediately passed into e.g. a method that calculates the attractor dimension, or simply be used as any matrix. For example:\n\n\nusing\n \nDynamicalSystems\n\n\nhe\n \n=\n \nSystems\n.\nhenon\n()\n\n\nts\n \n=\n \ntimeseries\n(\nhe\n,\n \n20000\n)\n\n\nD1\n \n=\n \ninformation_dim\n(\nts\n)\n \n# around 1.20\n\n\nx\n \n=\n \nview\n(\nts\n,\n \n:\n,\n \n1\n)\n \n# some \nrecorded\n timeseries\n\n\nR\n \n=\n \nreconstruct\n(\nx\n,\n \n5\n,\n \n3\n)\n\n\nD2\n \n=\n \ninformation_dim\n(\nR\n)\n \n#around 1.17\n\n\n\n\n\n\nThe 2 numbers are very close, which is not too bad given that there wasn't any care for the value of \n\u03c4\n that was chosen! More importantly:\n\n\nusing\n \nBenchmarkTools\n\n\n@btime\n \nrecostruct\n(\n$\nx\n,\n \n5\n,\n \n3\n);\n\n\n# @btime result:  94.675 ns (6 allocations: 304 bytes)", 
            "title": "Nonlinear Timeseries Analysis"
        }, 
        {
            "location": "/nlts/#nonlinear-timeseries-analysis", 
            "text": "", 
            "title": "Nonlinear Timeseries Analysis"
        }, 
        {
            "location": "/nlts/#attractor-reconstruction", 
            "text": "A timeseries can be used to gain information about the dynamics of the entire phase-space, by reconstructing a phase-space from the timeseries. One method that can do this is what is known as  delay coordinates embedding .  In  DynamicalSystems.jl  this is done through the  reconstruct  interface:  #  DynamicalSystems.reconstruct     Function .  reconstruct(s::AbstractVector, \u03c4::Int, d::Int) -  R  Create and return an efficient  Reconstruction  data structure that serves as the delay-coordinates reconstruction of the signal  s . The reconstuction has dimension  d  and delay  \u03c4  (measured in indeces). This object can have same invariant quantities (like e.g. lyapunov exponents) with the original system that the timeseries were recorded from [1, 2].  The returned  R  is a  VectorOfArrays  from  RecursiveArrayTools.jl  and stores all the information about the embedding without allocating new arrays. It can however be used as a normal matrix:  R [ : ,   2 ]   # get the second column the reconstructed matrix  R [ 5 ,   1 ]   # get the 5th element of the first column of the matrix   [1] : F. Takens,  Detecting Strange Attractors in Turbulence\u2014 Dynamical Systems and Turbulence , Lecture Notes in Mathematics  366  (1981)  [2] : T. Sauer  et al. , J. Stat. Phys.  65 , pp 579 (1991)  source  The returned object can be immediately passed into e.g. a method that calculates the attractor dimension, or simply be used as any matrix. For example:  using   DynamicalSystems  he   =   Systems . henon ()  ts   =   timeseries ( he ,   20000 )  D1   =   information_dim ( ts )   # around 1.20  x   =   view ( ts ,   : ,   1 )   # some  recorded  timeseries  R   =   reconstruct ( x ,   5 ,   3 )  D2   =   information_dim ( R )   #around 1.17   The 2 numbers are very close, which is not too bad given that there wasn't any care for the value of  \u03c4  that was chosen! More importantly:  using   BenchmarkTools  @btime   recostruct ( $ x ,   5 ,   3 );  # @btime result:  94.675 ns (6 allocations: 304 bytes)", 
            "title": "Attractor Reconstruction"
        }, 
        {
            "location": "/contributors_guide/", 
            "text": "Contributor Guide\n\n\n\n\nWhat you can contribute\n\n\n\n\nAny method that calculates a quantity that has been used in at least one published (and peer-reviewed) journal.\n\n\nAny kind of new \nType\n of Dynamical system, provided it is also used in research. If you do want to make something like this, please make it a subtype of \nDynamicalSystem\n. I have created the discrete and continuous general types, but more specialized types would allow for specialized methods.\n\n\nIf you are adding a new system type accompanied by new methods and quantities, please introduce a new file in the \n/src\n folder, or even better create your own subfolder, instead of adding code to the existing files.\n\n\nAny kind of existing discrete or continuous system that have been used in published literature at least once and you find it useful. Put this in the \nfamous_systems.jl\n file.\n\n\n\n\nAlso, you can contribute in the enhancement of the existing package by:\n\n\n\n\nSolving the \ngithub issues\n\n\nImproving the speed of the existing methods. I am not good at writing extremely fast code by inspecting assembly and all that.\n\n\n\n\n\n\nHow you should contribute\n\n\nThis section will be updated as the package matures.\n\n\n\n\nFor new methods and systems please always have very clear and self-contained documentation strings.\n\n\nAlways have a reference to the original work that first introduces the method or the system that you are using. See the existing documentation strings and do it in an identical manner.\n\n\n\n\nWhen enhancing already existing code, make sure to:\n\n\n\n\nHave enough comments at parts that are not easily understood, so that somebody else may continue your work in the future.", 
            "title": "Contributor Guide"
        }, 
        {
            "location": "/contributors_guide/#contributor-guide", 
            "text": "", 
            "title": "Contributor Guide"
        }, 
        {
            "location": "/contributors_guide/#what-you-can-contribute", 
            "text": "Any method that calculates a quantity that has been used in at least one published (and peer-reviewed) journal.  Any kind of new  Type  of Dynamical system, provided it is also used in research. If you do want to make something like this, please make it a subtype of  DynamicalSystem . I have created the discrete and continuous general types, but more specialized types would allow for specialized methods.  If you are adding a new system type accompanied by new methods and quantities, please introduce a new file in the  /src  folder, or even better create your own subfolder, instead of adding code to the existing files.  Any kind of existing discrete or continuous system that have been used in published literature at least once and you find it useful. Put this in the  famous_systems.jl  file.   Also, you can contribute in the enhancement of the existing package by:   Solving the  github issues  Improving the speed of the existing methods. I am not good at writing extremely fast code by inspecting assembly and all that.", 
            "title": "What you can contribute"
        }, 
        {
            "location": "/contributors_guide/#how-you-should-contribute", 
            "text": "This section will be updated as the package matures.   For new methods and systems please always have very clear and self-contained documentation strings.  Always have a reference to the original work that first introduces the method or the system that you are using. See the existing documentation strings and do it in an identical manner.   When enhancing already existing code, make sure to:   Have enough comments at parts that are not easily understood, so that somebody else may continue your work in the future.", 
            "title": "How you should contribute"
        }
    ]
}