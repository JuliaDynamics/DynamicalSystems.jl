<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Periodicity &amp; Ergodicity · DynamicalSystems.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/logo.ico" rel="icon" type="image/x-icon"/><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="DynamicalSystems.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">DynamicalSystems.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../../contents/">Contents</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Dynamical systems</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../ds/general/">Dynamical System Definition</a></li><li><a class="tocitem" href="../../ds/predefined/">Predefined Dynamical Systems</a></li><li><a class="tocitem" href="../../embedding/dataset/">Numerical Data</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Entropies</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../entropies/api/">Entropies &amp; Probabilities</a></li><li><a class="tocitem" href="../../entropies/estimators/">Probabilities Estimators</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">DelayEmbeddings</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../embedding/reconstruction/">Delay Coordinates Embedding</a></li><li><a class="tocitem" href="../../embedding/traditional/">Traditional Optimal Embedding</a></li><li><a class="tocitem" href="../../embedding/unified/">Unified Optimal Embedding</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox" checked/><label class="tocitem" for="menuitem-6"><span class="docs-label">ChaosTools</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../orbitdiagram/">Orbit Diagrams &amp; PSOS</a></li><li><a class="tocitem" href="../lyapunovs/">Lyapunov Exponents</a></li><li><a class="tocitem" href="../chaos_detection/">Detecting &amp; Categorizing Chaos</a></li><li><a class="tocitem" href="../fractaldim/">Fractal Dimension</a></li><li><a class="tocitem" href="../nlts/">Nonlinear Timeseries Analysis</a></li><li class="is-active"><a class="tocitem" href>Periodicity &amp; Ergodicity</a><ul class="internal"><li><a class="tocitem" href="#Stable-and-Unstable-Periodic-Orbits-of-Maps"><span>Stable and Unstable Periodic Orbits of Maps</span></a></li><li><a class="tocitem" href="#Estimating-the-Period"><span>Estimating the Period</span></a></li><li><a class="tocitem" href="#Return-time-statistics"><span>Return time statistics</span></a></li></ul></li><li><a class="tocitem" href="../choosing/">Choosing a solver</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">RecurrenceAnalysis</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../rqa/rplots/">Recurrence Plots</a></li><li><a class="tocitem" href="../../rqa/quantification/">Recurrence Quantification Analysis</a></li><li><a class="tocitem" href="../../rqa/windowed/">Windowed RQA</a></li><li><a class="tocitem" href="../../rqa/networks/">Recurrence Network Analysis</a></li></ul></li><li><a class="tocitem" href="../../advanced/">Advanced Documentation</a></li><li><a class="tocitem" href="../../contributors_guide/">Contributor Guide</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">ChaosTools</a></li><li class="is-active"><a href>Periodicity &amp; Ergodicity</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Periodicity &amp; Ergodicity</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDynamics/DynamicalSystems.jl/blob/master/docs/src/chaos/periodicity.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Periodicity-and-Ergodicity"><a class="docs-heading-anchor" href="#Periodicity-and-Ergodicity">Periodicity &amp; Ergodicity</a><a id="Periodicity-and-Ergodicity-1"></a><a class="docs-heading-anchor-permalink" href="#Periodicity-and-Ergodicity" title="Permalink"></a></h1><p>In this page we describe methods related to the periodic behavior of dynamical systems or univariate timeseries, <em>or</em> related to the ergodic property of chaotic sets.</p><h2 id="Stable-and-Unstable-Periodic-Orbits-of-Maps"><a class="docs-heading-anchor" href="#Stable-and-Unstable-Periodic-Orbits-of-Maps">Stable and Unstable Periodic Orbits of Maps</a><a id="Stable-and-Unstable-Periodic-Orbits-of-Maps-1"></a><a class="docs-heading-anchor-permalink" href="#Stable-and-Unstable-Periodic-Orbits-of-Maps" title="Permalink"></a></h2><p>Chaotic behavior of low dimensional dynamical systems is affected by the position and the stability properties of the <a href="http://www.scholarpedia.org/article/Unstable_periodic_orbits">periodic orbits</a> of a dynamical system.</p><p>Finding unstable (or stable) periodic orbits of a discrete mapping analytically rapidly becomes impossible for higher orders of fixed points. Fortunately there is a numeric algorithm due to Schmelcher &amp; Diakonos which allows such a computation. Notice that even though the algorithm can find stable fixed points, it is mainly aimed at <em>unstable</em> ones.</p><p>The functions <code>periodicorbits</code> and <code>lambdamatrix</code> implement the algorithm:</p><article class="docstring"><header><a class="docstring-binding" id="ChaosTools.periodicorbits" href="#ChaosTools.periodicorbits"><code>ChaosTools.periodicorbits</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">periodicorbits(ds::DiscreteDynamicalSystem,
               o, ics [, λs, indss, singss]; kwargs...) -&gt; FP</code></pre><p>Find fixed points <code>FP</code> of order <code>o</code> for the map <code>ds</code> using the algorithm due to Schmelcher &amp; Diakonos<sup class="footnote-reference"><a id="citeref-Schmelcher1997" href="#footnote-Schmelcher1997">[Schmelcher1997]</a></sup>. <code>ics</code> is a collection of initial conditions (container of vectors) to be evolved.</p><p><strong>Optional Arguments</strong></p><p>The optional arguments <code>λs, indss, singss</code> <em>must be containers</em> of appropriate values, besides <code>λs</code> which can also be a number. The elements of those containers are passed to: <a href="#ChaosTools.lambdamatrix"><code>lambdamatrix(λ, inds, sings)</code></a>, which creates the appropriate <span>$\mathbf{\Lambda}_k$</span> matrix. If these arguments are not given, a random permutation will be chosen for them, with <code>λ=0.001</code>.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>maxiters::Int = 100000</code> : Maximum amount of iterations an i.c. will be iterated  before claiming it has not converged.</li><li><code>disttol = 1e-10</code> : Distance tolerance. If the 2-norm of a previous state with  the next one is <code>≤ disttol</code> then it has converged to a fixed point.</li><li><code>inftol = 10.0</code> : If a state reaches <code>norm(state) ≥ inftol</code> it is assumed that  it has escaped to infinity (and is thus abandoned).</li><li><code>roundtol::Int = 4</code> : The found fixed points are rounded  to <code>roundtol</code> digits before pushed into the list of returned fixed points <code>FP</code>,  <em>if</em> they are not already contained in <code>FP</code>.  This is done so that <code>FP</code> doesn&#39;t contain duplicate fixed points (notice  that this has nothing to do with <code>disttol</code>). Turn this to <code>typemax(Int)</code>  to get the full precision of the algorithm.</li></ul><p><strong>Description</strong></p><p>The algorithm used can detect periodic orbits by turning fixed points of the original map <code>ds</code> to stable ones, through the transformation</p><p class="math-container">\[\mathbf{x}_{n+1} = \mathbf{x}_n +
\mathbf{\Lambda}_k\left(f^{(o)}(\mathbf{x}_n) - \mathbf{x}_n\right)\]</p><p>with <span>$f$</span> = <code>eom</code>. The index <span>$k$</span> counts the various possible <span>$\mathbf{\Lambda}_k$</span>.</p><p><strong>Performance Notes</strong></p><p><em>All</em> initial conditions are evolved for <em>all</em> <span>$\mathbf{\Lambda}_k$</span> which can very quickly lead to long computation times.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ChaosTools.lambdamatrix" href="#ChaosTools.lambdamatrix"><code>ChaosTools.lambdamatrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">lambdamatrix(λ, inds::Vector{Int}, sings) -&gt; Λk</code></pre><p>Return the matrix <span>$\mathbf{\Lambda}_k$</span> used to create a new dynamical system with some unstable fixed points turned to stable in the function <a href="#ChaosTools.periodicorbits"><code>periodicorbits</code></a>.</p><p><strong>Arguments</strong></p><ol><li><code>λ&lt;:Real</code> : the multiplier of the <span>$C_k$</span> matrix, with <code>0&lt;λ&lt;1</code>.</li><li><code>inds::Vector{Int}</code> : The <code>i</code>th entry of this vector gives the <em>row</em> of the nonzero element of the <code>i</code>th column of <span>$C_k$</span>.</li><li><code>sings::Vector{&lt;:Real}</code> : The element of the <code>i</code>th column of <span>$C_k$</span> is +1 if <code>signs[i] &gt; 0</code> and -1 otherwise (<code>sings</code> can also be <code>Bool</code> vector).</li></ol><p>Calling <code>lambdamatrix(λ, D::Int)</code> creates a random <span>$\mathbf{\Lambda}_k$</span> by randomly generating an <code>inds</code> and a <code>signs</code> from all possible combinations. The <em>collections</em> of all these combinations can be obtained from the function <a href="#ChaosTools.lambdaperms"><code>lambdaperms</code></a>.</p><p><strong>Description</strong></p><p>Each element of <code>inds</code> <em>must be unique</em> such that the resulting matrix is orthogonal and represents the group of special reflections and permutations.</p><p>Deciding the appropriate values for <code>λ, inds, sings</code> is not trivial. However, in ref.<sup class="footnote-reference"><a id="citeref-Pingel2000" href="#footnote-Pingel2000">[Pingel2000]</a></sup> there is a lot of information that can help with that decision. Also, by appropriately choosing various values for <code>λ</code>, one can sort periodic orbits from e.g. least unstable to most unstable, see<sup class="footnote-reference"><a id="citeref-Diakonos1998" href="#footnote-Diakonos1998">[Diakonos1998]</a></sup> for details.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ChaosTools.lambdaperms" href="#ChaosTools.lambdaperms"><code>ChaosTools.lambdaperms</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">lambdaperms(D) -&gt; indperms, singperms</code></pre><p>Return two collections that each contain all possible combinations of indices (total of <span>$D!$</span>) and signs (total of <span>$2^D$</span>) for dimension <code>D</code> (see <a href="#ChaosTools.lambdamatrix"><code>lambdamatrix</code></a>).</p></div></section></article><hr/><h3 id="Standard-Map-example"><a class="docs-heading-anchor" href="#Standard-Map-example">Standard Map example</a><a id="Standard-Map-example-1"></a><a class="docs-heading-anchor-permalink" href="#Standard-Map-example" title="Permalink"></a></h3><p>For example, let&#39;s find the fixed points of the <a href="../../ds/predefined/#DynamicalSystemsBase.Systems.standardmap"><code>Systems.standardmap</code></a> of order 2, 3, 4, 5, 6 and 8. We will use all permutations for the <code>signs</code> but only one for the <code>inds</code>. We will also only use one <code>λ</code> value, and a 21×21 density of initial conditions.</p><p>First, initialize everything</p><pre><code class="language-julia">using DynamicalSystems, PyPlot, StaticArrays

ds = Systems.standardmap()
xs = range(0, stop = 2π, length = 21); ys = copy(xs)
ics = [SVector{2}(x,y) for x in xs for y in ys]

# All permutations of [±1, ±1]:
singss = lambdaperms(2)[2] # second entry are the signs

# I know from personal research I only need this `inds`:
indss = [[1,2]] # &lt;- must be container of vectors!!!

λs = 0.005 # &lt;- only this allowed to not be vector (could also be vector)

orders = [2, 3, 4, 5, 6, 8]
ALLFP = Dataset{2, Float64}[];</code></pre><pre class="documenter-example-output">Dataset{2, Float64}[]</pre><p>Then, do the necessary computations for all orders</p><pre><code class="language-julia">for o in orders
    FP = periodicorbits(ds, o, ics, λs, indss, singss)
    push!(ALLFP, FP)
end</code></pre><p>Plot the phase space of the standard map</p><pre><code class="language-julia">iters = 1000
dataset = trajectory(ds, iters)
for x in xs
    for y in ys
        append!(dataset, trajectory(ds, iters, SVector{2}(x, y)))
    end
end
figure(figsize = (12,12))
m = Matrix(dataset)
PyPlot.scatter(view(m, :, 1), view(m, :, 2), s= 1, color = &quot;black&quot;)
PyPlot.xlim(xs[1], xs[end])
PyPlot.ylim(ys[1], ys[end]);</code></pre><pre class="documenter-example-output">(0.0, 6.283185307179586)</pre><p>and finally, plot the fixed points</p><pre><code class="language-julia">markers = [&quot;D&quot;, &quot;^&quot;, &quot;s&quot;, &quot;p&quot;, &quot;h&quot;, &quot;8&quot;]
colors = [&quot;b&quot;, &quot;g&quot;, &quot;r&quot;, &quot;c&quot;, &quot;m&quot;, &quot;grey&quot;]

for i in 1:6
    FP = ALLFP[i]
    o = orders[i]
    PyPlot.plot(columns(FP)...,
    marker=markers[i], color = colors[i], markersize=10.0 + (8-o), linewidth=0.0,
    label = &quot;order $o&quot;, markeredgecolor = &quot;yellow&quot;, markeredgewidth = 0.5)
end
legend(loc=&quot;upper right&quot;, framealpha=0.9)
xlabel(&quot;\$\\theta\$&quot;)
ylabel(&quot;\$p\$&quot;)</code></pre><p><img src="../fixedpoints.png" alt="Fixed points of the standard map"/></p><p>You can confirm for yourself that this is correct, for many reasons:</p><ol><li>It is the same <a href="https://journals.aps.org/pre/abstract/10.1103/PhysRevE.92.012914">fig. 12 of this publication</a>.</li><li>Fixed points of order <span>$n$</span> are also fixed points of order <span>$2n, 3n, 4n, ...$</span></li><li>Besides fixed points of previous orders, <em>original</em> fixed points of order <span>$n$</span> come in (possible multiples of) <span>$2n$</span>-sized pairs (see e.g. order 5). This is a direct consequence of the Poincaré–Birkhoff theorem.</li></ol><h2 id="Estimating-the-Period"><a class="docs-heading-anchor" href="#Estimating-the-Period">Estimating the Period</a><a id="Estimating-the-Period-1"></a><a class="docs-heading-anchor-permalink" href="#Estimating-the-Period" title="Permalink"></a></h2><p>The function <a href="#ChaosTools.estimate_period"><code>estimate_period</code></a> from <code>ChaosTools</code> offers ways for estimating the period (either exact for periodic timeseries, or approximate for near-periodic ones) of a given timeseries. We offer five methods to estimate periods, some of which work on evenly sampled data only, and others which accept any data. The figure below summarizes this: <img src="https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/chaos/periodestimationmethods.png?raw=true" alt/></p><article class="docstring"><header><a class="docstring-binding" id="ChaosTools.estimate_period" href="#ChaosTools.estimate_period"><code>ChaosTools.estimate_period</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">estimate_period(v::Vector, method, t=0:length(v)-1; kwargs...)</code></pre><p>Estimate the period of the signal <code>v</code>, with accompanying time vector <code>t</code>, using the given <code>method</code>.</p><p>If <code>t</code> is an AbstractArray, then it is iterated through to ensure that it&#39;s evenly sampled (if necessary for the algorithm).  To avoid this, you can pass any <code>AbstractRange</code>, like a <code>UnitRange</code> or a <code>LinRange</code>, which are defined to be evenly sampled.</p><p><strong>Methods requiring evenly sampled data</strong></p><p>These methods are faster, but some are error-prone.</p><ul><li><p><code>:periodogram</code> or <code>:pg</code>: Use the fast Fourier transform to compute a  periodogram (power-spectrum) of the given data.  Data must be evenly sampled.</p></li><li><p><code>:multitaper</code> or <code>mt</code>: The multitaper method reduces estimation bias by using multiple independent estimates from the same sample. Data tapers are then windowed and the power spectra are obtained.  Available keywords follow: <code>nw</code> is the time-bandwidth product, and <code>ntapers</code> is the number of tapers. If <code>window</code> is not specified, the signal is tapered with <code>ntapers</code> discrete prolate spheroidal sequences with time-bandwidth product <code>nw</code>. Each sequence is equally weighted; adaptive multitaper is not (yet) supported. If <code>window</code> is specified, each column is applied as a taper. The sum of periodograms is normalized by the total sum of squares of <code>window</code>.</p></li><li><p><code>:autocorrelation</code> or <code>:ac</code>: Use the autocorrelation function (AC). The value where the AC first comes back close to 1 is the period of the signal. The keyword <code>L = length(v)÷10</code> denotes the length of the AC (thus, given the default setting, this method will fail if there less than 10 periods in the signal). The keyword <code>ϵ = 0.2</code> (<code>\epsilon</code>) means that <code>1-ϵ</code> counts as &quot;1&quot; for the AC.</p></li></ul><p><strong>Methods not requiring evenly sampled data</strong></p><p>These methods tend to be slow, but versatile and low-error.</p><ul><li><p><code>:lombscargle</code> or <code>:ls</code>: Use the Lomb-Scargle algorithm to compute a periodogram.  The advantage of the Lomb-Scargle method is that it does not require an equally sampled dataset and performs well on undersampled datasets. Constraints have been set on the period, since Lomb-Scargle tends to have false peaks at very low frequencies.  That being said, it&#39;s a very flexible method.  It is extremely customizable, and the keyword arguments that can be passed to it are given <a href="https://juliaastro.github.io/LombScargle.jl/stable/index.html#LombScargle.plan">in the documentation</a>.</p></li><li><p><code>:zerocrossing</code> or <code>:zc</code>: Find the zero crossings of the data, and use the average difference between zero crossings as the period.  This is a naïve implementation, with only linear interpolation; however, it&#39;s useful as a sanity check.  The keyword <code>line</code> controls where the &quot;crossing point&quot; is. It deffaults to <code>mean(v)</code>.</p></li></ul><p>For more information on the periodogram methods, see the documentation of DSP.jl and LombScargle.jl.</p></div></section></article><h3 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h3><p>Here we will use a modified FitzHugh-Nagumo system that results in periodic behavior, and then try to estimate its period. First, let&#39;s see the trajectory:</p><pre><code class="language-julia">using DynamicalSystems, PyPlot

function FHN(u, p, t)
    e, b, g = p
    v, w = u
    dv = min(max(-2 - v, v), 2 - v) - w
    dw = e*(v - g*w + b)
    return SVector(dv, dw)
end

g, e, b  = 0.8, 0.04, 0.0
p0 = [e, b, g]

fhn = ContinuousDynamicalSystem(FHN, SVector(-2, -0.6667), p0)
T, dt = 1000.0, 0.1
v = trajectory(fhn, T; dt = dt)[:, 1]
t = 0:dt:T

figure()
plot(0:dt:T, v)</code></pre><p><img src="../fhn_trajectory.png" alt="A periodic trajectory"/></p><p>Examining the figure, one can see that the period of the system is around <code>91</code> time units. To estimate it numerically let&#39;s use some of the methods:</p><pre><code class="language-julia">estimate_period(v, :autocorrelation, t)</code></pre><pre class="documenter-example-output">91.0</pre><pre><code class="language-julia">estimate_period(v, :periodogram, t)</code></pre><pre class="documenter-example-output">91.62720091627202</pre><pre><code class="language-julia">estimate_period(v, :zerocrossing, t)</code></pre><pre class="documenter-example-output">91.08000000000001</pre><h2 id="Return-time-statistics"><a class="docs-heading-anchor" href="#Return-time-statistics">Return time statistics</a><a id="Return-time-statistics-1"></a><a class="docs-heading-anchor-permalink" href="#Return-time-statistics" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ChaosTools.mean_return_times" href="#ChaosTools.mean_return_times"><code>ChaosTools.mean_return_times</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">mean_return_times(ds::DynamicalSystem, u₀, εs, T; kwargs...) → τ, c</code></pre><p>Return the mean return times to subsets of the state space of <code>ds</code> defined by <code>u₀, εs</code> as well as the amount of returns <code>c</code> for each subset. The <code>ds</code> is evolved for a maximum of <code>T</code> time. This function behaves similarly to <a href="#ChaosTools.exit_entry_times"><code>exit_entry_times</code></a> and thus see that one for the meaning of <code>u₀</code> and <code>εs</code>.</p><p>This function supports both discrete and continuous systems, however the optimizations done in discrete systems (where all nested <code>ε</code>-sets are checked at the same time), are not done here yet, which leads to disproportionally lower performance since each <code>ε</code>-related set is checked individually from start.</p><p>Continuous systems allow for the following keywords:</p><ul><li><code>i=10</code> How many points to interpolate the trajectory in-between steps to find candidate crossing regions.</li><li><code>m=10.0</code> A multiplier. If the trajectory is at least <code>m*ε</code> distance away from <code>u0</code>, the algorithm that checks for crossings of the <code>ε</code>-set is not initiated.</li></ul><p>For continuous systems <code>T, i, m</code> can be vectors with same size as <code>εs</code>, to help increase accuracy of small <code>ε</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ChaosTools.exit_entry_times" href="#ChaosTools.exit_entry_times"><code>ChaosTools.exit_entry_times</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">exit_entry_times(dds, u₀, εs, T) → exits, entries</code></pre><p>Collect exit and entry times for a ball/box centered at <code>u₀</code> with radii <code>εs</code> (see below), in the state space of the given discrete dynamical system (function not yet available for continuous systems). Return the exit and (re-)entry return times to the set(s), where each of these is a vector containing all collected times for the respective <code>ε</code>-radius set, for <code>ε ∈ εs</code>.</p><p>Use <code>transit_return(exits, entries)</code> to transform the output into transit and return times, and see also <a href="#ChaosTools.mean_return_times"><code>mean_return_times</code></a> for both continuous and discrete systems.</p><p><strong>Description</strong></p><p>Transit time statistics are important for the transport properties of dynamical systems<sup class="footnote-reference"><a id="citeref-Meiss1997" href="#footnote-Meiss1997">[Meiss1997]</a></sup> and can even be connected with the fractal dimension of chaotic sets<sup class="footnote-reference"><a id="citeref-Boev2014" href="#footnote-Boev2014">[Boev2014]</a></sup>.</p><p>The current algorithm collects exit and re-entry times to given sets in the state space, which are centered at <code>u₀</code> (<strong>algorithm always starts at <code>u₀</code></strong> and the initial state of <code>ds</code> is irrelevant). <code>εs</code> is always a <code>Vector</code>.</p><p>The sets around <code>u₀</code> are nested hyper-spheres of radius <code>ε ∈ εs</code>, if each entry of <code>εs</code> is a real number. The sets can also be hyper-rectangles (boxes), if each entry of <code>εs</code> is a vector itself. Then, the <code>i</code>-th box is defined by the space covered by <code>u0 .± εs[i]</code> (thus the actual box size is <code>2εs[i]</code>!).</p><p>The reason to input multiple <code>εs</code> at once is purely for performance.</p><p>For discrete systems, exit time is recorded immediatelly after exitting of the set, and re-entry is recorded immediatelly on re-entry. This means that if an orbit needs 1 step to leave the set and then it re-enters immediatelly on the next step, the return time is 1. For continuous systems high-order interpolation is done to accurately record the time of exactly crossing the <code>ε</code>-ball/box.</p></div></section></article><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-Schmelcher1997"><a class="tag is-link" href="#citeref-Schmelcher1997">Schmelcher1997</a>P. Schmelcher &amp; F. K. Diakonos, Phys. Rev. Lett. <strong>78</strong>, pp 4733 (1997)</li><li class="footnote" id="footnote-Pingel2000"><a class="tag is-link" href="#citeref-Pingel2000">Pingel2000</a>D. Pingel <em>et al.</em>, Phys. Rev. E <strong>62</strong>, pp 2119 (2000)</li><li class="footnote" id="footnote-Diakonos1998"><a class="tag is-link" href="#citeref-Diakonos1998">Diakonos1998</a>F. K. Diakonos <em>et al.</em>, Phys. Rev. Lett. <strong>81</strong>, pp 4349 (1998)</li><li class="footnote" id="footnote-Meiss1997"><a class="tag is-link" href="#citeref-Meiss1997">Meiss1997</a>Meiss, J. D. <em>Average exit time for volume-preserving maps</em>, Chaos (1997)](https://doi.org/10.1063/1.166245)</li><li class="footnote" id="footnote-Boev2014"><a class="tag is-link" href="#citeref-Boev2014">Boev2014</a>Boev, Vadivasova, &amp; Anishchenko, <em>Poincaré recurrence statistics as an indicator of chaos synchronization</em>, Chaos (2014)](https://doi.org/10.1063/1.4873721)</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../nlts/">« Nonlinear Timeseries Analysis</a><a class="docs-footer-nextpage" href="../choosing/">Choosing a solver »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 27 March 2021 18:28">Saturday 27 March 2021</span>. Using Julia version 1.6.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
