<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Traditional Optimal Embedding ¬∑ DynamicalSystems.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/logo.ico" rel="icon" type="image/x-icon"/><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="DynamicalSystems.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">DynamicalSystems.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../../contents/">Contents</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Dynamical systems</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../ds/general/">Dynamical System Definition</a></li><li><a class="tocitem" href="../../ds/predefined/">Predefined Dynamical Systems</a></li><li><a class="tocitem" href="../dataset/">Numerical Data</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Entropies</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../entropies/api/">Entropies &amp; Probabilities</a></li><li><a class="tocitem" href="../../entropies/estimators/">Probabilities Estimators</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox" checked/><label class="tocitem" for="menuitem-5"><span class="docs-label">DelayEmbeddings</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../reconstruction/">Delay Coordinates Embedding</a></li><li class="is-active"><a class="tocitem" href>Traditional Optimal Embedding</a><ul class="internal"><li><a class="tocitem" href="#Optimal-delay-time"><span>Optimal delay time</span></a></li><li><a class="tocitem" href="#Optimal-embedding-dimension"><span>Optimal embedding dimension</span></a></li><li><a class="tocitem" href="#Example"><span>Example</span></a></li></ul></li><li><a class="tocitem" href="../unified/">Unified Optimal Embedding</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">ChaosTools</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../chaos/orbitdiagram/">Orbit Diagrams &amp; PSOS</a></li><li><a class="tocitem" href="../../chaos/lyapunovs/">Lyapunov Exponents</a></li><li><a class="tocitem" href="../../chaos/chaos_detection/">Detecting &amp; Categorizing Chaos</a></li><li><a class="tocitem" href="../../chaos/fractaldim/">Fractal Dimension</a></li><li><a class="tocitem" href="../../chaos/nlts/">Nonlinear Timeseries Analysis</a></li><li><a class="tocitem" href="../../chaos/periodicity/">Periodicity &amp; Ergodicity</a></li><li><a class="tocitem" href="../../chaos/choosing/">Choosing a solver</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">RecurrenceAnalysis</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../rqa/rplots/">Recurrence Plots</a></li><li><a class="tocitem" href="../../rqa/quantification/">Recurrence Quantification Analysis</a></li><li><a class="tocitem" href="../../rqa/windowed/">Windowed RQA</a></li><li><a class="tocitem" href="../../rqa/networks/">Recurrence Network Analysis</a></li></ul></li><li><a class="tocitem" href="../../advanced/">Advanced Documentation</a></li><li><a class="tocitem" href="../../contributors_guide/">Contributor Guide</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">DelayEmbeddings</a></li><li class="is-active"><a href>Traditional Optimal Embedding</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Traditional Optimal Embedding</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDynamics/DynamicalSystems.jl/blob/master/docs/src/embedding/traditional.md" title="Edit on GitHub"><span class="docs-icon fab">ÔÇõ</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Traditional-Optimal-Embedding"><a class="docs-heading-anchor" href="#Traditional-Optimal-Embedding">Traditional Optimal Embedding</a><a id="Traditional-Optimal-Embedding-1"></a><a class="docs-heading-anchor-permalink" href="#Traditional-Optimal-Embedding" title="Permalink"></a></h1><p>This page discusses and provides algorithms for estimating optimal parameters to do Delay Coordinates Embedding (DCE) with.</p><p>The approaches can be grouped into two schools:</p><ol><li><strong>Traditional</strong>, where one tries to find the best value for a delay time <code>œÑ</code> and then an optimal embedding dimension <code>d</code>.</li><li><strong>Unified</strong>, where at the same time an optimal combination of <code>œÑ, d</code> is found, and is discussed in the <a href="../unified/#Unified-Optimal-Embedding">Unified Optimal Embedding</a> page.</li></ol><p>The independent approach is something &quot;old school&quot;, while recent scientific research has shifted almost exclusively to unified approaches.</p><h2 id="Optimal-delay-time"><a class="docs-heading-anchor" href="#Optimal-delay-time">Optimal delay time</a><a id="Optimal-delay-time-1"></a><a class="docs-heading-anchor-permalink" href="#Optimal-delay-time" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DelayEmbeddings.estimate_delay" href="#DelayEmbeddings.estimate_delay"><code>DelayEmbeddings.estimate_delay</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">estimate_delay(s, method::String [, œÑs = 1:100]; kwargs...) -&gt; œÑ</code></pre><p>Estimate an optimal delay to be used in <a href="../reconstruction/#DelayEmbeddings.embed"><code>embed</code></a>. The <code>method</code> can be one of the following:</p><ul><li><code>&quot;ac_zero&quot;</code> : first delay at which the auto-correlation function becomes &lt;0.</li><li><code>&quot;ac_min&quot;</code> : delay of first minimum of the auto-correlation function.</li><li><code>&quot;mi_min&quot;</code> : delay of first minimum of mutual information of <code>s</code> with itself (shifted for various <code>œÑs</code>). Keywords <code>nbins, binwidth</code> are propagated into <a href="#DelayEmbeddings.selfmutualinfo"><code>selfmutualinfo</code></a>.</li><li><code>&quot;exp_decay&quot;</code> : <a href="#DelayEmbeddings.exponential_decay_fit"><code>exponential_decay_fit</code></a> of the correlation function rounded  to an integer (uses least squares on <code>c(t) = exp(-t/œÑ)</code> to find <code>œÑ</code>).</li><li><code>&quot;exp_extrema&quot;</code> : same as above but the exponential fit is done to the absolute value of the local extrema of the correlation function.</li></ul><p>Both the mutual information and correlation function (<code>autocor</code>) are computed <em>only</em> for delays <code>œÑs</code>. This means that the <code>min</code> methods can never return the first value of <code>œÑs</code>!</p><p>The method <code>mi_min</code> is significantly more accurate than the others and also returns good results for most timeseries. It is however the slowest method (but still quite fast!).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="DelayEmbeddings.exponential_decay_fit" href="#DelayEmbeddings.exponential_decay_fit"><code>DelayEmbeddings.exponential_decay_fit</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">exponential_decay_fit(x, y, weight = :equal) -&gt; œÑ</code></pre><p>Perform a least square fit of the form <code>y = exp(-x/œÑ)</code> and return <code>œÑ</code>. Taken from:  http://mathworld.wolfram.com/LeastSquaresFittingExponential.html. Assumes equal lengths of <code>x, y</code> and that <code>y ‚â• 0</code>.</p><p>To use the method that gives more weight to small values of <code>y</code>, use <code>weight = :small</code>.</p></div></section></article><h3 id="Self-Mutual-Information"><a class="docs-heading-anchor" href="#Self-Mutual-Information">Self Mutual Information</a><a id="Self-Mutual-Information-1"></a><a class="docs-heading-anchor-permalink" href="#Self-Mutual-Information" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="DelayEmbeddings.selfmutualinfo" href="#DelayEmbeddings.selfmutualinfo"><code>DelayEmbeddings.selfmutualinfo</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">selfmutualinfo(s, œÑs; kwargs...) ‚Üí m</code></pre><p>Calculate the mutual information between the time series <code>s</code> and itself delayed by <code>œÑ</code> points for <code>œÑ</code> ‚àà <code>œÑs</code>, using an <em>improvement</em> of the method outlined by Fraser &amp; Swinney in<sup class="footnote-reference"><a id="citeref-Fraser1986" href="#footnote-Fraser1986">[Fraser1986]</a></sup>.</p><p><strong>Description</strong></p><p>The joint space of <code>s</code> and its <code>œÑ</code>-delayed image (<code>sœÑ</code>) is partitioned as a rectangular grid, and the mutual information is computed from the joint and marginal frequencies of <code>s</code> and <code>sœÑ</code> in the grid as defined in [1]. The mutual information values are returned in a vector <code>m</code> of the same length as <code>œÑs</code>.</p><p>If any of the optional keyword parameters is given, the grid will be a homogeneous partition of the space where <code>s</code> and <code>sœÑ</code> are defined. The margins of that partition will be divided in a number of bins equal to <code>nbins</code>, such that the width of each bin will be <code>binwidth</code>, and the range of nonzero values of <code>s</code> will be in the centre. If only of those two parameters is given, the other will be automatically calculated to adjust the size of the grid to the area where <code>s</code> and <code>sœÑ</code> are nonzero.</p><p>If no parameter is given, the space will be partitioned by a recursive bisection algorithm based on the method given in [1].</p><p>Notice that the recursive method of [1] evaluates the joint frequencies of <code>s</code> and <code>sœÑ</code> in each cell resulting from a partition, and stops when the data points are uniformly distributed across the sub-partitions of the following levels. For performance and stability reasons, the automatic partition method implemented in this function is only used to divide the axes of the grid, using the marginal frequencies of <code>s</code>.</p></div></section></article><p>Notice that mutual information between two <em>different</em> timeseries x, y exists in JuliaDynamics as well, but in the package <a href="https://github.com/JuliaDynamics/TransferEntropy.jl">TransferEntropy.jl</a>. It is also trivial to define it yourself using <a href="../../entropies/api/#Entropies.genentropy"><code>genentropy</code></a> by doing</p><pre><code class="language-julia">function mutualinfo(x, y, est; base = 2, Œ± = 1)
    X = genentropy(Dataset(x), est; base = base, Œ± = Œ±)
    Y = genentropy(Dataset(y), est; base = base, Œ± = Œ±)
    XY = genentropy(Dataset(x, y), est; base = base, Œ± = Œ±)
    return X + Y - XY
end</code></pre><h2 id="Optimal-embedding-dimension"><a class="docs-heading-anchor" href="#Optimal-embedding-dimension">Optimal embedding dimension</a><a id="Optimal-embedding-dimension-1"></a><a class="docs-heading-anchor-permalink" href="#Optimal-embedding-dimension" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DelayEmbeddings.optimal_traditional_de" href="#DelayEmbeddings.optimal_traditional_de"><code>DelayEmbeddings.optimal_traditional_de</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">optimal_traditional_de(s, method = &quot;afnn&quot;, dmethod = &quot;mi_min&quot;; kwargs...) ‚Üí ùíü, œÑ, E</code></pre><p>Produce an optimal delay embedding <code>ùíü</code> of the given timeseries <code>s</code> by using the traditional approach of first finding an optimal (and constant) delay time using <a href="#DelayEmbeddings.estimate_delay"><code>estimate_delay</code></a> with the given <code>dmethod</code>, and then an optimal embedding dimension, by calculating an appropriate statistic for each dimension <code>d ‚àà 1:dmax</code>. Return the embedding <code>ùíü</code>, the optimal delay time <code>œÑ</code> (the optimal embedding dimension <code>d</code> is just <code>size(ùíü, 2)</code>) and the actual statistic <code>E</code> used to estimate optimal <code>d</code>.</p><p>Notice that <code>E</code> is a function of the embedding dimension, which ranges from 1 to <code>dmax</code>.</p><p>For calculating <code>E</code> to estimate the dimension we use the given <code>method</code> which can be:</p><ul><li><code>&quot;afnn&quot;</code> (default) is Cao&#39;s &quot;Averaged False Nearest Neighbors&quot; method<sup class="footnote-reference"><a id="citeref-Cao1997" href="#footnote-Cao1997">[Cao1997]</a></sup>,   which gives a ratio of distances between nearest neighbors.</li><li><code>&quot;ifnn&quot;</code> is the &quot;Improved False Nearest Neighbors&quot; from Hegger &amp; Kantz<sup class="footnote-reference"><a id="citeref-Hegger1999" href="#footnote-Hegger1999">[Hegger1999]</a></sup>,   which gives the fraction of false nearest neighbors.</li><li><code>&quot;fnn&quot;</code> is Kennel&#39;s &quot;False Nearest Neighbors&quot; method<sup class="footnote-reference"><a id="citeref-Kennel1992" href="#footnote-Kennel1992">[Kennel1992]</a></sup>, which gives   the number of points that cease to be &quot;nearest neighbors&quot; when the dimension   increases.</li><li><code>&quot;f1nn&quot;</code> is Krakovsk√°&#39;s &quot;False First Nearest Neighbors&quot; method<sup class="footnote-reference"><a id="citeref-Krakovsk√°2015" href="#footnote-Krakovsk√°2015">[Krakovsk√°2015]</a></sup>,   which gives the ratio of pairs of points that cease to be &quot;nearest neighbors&quot;   when the dimension increases.</li></ul><p>For more details, see individual methods: <a href="#DelayEmbeddings.delay_afnn"><code>delay_afnn</code></a>, <a href="#DelayEmbeddings.delay_ifnn"><code>delay_ifnn</code></a>, <a href="#DelayEmbeddings.delay_fnn"><code>delay_fnn</code></a>, <a href="#DelayEmbeddings.delay_f1nn"><code>delay_f1nn</code></a>. The special keywords `` denote for which possible embedding dimensions should the statistics be computed for.</p><div class="admonition is-category-warn"><header class="admonition-header">Careful in automated methods</header><div class="admonition-body"><p>While this method is automated if you want to be <strong>really sure</strong> of the results, you should directly calculate the statistic and plot its values versus the dimensions.</p></div></div><p><strong>Keywords</strong></p><p>The keywords</p><pre><code class="language-none">œÑs = 1:100, dmax = 10</code></pre><p>denote which delay times and embedding dimensions <code>ds ‚àà 1:dmax</code> to consider when calculating optimal embedding. All remaining keywords are propagated to the low level functions:</p><pre><code class="language-none">fnn_thres::Real = 0.05, slope_thres::Real= 0.2, w::Int=1,
rtol=10.0, atol=2.0, œÑs = 1:100, metric = Euclidean(), r::Real=2.0,
stoch_thres = 0.1</code></pre><p><strong>Description</strong></p><p>We estimate the optimal embedding dimension based on the given delay time gained from <code>dmethod</code> as follows: For Cao&#39;s method the optimal dimension is reached, when the slope of the <code>E‚ÇÅ</code>-statistic (output from <code>&quot;afnn&quot;</code>) falls below the threshold <code>slope_thres</code> (default is .05) and the according stochastic test turns out to be false, i.e. if the <code>E‚ÇÇ</code>-statistic&#39;s first value is <code>&lt; 1 - stoch_thres</code>.</p><p>For all the other methods we return the optimal embedding dimension when the corresponding FNN-statistic (output from <code>&quot;ifnn&quot;</code>, <code>&quot;fnn&quot;</code> or <code>&quot;f1nn&quot;</code>) falls below the fnn-threshold <code>fnn_thres</code> (Default is .05) AND the slope of the statistic falls below the threshold <code>slope_thres</code>. Note that with noise contaminated time series, one might need to adjust <code>fnn_thres</code> according to the noise level.</p><p>See also the file <code>test/compare_different_dimension_estimations.jl</code> for a comparison.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="DelayEmbeddings.delay_afnn" href="#DelayEmbeddings.delay_afnn"><code>DelayEmbeddings.delay_afnn</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">delay_afnn(s::AbstractVector, œÑ:Int, ds = 2:6; metric=Euclidean(), w = 0) ‚Üí E‚ÇÅ</code></pre><p>Compute the parameter E‚ÇÅ of Cao&#39;s &quot;averaged false nearest neighbors&quot; method for determining the minimum embedding dimension of the time series <code>s</code>, with a sequence of <code>œÑ</code>-delayed temporal neighbors.</p><p><strong>Description</strong></p><p>Given the scalar timeseries <code>s</code> and the embedding delay <code>œÑ</code> compute the values of <code>E‚ÇÅ</code> for each embedding dimension <code>d ‚àà ds</code>, according to Cao&#39;s Method (eq. 3 of<sup class="footnote-reference"><a id="citeref-Cao1997" href="#footnote-Cao1997">[Cao1997]</a></sup>).</p><p>This quantity is a ratio of the averaged distances between the nearest neighbors of the reconstructed time series, which quantifies the increment of those distances when the embedding dimension changes from <code>d</code> to <code>d+1</code>.</p><p>Return the vector of all computed <code>E‚ÇÅ</code>s. To estimate a good value for <code>d</code> from this, find <code>d</code> for which the value <code>E‚ÇÅ</code> saturates at some value around 1.</p><p><em>Note: This method does not work for datasets with perfectly periodic signals.</em></p><p><code>w</code> is the <a href="../dataset/#Theiler-window">Theiler window</a>.</p><p>See also: <a href="#DelayEmbeddings.optimal_traditional_de"><code>optimal_traditional_de</code></a> and <a href="#DelayEmbeddings.stochastic_indicator"><code>stochastic_indicator</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="DelayEmbeddings.delay_ifnn" href="#DelayEmbeddings.delay_ifnn"><code>DelayEmbeddings.delay_ifnn</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">delay_ifnn(s::Vector, œÑ::Int, ds = 1:10; kwargs...) ‚Üí `FNNs`</code></pre><p>Compute and return the <code>FNNs</code>-statistic for the time series <code>s</code> and a uniform time delay <code>œÑ</code> and embedding dimensions <code>ds</code> after <sup class="footnote-reference"><a id="citeref-Hegger1999" href="#footnote-Hegger1999">[Hegger1999]</a></sup>. In this notation <code>Œ≥ ‚àà Œ≥s = d-1</code>, if <code>d</code> is the embedding dimension. This fraction tends to 0 when the optimal embedding dimension with an appropriate lag is reached.</p><p><strong>Keywords</strong></p><p>*<code>r = 2</code>: Obligatory threshold, which determines the maximum tolerable spreading     of trajectories in the reconstruction space. *<code>metric = Euclidean</code>: The norm used for distance computations. *<code>w = 1</code> = The <a href="../dataset/#Theiler-window">Theiler window</a>.</p><p>See also: <a href="#DelayEmbeddings.optimal_traditional_de"><code>optimal_traditional_de</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="DelayEmbeddings.delay_fnn" href="#DelayEmbeddings.delay_fnn"><code>DelayEmbeddings.delay_fnn</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">delay_fnn(s::AbstractVector, œÑ:Int, ds = 2:6; rtol=10.0, atol=2.0) ‚Üí FNNs</code></pre><p>Calculate the number of &quot;false nearest neighbors&quot; (FNNs) of the datasets created from <code>s</code> with <code>embed(s, d, œÑ) for d ‚àà ds</code>.</p><p><strong>Description</strong></p><p>Given a dataset made by <code>embed(s, d, œÑ)</code> the &quot;false nearest neighbors&quot; (FNN) are the pairs of points that are nearest to each other at dimension <code>d</code>, but are separated at dimension <code>d+1</code>. Kennel&#39;s criteria for detecting FNN are based on a threshold for the relative increment of the distance between the nearest neighbors (<code>rtol</code>, eq. 4 in<sup class="footnote-reference"><a id="citeref-Kennel1992" href="#footnote-Kennel1992">[Kennel1992]</a></sup>), and another threshold for the ratio between the increased distance and the &quot;size of the attractor&quot; (<code>atol</code>, eq. 5 in<sup class="footnote-reference"><a id="citeref-Kennel1992" href="#footnote-Kennel1992">[Kennel1992]</a></sup>). These thresholds are given as keyword arguments.</p><p>The returned value is a vector with the number of FNN for each <code>Œ≥ ‚àà Œ≥s</code>. The optimal value for <code>Œ≥</code> is found at the point where the number of FNN approaches zero.</p><p>See also: <a href="#DelayEmbeddings.optimal_traditional_de"><code>optimal_traditional_de</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="DelayEmbeddings.delay_f1nn" href="#DelayEmbeddings.delay_f1nn"><code>DelayEmbeddings.delay_f1nn</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">delay_f1nn(s::AbstractVector, œÑ::Int, ds = 2:6, metric = Euclidean())</code></pre><p>Calculate the ratio of &quot;false first nearest neighbors&quot; (FFNN) of the datasets created from <code>s</code> with <code>embed(s, d, œÑ) for d ‚àà ds</code>.</p><p><strong>Description</strong></p><p>Given a dataset made by <code>embed(s, d, œÑ)</code> the &quot;false first nearest neighbors&quot; (FFNN) are the pairs of points that are nearest to each other at dimension <code>d</code> that cease to be nearest neighbors at dimension <code>d+1</code>.</p><p>The returned value is a vector with the ratio between the number of FFNN and the number of points in the dataset for each <code>d ‚àà ds</code>. The optimal value for <code>d</code> is found at the point where this ratio approaches zero.</p><p>See also: <a href="#DelayEmbeddings.optimal_traditional_de"><code>optimal_traditional_de</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="DelayEmbeddings.stochastic_indicator" href="#DelayEmbeddings.stochastic_indicator"><code>DelayEmbeddings.stochastic_indicator</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">stochastic_indicator(s::AbstractVector, œÑ:Int, ds = 2:5) -&gt; E‚ÇÇs</code></pre><p>Compute an estimator for apparent randomness in a delay embedding with <code>ds</code> dimensions.</p><p><strong>Description</strong></p><p>Given the scalar timeseries <code>s</code> and the embedding delay <code>œÑ</code> compute the values of <code>E‚ÇÇ</code> for each <code>d ‚àà ds</code>, according to Cao&#39;s Method (eq. 5 of <sup class="footnote-reference"><a id="citeref-Cao1997" href="#footnote-Cao1997">[Cao1997]</a></sup>).</p><p>Use this function to confirm that the input signal is not random and validate the results of <a href="embedding/@ref"><code>estimate_dimension</code></a>. In the case of random signals, it should be <code>E‚ÇÇ ‚âà 1 ‚àÄ d</code>.</p></div></section></article><h2 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h2><pre><code class="language-julia">using DynamicalSystems, PyPlot

ds = Systems.roessler()
# This trajectory is a chaotic attractor with fractal dim ‚âà 2
# therefore the set needs at least embedding dimension of 3
tr = trajectory(ds, 1000.0; dt = 0.05)
x = tr[:, 1]

dmax = 7
fig = figure()
for (i, method) in enumerate([&quot;afnn&quot;, &quot;fnn&quot;, &quot;f1nn&quot;, &quot;ifnn&quot;])
    # Plot statistic used to estimate optimal embedding
    # as well as the automated output embedding
    ùíü, œÑ, E = optimal_traditional_de(x, method; dmax)
    plot(1:dmax, E; label = method, marker = &quot;o&quot;, ms = 5, color = &quot;C$(i-1)&quot;)
    optimal_d = size(ùíü, 2)
    scatter(optimal_d, E[optimal_d]; marker = &quot;s&quot;, s = 100, color = &quot;C$(i-1)&quot;)
end
legend(); xlabel(&quot;embedding dimension&quot;)
ylabel(&quot;estimator&quot;)
tight_layout()</code></pre><pre class="documenter-example-output">Algorithm stopped due to convergence of E‚ÇÅ-statistic. Valid embedding achieved ‚úì.
Algorithm stopped due to sufficiently small FNNs. Valid embedding achieved ‚úì.
Sufficiently small FNNs NOT reached. Valid embedding NOT achieved ‚®â.
Algorithm stopped due to sufficiently small FNNs. Valid embedding achieved ‚úì.</pre><p><img src="../estimateD.png" alt/></p><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-Fraser1986"><a class="tag is-link" href="#citeref-Fraser1986">Fraser1986</a>Fraser A.M. &amp; Swinney H.L. &quot;Independent coordinates for strange attractors from mutual information&quot; <em>Phys. Rev. A 33</em>(2), 1986, 1134:1140.</li><li class="footnote" id="footnote-Cao1997"><a class="tag is-link" href="#citeref-Cao1997">Cao1997</a>Liangyue Cao, <a href="https://www.sciencedirect.com/science/article/pii/S0167278997001188?via%3Dihub">Physica D, pp. 43-50 (1997)</a></li><li class="footnote" id="footnote-Kennel1992"><a class="tag is-link" href="#citeref-Kennel1992">Kennel1992</a>M. Kennel <em>et al.</em>, <a href="https://journals.aps.org/pra/abstract/10.1103/PhysRevA.45.3403">Phys. Review A <strong>45</strong>(6), (1992)</a>.</li><li class="footnote" id="footnote-Krakovsk√°2015"><a class="tag is-link" href="#citeref-Krakovsk√°2015">Krakovsk√°2015</a>Anna Krakovsk√° <em>et al.</em>, <a href="https://doi.org/10.1155/2015/932750">J. Complex Sys. 932750 (2015)</a></li><li class="footnote" id="footnote-Hegger1999"><a class="tag is-link" href="#citeref-Hegger1999">Hegger1999</a>Hegger &amp; Kantz, <a href="https://doi.org/10.1103/PhysRevE.60.4970">Improved false nearest neighbor method to detect determinism in time series data. Physical Review E 60, 4970</a>.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../reconstruction/">¬´ Delay Coordinates Embedding</a><a class="docs-footer-nextpage" href="../unified/">Unified Optimal Embedding ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 27 March 2021 18:28">Saturday 27 March 2021</span>. Using Julia version 1.6.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
