var documenterSearchIndex = {"docs":
[{"location":"visualizations/#visualizations","page":"Animations, GUIs, Visuals","title":"Interactive GUIs, animations, visualizations","text":"","category":"section"},{"location":"visualizations/","page":"Animations, GUIs, Visuals","title":"Animations, GUIs, Visuals","text":"Using the functionality of package extensions in Julia v1.9+, DynamicalSystems.jl provides various visualization tools as soon as the Makie package comes into scope (i.e., when using Makie or any of its backends like GLMakie).","category":"page"},{"location":"visualizations/","page":"Animations, GUIs, Visuals","title":"Animations, GUIs, Visuals","text":"The main functionality is interactive_trajectory that allows building custom GUI apps for visualizing the time evolution of dynamical systems. The remaining GUI applications in this page are dedicated to more specialized scenarios.","category":"page"},{"location":"visualizations/#Interactive-or-animated-trajectory-evolution","page":"Animations, GUIs, Visuals","title":"Interactive- or animated trajectory evolution","text":"","category":"section"},{"location":"visualizations/","page":"Animations, GUIs, Visuals","title":"Animations, GUIs, Visuals","text":"The following GUI is obtained with the function interactive_trajectory_timeseries and the code snippet below it!","category":"page"},{"location":"visualizations/","page":"Animations, GUIs, Visuals","title":"Animations, GUIs, Visuals","text":"<video width=\"100%\" height=\"auto\" controls autoplay loop>\n<source src=\"https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/interact/interactive_trajectory.mp4?raw=true\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"visualizations/","page":"Animations, GUIs, Visuals","title":"Animations, GUIs, Visuals","text":"using DynamicalSystems\nstruct ShowFile\n    file::String\nend\nfunction Base.show(io::IO, ::MIME\"text/plain\", f::ShowFile)\n    write(io, read(f.file))\nend","category":"page"},{"location":"visualizations/","page":"Animations, GUIs, Visuals","title":"Animations, GUIs, Visuals","text":"ShowFile(joinpath(dirname(pathof(DynamicalSystems)), \"../test/mtk_gui.jl\")) # hide","category":"page"},{"location":"visualizations/","page":"Animations, GUIs, Visuals","title":"Animations, GUIs, Visuals","text":"interactive_trajectory_timeseries\ninteractive_trajectory","category":"page"},{"location":"visualizations/#DynamicalSystems.interactive_trajectory_timeseries","page":"Animations, GUIs, Visuals","title":"DynamicalSystems.interactive_trajectory_timeseries","text":"interactive_trajectory_timeseries(ds::DynamicalSystem, fs, [, u0s]; kwargs...) → fig, dsobs\n\nCreate a Makie Figure to visualize trajectories and timeseries of observables of ds. This Figure can also be used as an interactive GUI to enable interactive control over parameters and time evolution. It can also be used to create videos, as well as customized animations, see below.\n\nfs is a Vector of \"indices to observe\", i.e., anything that can be given to observe_state. Each observation index will make a timeseries plot. u0s is a Vector of initial conditions. Each is evolved with a unique color and displayed both as a trajectory in state space and as an observed timeseries. Elements of u0 can be either Vector{Real} encoding a full state or Dict to partially set a state from current state of ds (same as in set_state!).\n\nThe trajectories from the initial conditions in u0s are all evolved and visualized in parallel. By default only the current state of the system is used. u0s can be anything accepted by a ParallelDynamicalSystem.\n\nReturn\n\nReturn fig, dsobs::DynamicalSystemObservable. fig is the created Figure. dsobs facilities the creation of custom animations and/or interactive applications, see the custom animations section below.\n\nSee also interactive_trajectory.\n\nInteractivity and time stepping keywords\n\nGUI functionality is possible when the plotting backend is GLMakie. Do using GLMakie; GLMakie.activate!() to ensure this is the chosen backend.\n\nadd_controls = true: If true, below the state space axis some buttons for animating the trajectories live are added:\nreset: results the parallel trajectories to their initial conditions\nrun: when clicked it evolves the trajectories forwards in time indefinitely. click again to stop the evolution.\nstep: when clicked it evolves the trajectories forwards in time for the amount of steps chosen by the slider to its right.\nThe plotted trajectories can always be evolved manually using the custom animations etup that we describe below; add_controls only concerns the buttons and interactivity added to the created figure.\nparameter_sliders = nothing: If given, it must be a dictionary, mapping parameter indices (any valid index that can be given to set_parameter!) to ranges of parameter values. Each combination of index and range becomes a slider that can be interactively controlled to alter a system parameter on the fly during time evolution. Below the parameter sliders, three buttons are added for GUI usage:\nupdate: when clicked the chosen parameter values are propagated into the system\nu.r.s.: when clicked it is equivalent with clicking in order: \"update\", \"reset\", \"step\".\nreset p: when clicked it resets\nParameters can also be altered using the custom animation setup that we describe below; parameter_sliders only conserns the buttons and interactivity added to the created figure.\nparameter_names = Dict(keys(ps) .=> string.(keys(ps))): Dictionary mapping parameter keys to labels. Only used if parameter_sliders is given.\nΔt: Time step of time evolution. Defaults to 1 for discrete time, 0.01 for continuous time systems. For internal simplicity, continuous time dynamical systems are evolved non-adaptively with constant step size equal to Δt.\npause = nothing: If given, it must be a real number. This number is given to the sleep function, which is called between each plot update. Useful when time integration is computationally inexpensive and animation proceeds too fast.\nstarting_step = 1: the starting value of the \"step\" slider.\n\nVisualization keywords\n\ncolors: The color for each initial condition (and resulting trajectory and timeseries). Needs to be a Vector of equal length as u0s.\ntail = 1000: Length of plotted trajectory (in units of Δt).\nfade = 0.5: The trajectories in state space are faded towards full transparency. The alpha channel (transparency) scales as t^fade with t ranging from 0 to 1 (1 being the end of the trajectory). Use fade = 1.0 for linear fading or fade = 0 for no fading. Current default makes fading progress faster at trajectory start and slower at trajectory end.\nmarkersize = 15: Size of markers of trajectory endpoints. For discrete systems half of that is used for the trajectory tail.\nplotkwargs = NamedTuple(): A named tuple of keyword arguments propagated to the state space plot (lines for continuous, scatter for discrete systems). plotkwargs can also be a vector of named tuples, in which case each initial condition gets different arguments.\n\nStatespace trajectory keywords\n\nidxs = 1:min(length(u0s[1]), 3): Which variables to plot in a state space trajectory. Any index that can be given to observe_state can be given here.\nstatespace_axis = true: Whether to create and display an axis for the trajectory plot.\nidxs = 1:min(length(u0s[1]), 3): Which variables to plot in a state space trajectory. Any index that can be given to observe_state can be given here. If three indices are given, the trajectory plot is also 3D, otherwise 2D.\nlims: A tuple of tuples (min, max) for the axis limits. If not given, they are automatically deduced by evolving each of u0s 1000 Δt units and picking most extreme values (limits are not adjusted by default during the live animations).\nfigure, axis: both can be named tuples with arbitrary keywords propagated to the generation of the Figure and state space Axis instances.\n\nTimeseries keywords\n\nlinekwargs = NamedTuple(): Extra keywords propagated to the timeseries plots. Can also be a vector of named tuples, each one for each unique initial condition.\ntimeseries_names: A vector of strings with length equal to fs giving names to the y-labels of the timeseries plots.\ntimeseries_ylims: A vector of 2-tuples for the lower and upper limits of the y-axis of each timeseries plot. If not given it is deduced automatically similarly to lims.\ntimeunit = 1: the units of time, if any. Sets the units of the timeseries x-axis.\ntimelabel = \"time\": label of the x-axis of the timeseries plots.\n\nCustom animations\n\nThe second return argument dsobs is a DynamicalSystemObservable. The trajectories plotted in the main panel are linked to observables that are fields of the dsobs. Specifically, the field dsobs.state_obserable is an observable containing the final state of each of the trajectories, i.e., a vector of vectors like u0s. dsobs.param_observable is an observable of the system parameters. These observables are triggered by the interactive GUI buttons (the first two when the system is stepped in time, the last one when the parameters are updated). However, these observables, and hence the corresponding plotted trajectories that are maped from these observables, can be updated via the formal API of DynamicalSystem:\n\nstep!(dsobs, n::Int = 1)\n\nwill step the system for n steps of Δt time, and only update the plot on the last step. set_parameter!(dsobs, index, value) will update the system parameter and then trigger the parameter observable. Lastly, set_state!(dsobs, new_u [, i]) will set the i-th system state and clear the trajectory plot to the new initial condition.\n\nThis information can be used to create custom animations and/or interactive apps. In principle, the only thing a user has to do is create new observables from the existing ones using e.g. the on function and plot these new observables. Various examples are provided in the online documentation.\n\n\n\n\n\n","category":"function"},{"location":"visualizations/#DynamicalSystems.interactive_trajectory","page":"Animations, GUIs, Visuals","title":"DynamicalSystems.interactive_trajectory","text":"interactive_trajectory(ds::DynamicalSystem [, u0s]; kwargs...) → fig, dsobs\n\nSame as interactive_trajectory_timeseries, but does not plot any timeseries only the trajectory in a (projected) state space.\n\n\n\n\n\n","category":"function"},{"location":"visualizations/#Example-1:-interactive-trajectory-animation","page":"Animations, GUIs, Visuals","title":"Example 1: interactive trajectory animation","text":"","category":"section"},{"location":"visualizations/","page":"Animations, GUIs, Visuals","title":"Animations, GUIs, Visuals","text":"using DynamicalSystems, CairoMakie\nF, G, a, b = 6.886, 1.347, 0.255, 4.0\nds = PredefinedDynamicalSystems.lorenz84(; F, G, a, b)\n\nu1 = [0.1, 0.1, 0.1] # periodic\nu2 = u1 .+ 1e-3     # fixed point\nu3 = [-1.5, 1.2, 1.3] .+ 1e-9 # chaotic\nu4 = [-1.5, 1.2, 1.3] .+ 21e-9 # chaotic 2\nu0s = [u1, u2, u3, u4]\n\nfig, dsobs = interactive_trajectory(\n    ds, u0s; tail = 1000, fade = true,\n    idxs = [1,3],\n)\n\nfig","category":"page"},{"location":"visualizations/","page":"Animations, GUIs, Visuals","title":"Animations, GUIs, Visuals","text":"We could interact with this plot live, like in the example video above. We can also progress the visuals via code as instructed by interactive_trajectory utilizing the second returned argument dsobs:","category":"page"},{"location":"visualizations/","page":"Animations, GUIs, Visuals","title":"Animations, GUIs, Visuals","text":"step!(dsobs, 2000)\nfig","category":"page"},{"location":"visualizations/","page":"Animations, GUIs, Visuals","title":"Animations, GUIs, Visuals","text":"(if you progress the visuals via code you probably want to give add_controls = false as a keyword to interactive_trajectory)","category":"page"},{"location":"visualizations/#Example-2:-Adding-parameter-dependent-elements-to-a-plot","page":"Animations, GUIs, Visuals","title":"Example 2: Adding parameter-dependent elements to a plot","text":"","category":"section"},{"location":"visualizations/","page":"Animations, GUIs, Visuals","title":"Animations, GUIs, Visuals","text":"In this advanced example we add plot elements to the provided figure, and also utilize the parameter observable in dsobs to add animated plot elements that update whenever a parameter updates. The final product of this snippet is in fact the animation at the top of the docstring of interactive_trajectory_panel.","category":"page"},{"location":"visualizations/","page":"Animations, GUIs, Visuals","title":"Animations, GUIs, Visuals","text":"We start with an interactive trajectory panel of the Lorenz63 system, in which we also add sliders for interactively changing parameter values","category":"page"},{"location":"visualizations/","page":"Animations, GUIs, Visuals","title":"Animations, GUIs, Visuals","text":"using DynamicalSystems, CairoMakie\n\nps = Dict(\n    1 => 1:0.1:30,\n    2 => 10:0.1:50,\n    3 => 1:0.01:10.0,\n)\npnames = Dict(1 => \"σ\", 2 => \"ρ\", 3 => \"β\")\n\nlims = ((-30, 30), (-30, 30), (0, 100))\n\nds = PredefinedDynamicalSystems.lorenz()\n\nu1 = [10,20,40.0]\nu3 = [20,10,40.0]\nu0s = [u1, u3]\n\nfig, dsobs = interactive_trajectory(\n    ds, u0s; parameter_sliders = ps, pnames, lims\n)\n\nfig","category":"page"},{"location":"visualizations/","page":"Animations, GUIs, Visuals","title":"Animations, GUIs, Visuals","text":"If now one interactively clicked (if using GLMakie) the parameter sliders and then update, the system parameters would be updated accordingly. We can also add new plot elements that depend on the parameter values using the dsobs:","category":"page"},{"location":"visualizations/","page":"Animations, GUIs, Visuals","title":"Animations, GUIs, Visuals","text":"# Fixed points of the lorenz system (without the origin)\nlorenz_fixedpoints(ρ,β) = [\n    Point3f(sqrt(β*(ρ-1)), sqrt(β*(ρ-1)), ρ-1),\n    Point3f(-sqrt(β*(ρ-1)), -sqrt(β*(ρ-1)), ρ-1),\n]\n\n# add an observable trigger to the system parameters\nfpobs = map(dsobs.param_observable) do params\n    σ, ρ, β = params\n    return lorenz_fixedpoints(ρ, β)\nend\n\n# If we want to plot directly on the trajectory axis, we need to\n# extract it from the figure. The first entry of the figure is a grid layout\n# containing the axis and the GUI controls. The [1,1] entry of the layout\n# is the axis containing the trajectory plot\n\nax = content(fig[1,1][1,1])\nscatter!(ax, fpobs; markersize = 10, marker = :diamond, color = :red)\n\nfig","category":"page"},{"location":"visualizations/","page":"Animations, GUIs, Visuals","title":"Animations, GUIs, Visuals","text":"Now, after the live animation \"run\" button is pressed, we can interactively change the parameter ρ and click update, in which case both the dynamical system's ρ parameter will change, but also the location of the red diamonds.","category":"page"},{"location":"visualizations/","page":"Animations, GUIs, Visuals","title":"Animations, GUIs, Visuals","text":"We can also change the parameters non-interactively using set_parameter!","category":"page"},{"location":"visualizations/","page":"Animations, GUIs, Visuals","title":"Animations, GUIs, Visuals","text":"set_parameter!(dsobs, 2, 50.0)\n\nfig","category":"page"},{"location":"visualizations/","page":"Animations, GUIs, Visuals","title":"Animations, GUIs, Visuals","text":"set_parameter!(dsobs, 2, 10.0)\n\nfig","category":"page"},{"location":"visualizations/","page":"Animations, GUIs, Visuals","title":"Animations, GUIs, Visuals","text":"Note that the sliders themselves did not change, as this functionality is for \"offline\" creation of animations where one doesn't interact with sliders. The keyword add_controls should be given as false in such scenarios.","category":"page"},{"location":"visualizations/#Example-3:-Observed-timeseries-of-the-system","page":"Animations, GUIs, Visuals","title":"Example 3: Observed timeseries of the system","text":"","category":"section"},{"location":"visualizations/","page":"Animations, GUIs, Visuals","title":"Animations, GUIs, Visuals","text":"using DynamicalSystems, CairoMakie\nusing LinearAlgebra: norm, dot\n\n# Dynamical system and initial conditions\nds = Systems.thomas_cyclical(b = 0.2)\nu0s = [[3, 1, 1.], [1, 3, 1.], [1, 1, 3.]] # must be a vector of states!\n\n# Observables we get timeseries of:\nfunction distance_from_symmetry(u)\n    v = SVector{3}(1/√3, 1/√3, 1/√3)\n    t = dot(v, u)\n    return norm(u - t*v)\nend\nfs = [3, distance_from_symmetry]\n\nfig, dsobs = interactive_trajectory_timeseries(ds, fs, u0s;\n    idxs = [1, 2], Δt = 0.05, tail = 500,\n    lims = ((-2, 4), (-2, 4)),\n    timeseries_ylims = [(-2, 4), (0, 5)],\n    add_controls = false,\n    figure = (size = (800, 400),)\n)\n\nfig","category":"page"},{"location":"visualizations/","page":"Animations, GUIs, Visuals","title":"Animations, GUIs, Visuals","text":"we can progress the simulation:","category":"page"},{"location":"visualizations/","page":"Animations, GUIs, Visuals","title":"Animations, GUIs, Visuals","text":"step!(dsobs, 200)\nfig","category":"page"},{"location":"visualizations/","page":"Animations, GUIs, Visuals","title":"Animations, GUIs, Visuals","text":"or we can even make a nice video out of it:","category":"page"},{"location":"visualizations/","page":"Animations, GUIs, Visuals","title":"Animations, GUIs, Visuals","text":"\nrecord(fig, \"thomas_cycl.mp4\", 1:100) do i\n    step!(dsobs, 10)\nend","category":"page"},{"location":"visualizations/","page":"Animations, GUIs, Visuals","title":"Animations, GUIs, Visuals","text":"<video width=\"auto\" controls autoplay loop>\n<source src=\"../thomas_cycl.mp4\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"visualizations/#Cobweb-Diagrams","page":"Animations, GUIs, Visuals","title":"Cobweb Diagrams","text":"","category":"section"},{"location":"visualizations/","page":"Animations, GUIs, Visuals","title":"Animations, GUIs, Visuals","text":"<video width=\"100%\" height=\"auto\" controls autoplay loop>\n<source src=\"https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/interact/cobweb.mp4?raw=true\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"visualizations/","page":"Animations, GUIs, Visuals","title":"Animations, GUIs, Visuals","text":"interactive_cobweb","category":"page"},{"location":"visualizations/#DynamicalSystems.interactive_cobweb","page":"Animations, GUIs, Visuals","title":"DynamicalSystems.interactive_cobweb","text":"interactive_cobweb(ds::DiscreteDynamicalSystem, prange, O::Int = 3; kwargs...)\n\nLaunch an interactive application for exploring cobweb diagrams of 1D discrete dynamical systems. Two slides control the length of the plotted trajectory and the current parameter value. The parameter values are obtained from the given prange.\n\nIn the cobweb plot, higher order iterates of the dynamic rule f are plotted as well, starting from order 1 all the way to the given order O. Both the trajectory in the cobweb, as well as any iterate f can be turned off by using some of the buttons.\n\nKeywords\n\nfkwargs = [(linewidth = 4.0, color = randomcolor()) for i in 1:O]: plotting keywords for each of the plotted iterates of f\ntrajcolor = :black: color of the trajectory\npname = \"p\": name of the parameter slider\npindex = 1: parameter index\nxmin = 0, xmax = 1: limits the state of the dynamical system can take\nTmax = 1000: maximum trajectory length\nx0s = range(xmin, xmax; length = 101): Possible values for the x0 slider.\n\n\n\n\n\n","category":"function"},{"location":"visualizations/","page":"Animations, GUIs, Visuals","title":"Animations, GUIs, Visuals","text":"The animation at the top of this section was done with","category":"page"},{"location":"visualizations/","page":"Animations, GUIs, Visuals","title":"Animations, GUIs, Visuals","text":"using DynamicalSystems, GLMakie\n\n# the second range is a convenience for intermittency example of logistic\nrrange = 1:0.001:4.0\n# rrange = (rc = 1 + sqrt(8); [rc, rc - 1e-5, rc - 1e-3])\n\nlo = Systems.logistic(0.4; r = rrange[1])\ninteractive_cobweb(lo, rrange, 5)","category":"page"},{"location":"visualizations/#Orbit-Diagrams","page":"Animations, GUIs, Visuals","title":"Orbit Diagrams","text":"","category":"section"},{"location":"visualizations/","page":"Animations, GUIs, Visuals","title":"Animations, GUIs, Visuals","text":"Notice that orbit diagrams and bifurcation diagrams are different things in DynamicalSystems.jl","category":"page"},{"location":"visualizations/","page":"Animations, GUIs, Visuals","title":"Animations, GUIs, Visuals","text":"<video width=\"100%\" height=\"auto\" controls autoplay loop>\n<source src=\"https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/interact/odhenon.mp4?raw=true\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"visualizations/","page":"Animations, GUIs, Visuals","title":"Animations, GUIs, Visuals","text":"interactive_orbitdiagram\nscaleod","category":"page"},{"location":"visualizations/#DynamicalSystems.interactive_orbitdiagram","page":"Animations, GUIs, Visuals","title":"DynamicalSystems.interactive_orbitdiagram","text":"interactive_orbitdiagram(\n    ds::DynamicalSystem, p_index, pmin, pmax, i::Int = 1;\n    u0 = nothing, parname = \"p\", title = \"\"\n)\n\nOpen an interactive application for exploring orbit diagrams (ODs) of discrete time dynamical systems. Requires DynamicalSystems.\n\nIn essense, the function presents the output of orbitdiagram of the ith variable of the ds, and allows interactively zooming into it.\n\nKeywords control the name of the parameter, the initial state (used for any parameter) or whether to add a title above the orbit diagram.\n\nInteraction\n\nThe application is separated in the \"OD plot\" (left) and the \"control panel\" (right). On the OD plot you can interactively click and drag with the left mouse button to select a region in the OD. This region is then re-computed at a higher resolution.\n\nThe options at the control panel are straight-forward, with\n\nn amount of steps recorded for the orbit diagram (not all are in the zoomed region!)\nt transient steps before starting to record steps\nd density of x-axis (the parameter axis)\nα alpha value for the plotted points.\n\nNotice that at each update n*t*d steps are taken. You have to press update after changing these parameters. Press reset to bring the OD in the original state (and variable). Pressing back will go back through the history of your exploration History is stored when the \"update\" button is pressed or a region is zoomed in.\n\nYou can even decide which variable to get the OD for by choosing one of the variables from the wheel! Because the y-axis limits can't be known when changing variable, they reset to the size of the selected variable.\n\nAccessing the data\n\nWhat is plotted on the application window is a true orbit diagram, not a plotting shorthand. This means that all data are obtainable and usable directly. Internally we always scale the orbit diagram to [0,1]² (to allow Float64 precision even though plotting is Float32-based). This however means that it is necessary to transform the data in real scale. This is done through the function scaleod which accepts the 5 arguments returned from the current function:\n\nfigure, oddata = interactive_orbitdiagram(...)\nps, us = scaleod(oddata)\n\n\n\n\n\n","category":"function"},{"location":"visualizations/#DynamicalSystems.scaleod","page":"Animations, GUIs, Visuals","title":"DynamicalSystems.scaleod","text":"scaleod(oddata) -> ps, us\n\nGiven the return values of interactive_orbitdiagram, produce orbit diagram data scaled correctly in data units. Return the data as a vector of parameter values and a vector of corresponding variable values.\n\n\n\n\n\n","category":"function"},{"location":"visualizations/","page":"Animations, GUIs, Visuals","title":"Animations, GUIs, Visuals","text":"The animation at the top of this section was done with","category":"page"},{"location":"visualizations/","page":"Animations, GUIs, Visuals","title":"Animations, GUIs, Visuals","text":"i = p_index = 1\nds, p_min, p_max, parname = Systems.henon(), 0.8, 1.4, \"a\"\nt = \"orbit diagram for the Hénon map\"\n\noddata = interactive_orbitdiagram(ds, p_index, p_min, p_max, i;\n                                  parname = parname, title = t)\n\nps, us = scaleod(oddata)","category":"page"},{"location":"visualizations/#Interactive-Poincaré-Surface-of-Section","page":"Animations, GUIs, Visuals","title":"Interactive Poincaré Surface of Section","text":"","category":"section"},{"location":"visualizations/","page":"Animations, GUIs, Visuals","title":"Animations, GUIs, Visuals","text":"<video width=\"100%\" height=\"auto\" controls autoplay loop>\n<source src=\"https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/interact/interactive_psos.mp4?raw=true\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"visualizations/","page":"Animations, GUIs, Visuals","title":"Animations, GUIs, Visuals","text":"interactive_poincaresos","category":"page"},{"location":"visualizations/#DynamicalSystems.interactive_poincaresos","page":"Animations, GUIs, Visuals","title":"DynamicalSystems.interactive_poincaresos","text":"interactive_poincaresos(cds, plane, idxs, complete; kwargs...)\n\nLaunch an interactive application for exploring a Poincaré surface of section (PSOS) of the continuous dynamical system cds. Requires DynamicalSystems.\n\nThe plane can only be the Tuple type accepted by DynamicalSystems.poincaresos, i.e. (i, r) for the ith variable crossing the value r. idxs gives the two indices of the variables to be displayed, since the PSOS plot is always a 2D scatterplot. I.e. idxs = (1, 2) will plot the 1st versus 2nd variable of the PSOS. It follows that plane[1] ∉ idxs must be true.\n\ncomplete is a three-argument function that completes the new initial state during interactive use, see below.\n\nThe function returns: figure, laststate with the latter being an observable containing the latest initial state.\n\nKeyword Arguments\n\ndirection, rootkw : Same use as in DynamicalSystems.poincaresos.\ntfinal = (1000.0, 10.0^4) : A 2-element tuple for the range of values for the total integration time (chosen interactively).\ncolor : A function of the system's initial condition, that returns a color to plot the new points with. The color must be RGBf/RGBAf.  A random color is chosen by default.\nlabels = (\"u₁\" , \"u₂\") : Scatter plot labels.\nscatterkwargs = (): Named tuple of keywords passed to scatter.\ndiffeq = NamedTuple() : Any extra keyword arguments are passed into init of DiffEq.\n\nInteraction\n\nThe application is a standard scatterplot, which shows the PSOS of the system, initially using the system's u0. Two sliders control the total evolution time and the size of the marker points (which is always in pixels).\n\nUpon clicking within the bounds of the scatter plot your click is transformed into a new initial condition, which is further evolved and its PSOS is computed and then plotted into the scatter plot.\n\nYour click is transformed into a full D-dimensional initial condition through the function complete. The first two arguments of the function are the positions of the click on the PSOS. The third argument is the value of the variable the PSOS is defined on. To be more exact, this is how the function is called:\n\nx, y = mouseclick; z = plane[2]\nnewstate = complete(x, y, z)\n\nThe complete function can throw an error for ill-conditioned x, y, z. This will be properly handled instead of breaking the application. This newstate is also given to the function color that gets a new color for the new points.\n\n\n\n\n\n","category":"function"},{"location":"visualizations/","page":"Animations, GUIs, Visuals","title":"Animations, GUIs, Visuals","text":"To generate the animation at the start of this section you can run","category":"page"},{"location":"visualizations/","page":"Animations, GUIs, Visuals","title":"Animations, GUIs, Visuals","text":"using InteractiveDynamics, GLMakie, OrdinaryDiffEq, DynamicalSystems\ndiffeq = (alg = Vern9(), abstol = 1e-9, reltol = 1e-9)\n\nhh = Systems.henonheiles()\n\npotential(x, y) = 0.5(x^2 + y^2) + (x^2*y - (y^3)/3)\nenergy(x,y,px,py) = 0.5(px^2 + py^2) + potential(x,y)\nconst E = energy(get_state(hh)...)\n\nfunction complete(y, py, x)\n    V = potential(x, y)\n    Ky = 0.5*(py^2)\n    Ky + V ≥ E && error(\"Point has more energy!\")\n    px = sqrt(2(E - V - Ky))\n    ic = [x, y, px, py]\n    return ic\nend\n\nplane = (1, 0.0) # first variable crossing 0\n\n# Coloring points using the Lyapunov exponent\nfunction λcolor(u)\n    λ = lyapunovs(hh, 4000; u0 = u)[1]\n    λmax = 0.1\n    return RGBf(0, 0, clamp(λ/λmax, 0, 1))\nend\n\nstate, scene = interactive_poincaresos(hh, plane, (2, 4), complete;\nlabels = (\"q₂\" , \"p₂\"),  color = λcolor, diffeq...)","category":"page"},{"location":"visualizations/#Scanning-a-Poincaré-Surface-of-Section","page":"Animations, GUIs, Visuals","title":"Scanning a Poincaré Surface of Section","text":"","category":"section"},{"location":"visualizations/","page":"Animations, GUIs, Visuals","title":"Animations, GUIs, Visuals","text":"<video width=\"100%\" height=\"auto\" controls autoplay loop>\n<source src=\"https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/interact/psos_brainscan.mp4?raw=true\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"visualizations/","page":"Animations, GUIs, Visuals","title":"Animations, GUIs, Visuals","text":"interactive_poincaresos_scan","category":"page"},{"location":"visualizations/#DynamicalSystems.interactive_poincaresos_scan","page":"Animations, GUIs, Visuals","title":"DynamicalSystems.interactive_poincaresos_scan","text":"interactive_poincaresos_scan(A::StateSpaceSet, j::Int; kwargs...)\ninteractive_poincaresos_scan(As::Vector{StateSpaceSet}, j::Int; kwargs...)\n\nLaunch an interactive application for scanning a Poincare surface of section of A like a \"brain scan\", where the plane that defines the section can be arbitrarily moved around via a slider. Return figure, ax3D, ax2D.\n\nThe input dataset must be 3 dimensional, and here the crossing plane is always chosen to be when the j-th variable of the dataset crosses a predefined value. The slider automatically gets all possible values the j-th variable can obtain.\n\nIf given multiple datasets, the keyword colors attributes a color to each one, e.g. colors = [JULIADYNAMICS_COLORS[mod1(i, 6)] for i in 1:length(As)].\n\nThe keywords linekw, scatterkw are named tuples that are propagated as keyword arguments to the line and scatter plot respectively, while the keyword direction = -1 is propagated to the function DyamicalSystems.poincaresos.\n\n\n\n\n\n","category":"function"},{"location":"visualizations/","page":"Animations, GUIs, Visuals","title":"Animations, GUIs, Visuals","text":"The animation at the top of this page was done with","category":"page"},{"location":"visualizations/","page":"Animations, GUIs, Visuals","title":"Animations, GUIs, Visuals","text":"using GLMakie, DynamicalSystems\nusing OrdinaryDiffEq: Vern9\n\ndiffeq = (alg = Vern9(), abstol = 1e-9, reltol = 1e-9)\nds = PredefinedDynamicalSystems.henonheiles()\nds = CoupledODEs(ds, diffeq)\n\nu0s = [\n    [0.0, -0.25, 0.42081, 0.0],\n    [0.0, 0.1, 0.5, 0.0],\n    [0.0, -0.31596, 0.354461, 0.0591255]\n]\n# inputs\ntrs = [trajectory(ds, 10000, u0)[1][:, SVector(1,2,3)] for u0 ∈ u0s]\nj = 2 # the dimension of the plane\n\ninteractive_poincaresos_scan(trs, j; linekw = (transparency = true,))","category":"page"},{"location":"contributors_guide/#Contributor-Guide","page":"Contributor Guide","title":"Contributor Guide","text":"","category":"section"},{"location":"contributors_guide/","page":"Contributor Guide","title":"Contributor Guide","text":"The ultimate goal for DynamicalSystems.jl is to be a useful library for scientists working on nonlinear dynamics and to make nonlinear dynamics accessible and reproducible.","category":"page"},{"location":"contributors_guide/","page":"Contributor Guide","title":"Contributor Guide","text":"Of course, for such an ambitious goal to be achieved, many of us should try to work together to improve the library! If you want to help the cause, there are many ways to contribute to the DynamicalSystems.jl library:","category":"page"},{"location":"contributors_guide/","page":"Contributor Guide","title":"Contributor Guide","text":"Just use it! Share it with your colleagues if it was useful for you, and report unexpected behaviour if you find any (see here for how).\nSuggest methods that you think should be included in our library. This should be done by opening a new issue that describes the method, gives references to papers using the method and also justifies why the method should be included. Please open an issue to the GitHub page of the submodule of DynamicalSystems.jl that you feel is the most related to the method.\nContribute code by solving existing issues. The easiest issues to tackle are the ones with label \"good first issue\". Here is a list of all such issues from all submodules of DynamicalSystems.jl: link.\nContribute code by implementing new methods! That is by far the most impactful way to contribute to the library. The individual packages that compose DynamicalSystems.jl have plenty of issues that outline new methods wanted by the library, that are likely not tagged as \"good first issues\" because they will likely require familiarity that goes beyond a complete beginner. You can tackle one of these if you want to contribute! Additionally, we strongly welcome contributions of brand new algorithms that have just been developed during research in nonlinear dynamics. In fact, DynamicalSystems.jl started with the vision that researchers would add their newly developed methods directly to the library when they publish the methods.","category":"page"},{"location":"contributors_guide/#Contributing-Code","page":"Contributor Guide","title":"Contributing Code","text":"","category":"section"},{"location":"contributors_guide/","page":"Contributor Guide","title":"Contributor Guide","text":"When contributing code, principles for writing good scientific code apply. We recommend the [Good Scientific Code workshop] material for teaching you this.","category":"page"},{"location":"contributors_guide/","page":"Contributor Guide","title":"Contributor Guide","text":"You should keep these things in mind:","category":"page"},{"location":"contributors_guide/","page":"Contributor Guide","title":"Contributor Guide","text":"In general, the speed of the implementation is important, but not as important as the clarity of the implementation. One of cornerstones of all of DynamicalSystems.jl is to have clear and readable source code. Fortunately, Julia allows you to have perfectly readable code but also super fast ;) If necessary add comments to the code, so that somebody that knows the method, can also understand the code immediately.\nTry to design general, extendable functions instead of unnecessarily specialized to the case at hand.\nThe documentation strings of the new API functions you contribute are the most important to make as good as possible. Please follow the convention of the documentation strings of DynamicalSystems.jl outlined below.","category":"page"},{"location":"contributors_guide/#Documentation-string-style","page":"Contributor Guide","title":"Documentation string style","text":"","category":"section"},{"location":"contributors_guide/","page":"Contributor Guide","title":"Contributor Guide","text":"Documentation strings are the most important thing in your pull request/code. The number 1 priority of DynamicalSystems.jl is highest possible quality of documentation and utmost transparency, and the best way to achieve this is with good documentation strings. In DynamicalSystems.jl we recommend that documentation strings are structured in the following way (and this is also the recommendation we give in the Good Scientific Code Workshop).","category":"page"},{"location":"contributors_guide/","page":"Contributor Guide","title":"Contributor Guide","text":"Clear call signature in code syntax, including expected input types if necessary. The call signature should ONLY include only the most important information, not list out in detail every keyword!\nBrief summary of the function\n[Optional] Return value and type if not obvious (almost always it is not obvious!)\n[Optional] References to related functions if sensible with the @ref command.\n[Optional] Keyword arguments list if the function has some with a ## Keyword arguments subsection.\n[Optional] Detailed discussion of functionality if function behavior is scientifically involved with a ## Description subsection.\n[Optional] Citations to relevant scientific papers with the @cite command.","category":"page"},{"location":"contributors_guide/","page":"Contributor Guide","title":"Contributor Guide","text":"The syntax of the documentation strings follows Documenter.jl protocol. For an example docstring to use as a reference, you can use the ApproximateEntropy:","category":"page"},{"location":"contributors_guide/","page":"Contributor Guide","title":"Contributor Guide","text":"rendered documentation string\nsource code documentation string","category":"page"},{"location":"contents/#contents","page":"Contents","title":"Contents","text":"","category":"section"},{"location":"contents/","page":"Contents","title":"Contents","text":"When you do using DynamicalSystems in your Julia session, the module re-exports and brings into scope all submodules (Julia packages) that compose DynamicalSystems.jl. These are listed in this page. Of course, you could be using these packages directly instead of adding DynamicalSystems. However, doing using DynamicalSystems provides the environment all these packages were designed to work together in, and so we recommend to simply install DynamicalSystems and use that.","category":"page"},{"location":"contents/#Exported-submodules","page":"Contents","title":"Exported submodules","text":"","category":"section"},{"location":"contents/","page":"Contents","title":"Contents","text":"The submodules that compose DynamicalSystems.jl are the following packages, which are re-exported by DynamicalSystems:","category":"page"},{"location":"contents/","page":"Contents","title":"Contents","text":"Core","category":"page"},{"location":"contents/","page":"Contents","title":"Contents","text":"StateSpaceSets\nDynamicalSystemsBase","category":"page"},{"location":"contents/","page":"Contents","title":"Contents","text":"For observed/measured data","category":"page"},{"location":"contents/","page":"Contents","title":"Contents","text":"ComplexityMeasures\nRecurrenceAnalysis\nDelayEmbeddings\nFractalDimensions\nTimeseriesSurrogates","category":"page"},{"location":"contents/","page":"Contents","title":"Contents","text":"For dynamical system instances","category":"page"},{"location":"contents/","page":"Contents","title":"Contents","text":"PredefinedDynamicalSystems\nChaosTools\nAttractors","category":"page"},{"location":"contents/","page":"Contents","title":"Contents","text":"At the very end of this page, a full list of exported names is presented.","category":"page"},{"location":"contents/#Core","page":"Contents","title":"Core","text":"","category":"section"},{"location":"contents/","page":"Contents","title":"Contents","text":"StateSpaceSets\nDynamicalSystemsBase","category":"page"},{"location":"contents/#StateSpaceSets.StateSpaceSets","page":"Contents","title":"StateSpaceSets.StateSpaceSets","text":"StateSpaceSets.jl\n\n(Image: docsdev) (Image: docsstable) (Image: ) (Image: CI) (Image: codecov) (Image: Package Downloads)\n\nA Julia package that provides functionality for state space sets. These are collections of points of fixed, and known by type, size (called dimension). It is used by many other packages in the JuliaDynamics organization. The main export of StateSpaceSets is the concrete type StateSpaceSet. The package also provides functionality for distances, neighbor searches, sampling, and normalization.\n\nTo install it you may run import Pkg; Pkg.add(\"StateSpaceSets\"), however, there is no real reason to install this package directly as it is re-exported by all downstream packages that use it.\n\n\n\n\n\n","category":"module"},{"location":"contents/#DynamicalSystemsBase.DynamicalSystemsBase","page":"Contents","title":"DynamicalSystemsBase.DynamicalSystemsBase","text":"DynamicalSystemsBase.jl\n\n(Image: docsdev) (Image: docsstable) (Image: ) (Image: CI) (Image: codecov) (Image: Package Downloads)\n\nA Julia package that defines the DynamicalSystem interface and many concrete implementations used in the DynamicalSystems.jl ecosystem.\n\nTo install it, run import Pkg; Pkg.add(\"DynamicalSystemsBase\"). Typically, you do not want to use DynamicalSystemsBase directly, as downstream analysis packages re-export it.\n\nAll further information is provided in the documentation, which you can either find online or build locally by running the docs/make.jl file.\n\n\n\n\n\n","category":"module"},{"location":"contents/#For-observed/measured-data","page":"Contents","title":"For observed/measured data","text":"","category":"section"},{"location":"contents/","page":"Contents","title":"Contents","text":"ComplexityMeasures\nRecurrenceAnalysis\nDelayEmbeddings\nFractalDimensions\nTimeseriesSurrogates","category":"page"},{"location":"contents/#ComplexityMeasures.ComplexityMeasures","page":"Contents","title":"ComplexityMeasures.ComplexityMeasures","text":"ComplexityMeasures.jl\n\n(Image: docsdev) (Image: docsstable) (Image: CI) (Image: codecov) (Image: Package Downloads) (Image: Package Downloads) (Image: DOI)\n\nComplexityMeasures.jl is a software for calculating 1000s of various kinds of probabilities, entropies, and other so-called complexity measures from a single input dataset. For relational measures across many input datasets see its extension CausalityTools.jl.\n\nThe key features that it provides can be summarized as:\n\nA rigorous framework for extracting probabilities from data, based on the mathematical formulation of probability spaces.\nSeveral (12+) outcome spaces, i.e., ways to discretize data into probabilities.\nSeveral estimators for estimating probabilities given an outcome space, which correct theoretically known estimation biases.\nSeveral definitions of information measures, such as various flavours of entropies (Shannon, Tsallis, Curado...), extropies, and other complexity measures, that are used in the context of nonlinear dynamics, nonlinear timeseries analysis, and complex systems.\nSeveral discrete and continuous (differential) estimators for entropies, which correct theoretically known estimation biases.\nAn extendable interface and well thought out API accompanied by dedicated developer documentation. This makes it trivial to define new outcome spaces, or new estimators for probabilities, information measures, or complexity measures and integrate them with everything else in the software without boilerplate code.\n\nComplexityMeasures.jl can be used as a standalone package, or as part of other projects in the JuliaDynamics organization, such as DynamicalSystems.jl or CausalityTools.jl.\n\nTo install it, run import Pkg; Pkg.add(\"ComplexityMeasures\").\n\nAll further information is provided in the documentation, which you can either find online or build locally by running the docs/make.jl file.\n\nPreviously, this package was called Entropies.jl.\n\n\n\n\n\n","category":"module"},{"location":"contents/#RecurrenceAnalysis.RecurrenceAnalysis","page":"Contents","title":"RecurrenceAnalysis.RecurrenceAnalysis","text":"RecurrenceAnalysis.jl\n\n(Image: docsdev) (Image: docsstable) (Image: CI) (Image: codecov) (Image: Package Downloads)\n\nA Julia package that offers tools for computing Recurrence Plots and exploring them within the framework of Recurrence Quantification Analysis and Recurrence Network Analysis. It can be used as a standalone package, or as part of DynamicalSystems.jl.\n\nTo install it, run import Pkg; Pkg.add(\"RecurrenceAnalysis\").\n\nAll further information is provided in the documentation, which you can either find online or build locally by running the docs/make.jl file.\n\n\n\n\n\n","category":"module"},{"location":"contents/#DelayEmbeddings.DelayEmbeddings","page":"Contents","title":"DelayEmbeddings.DelayEmbeddings","text":"DelayEmbeddings.jl\n\n(Image: docsdev) (Image: docsstable) (Image: ) (Image: CI) (Image: codecov) (Image: Package Downloads)\n\nA Julia package that provides a generic interface for performing delay coordinate embeddings, as well as cutting edge algorithms for creating optimal embeddings given some data. It can be used as a standalone package, or as part of DynamicalSystems.jl.\n\nTo install it, run import Pkg; Pkg.add(\"DelayEmbeddings\").\n\nAll further information is provided in the documentation, which you can either find online or build locally by running the docs/make.jl file.\n\n\n\n\n\n","category":"module"},{"location":"contents/#FractalDimensions.FractalDimensions","page":"Contents","title":"FractalDimensions.FractalDimensions","text":"FractalDimensions.jl\n\n(Image: ) (Image: ) (Image: ) (Image: CI) (Image: codecov) (Image: Package Downloads)\n\nA Julia package that estimates various definitions of fractal dimension from data. It can be used as a standalone package, or as part of DynamicalSystems.jl.\n\nTo install it, run import Pkg; Pkg.add(\"FractalDimensions\").\n\nAll further information is provided in the documentation, which you can either find online or build locally by running the docs/make.jl file.\n\nPreviously, this package was part of ChaosTools.jl.\n\nPublication\n\nFractalDimensions.jl is used in a review article comparing various estimators for fractal dimensions. The paper is likely a relevant read if you are interested in the package. And if you use the package, please cite the paper.\n\n@article{FractalDimensions.jl,\n  doi = {10.1063/5.0160394},\n  url = {https://doi.org/10.1063/5.0160394},\n  year = {2023},\n  month = oct,\n  publisher = {{AIP} Publishing},\n  volume = {33},\n  number = {10},\n  author = {George Datseris and Inga Kottlarz and Anton P. Braun and Ulrich Parlitz},\n  title = {Estimating fractal dimensions: A comparative review and open source implementations},\n  journal = {Chaos: An Interdisciplinary Journal of Nonlinear Science}\n}\n\n\n\n\n\n","category":"module"},{"location":"contents/#TimeseriesSurrogates.TimeseriesSurrogates","page":"Contents","title":"TimeseriesSurrogates.TimeseriesSurrogates","text":"TimeseriesSurrogates.jl\n\n(Image: docsdev) (Image: docsstable) (Image: ) (Image: CI) (Image: codecov) (Image: Package Downloads)\n\nA Julia package for generating timeseries surrogates. TimeseriesSurrogates.jl is the fastest and most featureful open source code for generating timeseries surrogates. It can be used as a standalone package, or as part of other projects in JuliaDynamics such as DynamicalSystems.jl or CausalityTools.jl.\n\nTo install it, run import Pkg; Pkg.add(\"TimeseriesSurrogates\").\n\nAll further information is provided in the documentation, which you can either find online or build locally by running the docs/make.jl file.\n\nCiting\n\nPlease use the following BiBTeX entry, or DOI, to cite TimeseriesSurrogates.jl:\n\nDOI: https://doi.org/10.21105/joss.04414\n\nBiBTeX:\n\n@article{TimeseriesSurrogates.jl,\n    doi = {10.21105/joss.04414},\n    url = {https://doi.org/10.21105/joss.04414},\n    year = {2022},\n    publisher = {The Open Journal},\n    volume = {7},\n    number = {77},\n    pages = {4414},\n    author = {Kristian Agasøster Haaga and George Datseris},\n    title = {TimeseriesSurrogates.jl: a Julia package for generating surrogate data},\n    journal = {Journal of Open Source Software}\n}\n\n\n\n\n\n","category":"module"},{"location":"contents/#For-dynamical-system-instances","page":"Contents","title":"For dynamical system instances","text":"","category":"section"},{"location":"contents/","page":"Contents","title":"Contents","text":"PredefinedDynamicalSystems\nChaosTools\nAttractors","category":"page"},{"location":"contents/#PredefinedDynamicalSystems.PredefinedDynamicalSystems","page":"Contents","title":"PredefinedDynamicalSystems.PredefinedDynamicalSystems","text":"PredefinedDynamicalSystems.jl\n\n(Image: ) (Image: CI) (Image: Package Downloads)\n\nModule which contains pre-defined dynamical systems that can be used by the DynamicalSystems.jl library. To install it, run import Pkg; Pkg.add(\"PredefinedDynamicalSystems\").\n\nPredefined systems exist as functions that return a DynamicalSystem instance. They are accessed like:\n\nds = PredefinedDynamicalSystems.lorenz(u0; ρ = 32.0)\n\nThe alias Systems is also exported as a deprecation.\n\nThis module is provided purely as a convenience. It does not have any actual tests, and it is not guaranteed to be stable in future versions. It is not recommended to use this module for anything else besides on-the-spot demonstrative examples.\n\nFor some systems, a Jacobian function is also defined. The naming convention for the Jacobian function is \\$(name)_jacob. So, for the above example we have J = Systems.lorenz_jacob.\n\nAll available systems are provided in the documentation, which you can either find online or build locally by running the docs/make.jl file.\n\n\n\n\n\n","category":"module"},{"location":"contents/#ChaosTools.ChaosTools","page":"Contents","title":"ChaosTools.ChaosTools","text":"ChaosTools.jl\n\n(Image: docsdev) (Image: docsstable) (Image: ) (Image: CI) (Image: codecov) (Image: Package Downloads)\n\nA Julia module that offers various tools for analysing nonlinear dynamics and chaotic behaviour. It can be used as a standalone package, or as part of DynamicalSystems.jl.\n\nTo install it, run import Pkg; Pkg.add(\"ChaosTools\").\n\nAll further information is provided in the documentation, which you can either find online or build locally by running the docs/make.jl file.\n\nChaosTools.jl is the jack-of-all-trades package of the DynamicalSystems.jl library: methods that are not extensive enough to be a standalone package are added here. You should see the full DynamicalSystems.jl library for other packages that may contain functionality you are looking for but did not find in ChaosTools.jl.\n\n\n\n\n\n","category":"module"},{"location":"contents/#Attractors.Attractors","page":"Contents","title":"Attractors.Attractors","text":"Attractors.jl\n\n(Image: docsdev) (Image: docsstable) (Image: Paper) (Image: CI) (Image: codecov) (Image: Package Downloads)\n\nA Julia module for\n\nfinding attractors of arbitrary dynamical systems\nfinding their basins of attraction or the state space fractions of the basins\nanalyzing global stability of attractors (also called non-local stability or  resilience)\n\"continuing\" the attractors and their basins over a parameter range\nfinding the basin boundaries and analyzing their fractal properties\ntipping points related functionality for systems with known dynamic rule\nand more!\n\nIt can be used as a standalone package, or as part of DynamicalSystems.jl.\n\nTo install it, run import Pkg; Pkg.add(\"Attractors\").\n\nAll further information is provided in the documentation, which you can either find online or build locally by running the docs/make.jl file.\n\nPreviously, Attractors.jl was part of ChaosTools.jl\n\n\n\n\n\n","category":"module"},{"location":"contents/#All-exported-names","page":"Contents","title":"All exported names","text":"","category":"section"},{"location":"contents/","page":"Contents","title":"Contents","text":"This section lists all exported names of the DynamicalSystems.jl library. We do not list their documentation in any way here. This list is only meant as a quantitative listing of features, as well as perhaps helping searching via the search bar. To actually learn how to use all these exported names you need to use above-linked documentation of the respective submodules!","category":"page"},{"location":"contents/","page":"Contents","title":"Contents","text":"The total exported names are:","category":"page"},{"location":"contents/","page":"Contents","title":"Contents","text":"using DynamicalSystems\nall_exported_names = names(DynamicalSystems)\nlength(all_exported_names)","category":"page"},{"location":"contents/","page":"Contents","title":"Contents","text":"And they are:","category":"page"},{"location":"contents/","page":"Contents","title":"Contents","text":"using DisplayAs\nDisplayAs.unlimited(all_exported_names)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"DynamicalSystems","category":"page"},{"location":"#DynamicalSystems","page":"Introduction","title":"DynamicalSystems","text":"(Image: DynamicalSystems.jl logo: The Double Pendulum)\n\n(Image: ) (Image: DocBuild) (Image: DOI) (Image: Textbook) (Image: Package Downloads)\n\nDynamicalSystems.jl is an award-winning Julia software library for nonlinear dynamics and nonlinear timeseries analysis.\n\nTo install DynamicalSystems.jl, run import Pkg; Pkg.add(\"DynamicalSystems\") as a Julia language command. To learn how to use it and see its contents visit the documentation, which you can either find online or build locally by running the docs/make.jl file.\n\nDynamicalSystems.jl is part of JuliaDynamics, an organization dedicated to creating high quality scientific software.\n\nHighlights\n\nAspects of DynamicalSystems.jl that make it stand out among other codebases for nonlinear dynamics or nonlinear timeseries analysis are:\n\nExceptional documentation. All implemented algorithms provide a high-level scientific description of their functionality in their documentation string as well as references to scientific papers. The documentation features hundreds of tutorials and examples ranging from introductory to expert usage.\nAccessible source code. One of the main priorities of the library is that the source code of (almost) all implementations is small, simple, easy to understand and modify. This increases confidence, reduces bugs, and allows users to become developers without unnecessary effort.\nOpen source community project. Built from the ground up entirely on GitHub, DynamicalSystems.jl is 100% open source and based on community contributions. Anyone can be a developer of the library. Everyone is welcomed.\nExtensive content. It aims to cover the entire field of nonlinear dynamics and nonlinear timeseries analysis. It has functionality for complexity measures, delay embeddings, periodic orbits, nonlocal stability analysis, continuation, chaos, fractal dimensions, surrogate testing, recurrence quantification analysis, and much more. Furthermore, all algorithms are \"general\" and work for any dynamical system applicable. Missing functionality that falls under this wide category of content is welcomed to be part of the library!\nWell tested. All implemented functionality is extensively tested. Each time any change in the code base is done, the extensive test suite is run and checked before merging the change in.\nExtendable. DynamicalSystems.jl is a living, evolving project. New contributions can become part of the library and be accessed by all users in the next release. Most importantly, all parts of the library follow professional standards in software design and implement extendable interfaces so that it is easy to contribute new functionality.\nActive development. Since the start of the project (May 2017) there has been  activity every month: new features, bugfixes, and the developer team answers users questions on official Julia language forums.\nPerformant. Written entirely in Julia, heavily optimized and parallelized, and taking advantage of some of the best packages within the language, DynamicalSystems.jl is really fast.\n\nGoals\n\nThe DynamicalSystems.jl library started as a vision with three main goals; These same goals now are the core pillars guiding development, and are largely the source of where the aforementioned unique highlights stem from.\n\nGoal 1: Accessible and reproducible nonlinear dynamics\n\nThe first goal of the library is to make this beautiful field accessible and reproducible.\n\nAccessible means that if you read on some sorts of fancy algorithm online in a scientific article, you should be able to use it instantly. You shouldn't have to put in the work to code it yourself. The authors of the paper already did that. So why should you do it again?! To resolve this problem we developed, and continue to develop, a library that has an incredibly low threshold of entry: contributing to DynamicalSystems.jl and making your code available to all is truly easier than coding your own algorithms from scratch, due to the well thought out and generic interfaces it provides for dynamical systems.\n\nReproducible means that given some sorts of dynamical systems analysis in a scientific article, you should be able to do exactly the same analysis and get exactly the same results (within some numeric precision) as the article. After all, computers are deterministic constructs. DynamicalSystems.jl allows this by (1) being written in a modern programming language with incredible environment and reproducibility support, (2) being well tested, and (3) by providing thousands of algorithms out of the box, allowing most dynamical systems analysis to be done instantly while implementing only as little new stuff as necessary.\n\nGoal 2: Library in the literal sense\n\nDynamicalSystems.jl is not just a software library. It is also a library in the literal sense: where people go to learn something new (here in particular for nonlinear dynamics). That is why the documentation is of exceptionally high quality: detailed descriptions and explanations of algorithms, with references to the scientific articles articles. It is also partly a reason for the source code to be written as clearly as possible, so that it is examinable by any user.\n\nGoal 3: A general purpose software\n\nThe third goal is to fill the missing gap of a high quality general purpose software for nonlinear dynamics which can be easily extended with new functionality. This can be particularly impactful in teaching. You see, it is unfortunately rarely the case that real, runnable code is shown in the classroom, because it is often long and messy. This is especially hurtful for nonlinear dynamics, a field where computer-assisted exploration is critical.\n\nDynamicalSystems.jl provides teachers with a framework capable of demonstrating actual, real-world nonlinear dynamics code and its output, without having to invest the weeks to code the internal infrastructure themselves. Its high level syntax requires writing little code to get lots of meaningful analysis done, while its extensive functionality covers most typical classroom applications.\n\n\n\n\n\n","category":"module"},{"location":"","page":"Introduction","title":"Introduction","text":"tip: Star us on GitHub!\nIf you have found this library useful, please consider starring it on GitHub. This gives us an accurate lower bound of the (satisfied) user count.","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Welcome to the documentation of DynamicalSystems.jl!","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"If you have not used the library before, and would like to get started, then please read the overarching tutorial for the library.\nThe contents page gives a summary of all packages that are part of the library.\nSee the learning resources below to find out more resources about learning the library and using it in scientific research and/or education.\nBesides the formal algorithmic/scientific content of DynamicalSystems.jl (those in the contents) page, the library also provides basic functionality for interactive or offline animations and visualizations. These are found in the visualizations page.\nThe remaining of this introduction page discusses our goals with the library, how to participate as a user or developer, how to cite, and other relevant information (see the sections of the sidebar on the left).","category":"page"},{"location":"#Latest-news","page":"Introduction","title":"Latest news","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"DynamicalSystems.jl now integrates with ModelingToolkit.jl and allows using symbolic variables to access/observe state and parameter.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"At a low level, this happens via the functions observe_state, set_state!, current_parameter and set_parameter!.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Additionally, interactive_trajectory_timeseries allows symbolic indexing for state space plot, timeseries plots, or parameter sliders. Everything is also automatically named and limits are also automatically deduced for everything! Super convenient!","category":"page"},{"location":"#learning","page":"Introduction","title":"Learning resources","text":"","category":"section"},{"location":"#Textbook-with-DynamicalSystems.jl","page":"Introduction","title":"Textbook with DynamicalSystems.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"We have written an undergraduate level textbook as an introduction to nonlinear dynamics. The text is written in an applied, hands-on manner, while still covering all fundamentals. The book pages are interlaced with real Julia code that uses DynamicalSystems.jl and is published in the Undergraduate Lecture Notes in Physics by Springer Nature:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Nonlinear Dynamics: A concise introduction interlaced with code by G. Datseris & U. Parlitz.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Additional textbooks on nonlinear dynamics with practical focus are:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Chaos in Dynamical Systems - E. Ott\nNonlinear Time series Analysis - H. Kantz & T. Schreiber\nNonlinear Dynamics and Chaos - S. Strogatz","category":"page"},{"location":"#Course-on-applied-nonlinear-dynamics-and-complex-systems","page":"Introduction","title":"Course on applied nonlinear dynamics and complex systems","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"We are developing a full course (targeting a graduate or undergraduate semester long course) on applied nonlinear dynamics, nonlinear timeseries analysis, and complex systems, using the packages of JuliaDynamics. DynamicalSystems.jl is part of this course.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The materials of the course are on GitHub: https://github.com/JuliaDynamics/NonlinearDynamicsComplexSystemsCourses","category":"page"},{"location":"#Citing","page":"Introduction","title":"Citing","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"There is a (small) paper associated with DynamicalSystems.jl. If we have helped you in research that led to a publication, please cite it using the DOI 10.21105/joss.00598 or the following BiBTeX entry:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@article{Datseris2018,\n  doi = {10.21105/joss.00598},\n  url = {https://doi.org/10.21105/joss.00598},\n  year  = {2018},\n  month = {mar},\n  volume = {3},\n  number = {23},\n  pages = {598},\n  author = {George Datseris},\n  title = {DynamicalSystems.jl: A Julia software library for chaos and nonlinear dynamics},\n  journal = {Journal of Open Source Software}\n}","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Irrespectively of DynamicalSystems.jl, please also cite the specific algorithm that you used from the library. The documentation of the function used will point you to the correct reference.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Besides the library, we would also appreciate it if you cited the textbook we wrote that DynamicalSystems.jl accompanies:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@book{DatserisParlitz2022,\n  doi = {10.1007/978-3-030-91032-7},\n  url = {https://doi.org/10.1007/978-3-030-91032-7},\n  year = {2022},\n  publisher = {Springer Nature},\n  author = {George Datseris and Ulrich Parlitz},\n  title     = \"Nonlinear dynamics: A concise introduction interlaced with code\",\n  address   = \"Cham, Switzerland\",\n  language  = \"en\",\n}","category":"page"},{"location":"#ask_questions","page":"Introduction","title":"Asking questions","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"There are three options for asking questions:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"As a new post in the official Julia discourse and ask a question under the category Specific Domains > Modelling & Simulations, also using dynamical-systems as a tag. This option is preferred for any meaningfully involved question, as the answer there will be future-searchable.\nAs a message in our channel #dynamics-bridged in the Julia Slack workplace. This option is preferred for a brief question with (expected) simple answer, or to get an opinion about something, or to chat about something.\nBy opening an issue directly on the GitHub page of DynamicalSystems.jl while providing a Minimal Working Example. This option is preferred when you encounter unexpected behavior.","category":"page"},{"location":"#Contributing-and-Donating","page":"Introduction","title":"Contributing & Donating","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Be sure to visit the Contributor Guide page, because you can help make this package better without having to write a single line of code! Also, if you find this package helpful please consider staring it on GitHub! This gives us an accurate lower bound of users that this package has already helped!","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Finally, you can donate for the development of DynamicalSystems.jl. You can do that by adding bounties to existing issues on the GitHub repositories (you can open new issues as well). Every issue has an automatic way to create a bounty using Bountysource, see the first comment of each issue.","category":"page"},{"location":"#Issues-with-Bounties","page":"Introduction","title":"Issues with Bounties","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Money that DynamicalSystems.jl obtains from awards, sponsors, or donators are converted into bounties for GitHub issues. The full list of issues that have a bounty is available here.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"By solving these issues you not only contribute to open source, but you also get some pocket money to boot :)","category":"page"},{"location":"#Maintainers-and-Contributors","page":"Introduction","title":"Maintainers and Contributors","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The DynamicalSystems.jl library is maintained by George Datseris, who is also curating and writing this documentation. The software code however is built from the contributions of several individuals. The list is too long to write and constantly update, so the best way to find out these contributions is to visit the GitHub page of each of the subpackages and checkout the \"contributors\" pages there.","category":"page"},{"location":"#Version-numbers","page":"Introduction","title":"Version numbers","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The version of DynamicalSystems by itself is a bit meaningless, because the module does not have any source code, besides re-exporting other modules. For transparency, the packages and versions used to build the documentation you are reading now are:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using CairoMakie, DynamicalSystems","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using Pkg\nPkg.status([\n    \"DynamicalSystems\",\n    \"StateSpaceSets\", \"DynamicalSystemsBase\", \"RecurrenceAnalysis\", \"FractalDimensions\", \"DelayEmbeddings\", \"ComplexityMeasures\", \"TimeseriesSurrogates\", \"PredefinedDynamicalSystems\", \"Attractors\", \"ChaosTools\", \"CairoMakie\",\n    ];\n    mode = PKGMODE_MANIFEST\n)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"warn: Version numbers do not strictly follow SemVer2.0\nBecause of the nature of the DynamicalSystems.jl library, the exported API contains hundreds of algorithm implementations, most of which are independent of each other. Our development approach is that breaking changes to these individual algorithms (due to e.g., better API design or better performance implementations or better default keyword arguments) can be done without incrementing any major version numbers. We increment major version numbers only for breaking changes that have wide impact over most of the DynamicalSystems.jl library.","category":"page"},{"location":"#Other-NLD-relevant-packages","page":"Introduction","title":"Other NLD-relevant packages","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Besides DynamicalSystems.jl, the Julia programming language has a thriving ecosystem with plenty of functionality that is relevant for nonlinear dynamics. We list some useful references below:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"DifferentialEquations.jl - Besides providing solvers for standard ODE systems (infastructure already used in DynamicalSystems.jl), it also has much more features like SDE solvers or uncertainty quantification.\nDiffEqSensitivity.jl - Discrete and continuous local sensitivity analysis, i.e., derivatives of the solutions of ODEs, or functions of the solutions, versus parameters, hosting various forward and adjoint methods as well as methods tailored to chaotic systems.\nGlobalSensitivity.jl - Global sensitivity analysis assessing the effect of any input variables over a larger domain on the output.\nBifurcationKit.jl - Featureful toolkit for automated bifurcation analysis.\nNetworkDynamics.jl - Simulating dynamics on networks and transforming network systems into ODEProblem (that can be made directly into a ContinuousDynamicalSystem).\nAgents.jl - Agent based modelling.\nEasyModelAnalysis.jl - Analysis tools for conveniently analysing solutions of DiffEq systems.\nSignalDecomposition.jl - Decompose a signal/timeseries into structure and noise or seasonal and residual components.\nARFIMA.jl - generate ARFIMA process timeseries.\nConcurrentSim.jl - discrete event process oriented simulation framework.\nCausalityTools.jl - hundreds of algorithms for relational/causal timeseries analysis and causal graphs.","category":"page"},{"location":"tutorial/#tutorial","page":"Overarching tutorial","title":"Overarching tutorial for DynamicalSystems.jl","text":"","category":"section"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"This page serves as a short but to-the-point introduction to the DynamicalSystems.jl library. It outlines the core components, and how they establish an interface that is used by the rest of the library. It also provides a couple of usage examples to connect the various packages of the library together.","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"Going through this tutorial should take you about 20 minutes.","category":"page"},{"location":"tutorial/#Installation","page":"Overarching tutorial","title":"Installation","text":"","category":"section"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"To install DynamicalSystems.jl, simply do:","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"using Pkg; Pkg.add(\"DynamicalSystems\")","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"As discussed in the contents page, this installs several packages for the Julia language, that are all exported under a common name. To use them, simply do:","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"using DynamicalSystems","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"in your Julia session.","category":"page"},{"location":"tutorial/#Core-components","page":"Overarching tutorial","title":"Core components","text":"","category":"section"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"The individual packages that compose DynamicalSystems interact flawlessly with each other because of the following two components:","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"The StateSpaceSet, which represents numerical data. They can be observed or measured from experiments, sampled trajectories of dynamical systems, or just unordered sets in a state space. A StateSpaceSet is a container of equally-sized points, representing multivariate timeseries or multivariate datasets. Timeseries, which are univariate sets, are represented by the AbstractVector{<:Real} Julia base type.\nThe DynamicalSystem, which is the abstract representation of a dynamical system with a known dynamic evolution rule. DynamicalSystem defines an extendable interface, but typically one uses existing implementations such as DeterministicIteratedMap or CoupledODEs.","category":"page"},{"location":"tutorial/#Making-dynamical-systems","page":"Overarching tutorial","title":"Making dynamical systems","text":"","category":"section"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"In the majority of cases, to make a dynamical system one needs three things:","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"The dynamic rule f: A Julia function that provides the instructions of how to evolve the dynamical system in time.\nThe state u: An array-like container that contains the variables of the dynamical system and also defines the starting state of the system.\nThe parameters p: An arbitrary container that parameterizes f.","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"For most concrete implementations of DynamicalSystem there are two ways of defining f, u. The distinction is done on whether f is defined as an in-place (iip) function or out-of-place (oop) function.","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"oop : f must be in the form f(u, p, t) -> out   which means that given a state u::SVector{<:Real} and some parameter container   p it returns the output of f as an SVector{<:Real} (static vector).\niip : f must be in the form f!(out, u, p, t)   which means that given a state u::AbstractArray{<:Real} and some parameter container p,   it writes in-place the output of f in out::AbstractArray{<:Real}.   The function must return nothing as a final statement.","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"t stands for current time in both cases. iip is suggested for systems with high dimension and oop for small. The break-even point is between 10 to 100 dimensions but should be benchmarked on a case-by-case basis as it depends on the complexity of f.","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"note: Autonomous vs non-autonomous systems\nWhether the dynamical system is autonomous (f doesn't depend on time) or not, it is still necessary to include t as an argument to f. Some algorithms utilize this information, some do not, but we prefer to keep a consistent interface either way.","category":"page"},{"location":"tutorial/#Example:-Henon-map","page":"Overarching tutorial","title":"Example: Henon map","text":"","category":"section"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"Let's make the Henon map, defined as","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"beginaligned\nx_n+1 = 1 - ax^2_n+y_n \ny_n+1  = bx_n\nendaligned","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"with parameters a = 14 b = 03.","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"First, we define the dynamic rule as a standard Julia function. Since the dynamical system is only two-dimensional, we should use the out-of-place form that returns an SVector with the next state:","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"using DynamicalSystems\n\nfunction henon_rule(u, p, n) # here `n` is \"time\", but we don't use it.\n    x, y = u # system state\n    a, b = p # system parameters\n    xn = 1.0 - a*x^2 + y\n    yn = b*x\n    return SVector(xn, yn)\nend","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"Then, we define initial state and parameters","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"u0 = [0.2, 0.3]\np0 = [1.4, 0.3]","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"Lastly, we give these three to the DeterministicIteratedMap:","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"henon = DeterministicIteratedMap(henon_rule, u0, p0)","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"henon is a DynamicalSystem, one of the two core structures of the library. They can evolved interactively, and queried, using the interface defined by DynamicalSystem. The simplest thing you can do with a DynamicalSystem is to get its trajectory:","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"total_time = 10_000\nX, t = trajectory(henon, total_time)","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"X","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"X is a StateSpaceSet, the second of the core structures of the library. We'll see below how, and where, to use a StateSpaceset, but for now let's just do a scatter plot","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"using CairoMakie\nscatter(X[:, 1], X[:, 2])","category":"page"},{"location":"tutorial/#Example:-Lorenz96","page":"Overarching tutorial","title":"Example: Lorenz96","text":"","category":"section"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"Let's also make another dynamical system, the Lorenz96 model:","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"fracdx_idt = (x_i+1-x_i-2)x_i-1 - x_i + F","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"for i in 1 ldots N and N+j=j.","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"Here, instead of a discrete time map we have N coupled ordinary differential equations. However, creating the dynamical system works out just like above, but using CoupledODEs instead of DeterministicIteratedMap.","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"First, we make the dynamic rule function. Since this dynamical system can be arbitrarily high-dimensional, we prefer to use the in-place form for f, overwriting in place the rate of change in a pre-allocated container. It is customary to append the name of functions that modify their arguments in-place with a bang (!).","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"function lorenz96_rule!(du, u, p, t)\n    F = p[1]; N = length(u)\n    # 3 edge cases\n    du[1] = (u[2] - u[N - 1]) * u[N] - u[1] + F\n    du[2] = (u[3] - u[N]) * u[1] - u[2] + F\n    du[N] = (u[1] - u[N - 2]) * u[N - 1] - u[N] + F\n    # then the general case\n    for n in 3:(N - 1)\n        du[n] = (u[n + 1] - u[n - 2]) * u[n - 1] - u[n] + F\n    end\n    return nothing # always `return nothing` for in-place form!\nend","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"then, like before, we define an initial state and parameters, and initialize the system","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"N = 6\nu0 = range(0.1, 1; length = N)\np0 = [8.0]\nlorenz96 = CoupledODEs(lorenz96_rule!, u0, p0)","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"and, again like before, we may obtain a trajectory the same way","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"total_time = 12.5\nsampling_time = 0.02\nY, t = trajectory(lorenz96, total_time; Ttr = 2.2, Δt = sampling_time)\nY","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"We can't scatterplot something 6-dimensional but we can visualize all timeseries","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"fig = Figure()\nax = Axis(fig[1, 1]; xlabel = \"time\", ylabel = \"variable\")\nfor var in columns(Y)\n    lines!(ax, t, var)\nend\nfig","category":"page"},{"location":"tutorial/#ODE-solving","page":"Overarching tutorial","title":"ODE solving","text":"","category":"section"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"Continuous time dynamical systems are evolved through DifferentialEquations.jl. When initializing a CoupledODEs you can tune the solver properties to your heart's content using any of the ODE solvers and any of the common solver options. For example:","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"using OrdinaryDiffEq # accessing the ODE solvers\ndiffeq = (alg = Vern9(), abstol = 1e-9, reltol = 1e-9)\nlorenz96_vern = ContinuousDynamicalSystem(lorenz96_rule!, u0, p0; diffeq)","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"Y, t = trajectory(lorenz96_vern, total_time; Ttr = 2.2, Δt = sampling_time)\nY[end]","category":"page"},{"location":"tutorial/#Using-dynamical-systems","page":"Overarching tutorial","title":"Using dynamical systems","text":"","category":"section"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"You may use the DynamicalSystem interface to develop algorithms that utilize dynamical systems with a known evolution rule. The two main packages of the library that do this are ChaosTools and Attractors. For example, you may want to compute the Lyapunov spectrum of the Lorenz96 system from above. This is as easy as calling the lyapunovspectrum function with lorenz96","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"steps = 10_000\nlyapunovspectrum(lorenz96, steps)","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"As expected, there is at least one positive Lyapunov exponent, because the system is chaotic, and at least one zero Lyapunov exponent, because the system is continuous time.","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"Alternatively, you may want to estimate the basins of attraction of a multistable dynamical system. The Henon map is \"multistable\" in the sense that some initial conditions diverge to infinity, and some others converge to a chaotic attractor. Computing these basins of attraction is simple with Attractors, and would work as follows:","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"# define a state space grid to compute the basins on:\nxg = yg = range(-2, 2; length = 201)\n# find attractors using recurrences in state space:\nmapper = AttractorsViaRecurrences(henon, (xg, yg); sparse = false)\n# compute the full basins of attraction:\nbasins, attractors = basins_of_attraction(mapper; show_progress = false)","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"fig, ax = heatmap(xg, yg, basins)\nx, y = columns(X) # attractor of Henon map\nscatter!(ax, x, y; color = \"black\")\nfig","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"You could also be using a DynamicalSystem instance directly to build your own algorithm if it isn't already implemented (and then later contribute it so it is implemented ;) ). A dynamical system can be evolved forwards in time using step!:","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"henon","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"Notice how the time is not 0, because henon has already been stepped when we called the function basins_of_attraction with it. We can step it more:","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"step!(henon)","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"step!(henon, 2)","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"For more information on how to directly use DynamicalSystem instances, see the documentation of DynamicalSystemsBase.","category":"page"},{"location":"tutorial/#State-space-sets","page":"Overarching tutorial","title":"State space sets","text":"","category":"section"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"Let's recall that the output of the trajectory function is a StateSpaceSet:","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"X","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"It is printed like a matrix where each column is the timeseries of each dynamic variable. In reality, it is a vector of statically sized vectors (for performance reasons). When indexed with 1 index, it behaves like a vector of vectors","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"X[1]","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"X[2:5]","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"When indexed with two indices, it behaves like a matrix","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"X[2:5, 2]","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"When iterated, it iterates over the contained points","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"for (i, point) in enumerate(X)\n    @show point\n    i > 5 && break\nend","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"map(point -> point[1] + point[2], X)","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"The columns of the set are obtained with the convenience columns function","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"x, y = columns(X)\nsummary.((x, y))","category":"page"},{"location":"tutorial/#Using-state-space-sets","page":"Overarching tutorial","title":"Using state space sets","text":"","category":"section"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"Several packages of the library deal with StateSpaceSets.","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"You could use ComplexityMeasures to obtain the entropy, or other complexity measures, of a given set. Below, we obtain the entropy of the natural density of the chaotic attractor by partitioning into a histogram of approximately 50 bins per dimension:","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"prob_est = ValueHistogram(50)\nentropy(prob_est, X)","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"Alternatively, you could use FractalDimensions to get the fractal dimensions of the chaotic attractor of the henon map using the Grassberger-Procaccia algorithm:","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"grassberger_proccacia_dim(X)","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"Or, you could obtain a recurrence matrix of a state space set with RecurrenceAnalysis","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"R = RecurrenceMatrix(Y, 8.0)\nRg = grayscale(R)\nrr = recurrencerate(R)\nheatmap(Rg; colormap = :grays,\n    axis = (title = \"recurrence rate = $(rr)\", aspect = 1,)\n)","category":"page"},{"location":"tutorial/#More-nonlinear-timeseries-analysis","page":"Overarching tutorial","title":"More nonlinear timeseries analysis","text":"","category":"section"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"A trajectory of a known dynamical system is one way to obtain a StateSpaceSet. However, another common way is via a delay coordinates embedding of a measured/observed timeseries. For example, we could use optimal_separated_de from DelayEmbeddings to create an optimized delay coordinates embedding of a timeseries","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"w = Y[:, 1] # first variable of Lorenz96\n𝒟, τ, e = optimal_separated_de(w)\n𝒟","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"and compare","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"fig = Figure()\naxs = [Axis3(fig[1, i]) for i in 1:2]\nfor (S, ax) in zip((Y, 𝒟), axs)\n    lines!(ax, S[:, 1], S[:, 2], S[:, 3])\nend\nfig","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"Since 𝒟 is just another state space set, we could be using any of the above analysis pipelines on it just as easily.","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"The last package to mention here is TimeseriesSurrogates, which ties with all other observed/measured data analysis by providing a framework for confidence/hypothesis testing. For example, if we had a measured timeseries but we were not sure whether it represents a deterministic system with structure in the state space, or mostly noise, we could do a surrogate test. For this, we use surrogenerator and RandomFourier from TimeseriesSurrogates, and the generalized_dim from FractalDimensions (because it performs better in noisy sets)","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"x = X[:, 1] # Henon map timeseries\n# contaminate with noise\nusing Random: Xoshiro\nrng = Xoshiro(1234)\nx .+= randn(rng, length(x))/100\n# compute noise-contaminated fractal dim.\nΔ_orig = generalized_dim(embed(x, 2, 1))","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"And we do the surrogate test","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"surrogate_method = RandomFourier()\nsgen = surrogenerator(x, surrogate_method, rng)\n\nΔ_surr = map(1:1000) do i\n    s = sgen()\n    generalized_dim(embed(s, 2, 1))\nend","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"and visualize the test result","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"fig, ax = hist(Δ_surr)\nvlines!(ax, Δ_orig)\nfig","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"since the real value is outside the distribution we have confidence the data are not pure noise.","category":"page"},{"location":"tutorial/#Integration-with-ModelingToolkit.jl","page":"Overarching tutorial","title":"Integration with ModelingToolkit.jl","text":"","category":"section"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"DynamicalSystems.jl understands when a model has been generated via ModelingToolkit.jl. The symbolic variables used in ModelingToolkit.jl can be used to access the state or parameters of the dynamical system.","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"To access this functionality, the DynamicalSystem must be created from a DEProblem of the SciML ecosystem, and the DEProblem itself must be created from a ModelingToolkit.jl model.","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"note: ProcessBasedModelling.jl\nProcessBasedModelling.jl is an extension to ModelingToolkit.jl for creating models from a set of equations. It has been designed to be useful for scenarios applicable to a typical nonlinear dynamics analysis workflow, and provides better error messages during system construction than MTK. Have a look at its docs!","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"Let's create a the Roessler system as an MTK model:","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"using ModelingToolkit\n\n@variables t # use unitless time\nD = Differential(t)\n@mtkmodel Roessler begin\n    @parameters begin\n        a = 0.2\n        b = 0.2\n        c = 5.7\n    end\n    @variables begin\n        x(t) = 1.0\n        y(t) = 0.0\n        z(t) = 0.0\n        nlt(t) # nonlinear term\n    end\n    @equations begin\n        D(x) ~ -y -z\n        D(y) ~ x + a*y\n        D(z) ~ b + nlt\n        nlt ~ z*(x - c)\n    end\nend\n\n@mtkbuild model = Roessler()","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"this model can then be made into an ODEProblem:","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"prob = ODEProblem(model)","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"(notice that because we specified initial values for all parameters and variables during the model creation  we do need to provide additional initial values)","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"Now, this problem can be made into a CoupledODEs:","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"roessler = CoupledODEs(prob)","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"This dynamical system instance can be used in the rest of the library like anything else. Additionally, you can \"observe\" referenced symbolic variables:","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"observe_state(roessler, model.x)","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"observe_state(roessler, model.nlt)","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"These observables can also be used in the GUI visualization interactive_trajectory_timeseries.","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"You can also symbolically alter parameters","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"current_parameter(roessler, model.c)","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"set_parameter!(roessler, model.c, 5.0)","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"current_parameter(roessler, model.c)","category":"page"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"This symbolic indexing can be given anywhere in the ecosystem where you would be altering the parameters.","category":"page"},{"location":"tutorial/#Core-components-reference","page":"Overarching tutorial","title":"Core components reference","text":"","category":"section"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"StateSpaceSet\nDynamicalSystem","category":"page"},{"location":"tutorial/#StateSpaceSets.StateSpaceSet","page":"Overarching tutorial","title":"StateSpaceSets.StateSpaceSet","text":"StateSpaceSet{D, T} <: AbstractStateSpaceSet{D,T}\n\nA dedicated interface for sets in a state space. It is an ordered container of equally-sized points of length D. Each point is represented by SVector{D, T}. The data are a standard Julia Vector{SVector}, and can be obtained with vec(ssset::StateSpaceSet). Typically the order of points in the set is the time direction, but it doesn't have to be.\n\nWhen indexed with 1 index, StateSpaceSet is like a vector of points. When indexed with 2 indices it behaves like a matrix that has each of the columns be the timeseries of each of the variables. When iterated over, it iterates over its contained points. See description of indexing below for more.\n\nStateSpaceSet also supports almost all sensible vector operations like append!, push!, hcat, eachrow, among others.\n\nDescription of indexing\n\nIn the following let i, j be integers, typeof(X) <: AbstractStateSpaceSet and v1, v2 be <: AbstractVector{Int} (v1, v2 could also be ranges, and for performance benefits make v2 an SVector{Int}).\n\nX[i] == X[i, :] gives the ith point (returns an SVector)\nX[v1] == X[v1, :], returns a StateSpaceSet with the points in those indices.\nX[:, j] gives the jth variable timeseries (or collection), as Vector\nX[v1, v2], X[:, v2] returns a StateSpaceSet with the appropriate entries (first indices being \"time\"/point index, while second being variables)\nX[i, j] value of the jth variable, at the ith timepoint\n\nUse Matrix(ssset) or StateSpaceSet(matrix) to convert. It is assumed that each column of the matrix is one variable. If you have various timeseries vectors x, y, z, ... pass them like StateSpaceSet(x, y, z, ...). You can use columns(dataset) to obtain the reverse, i.e. all columns of the dataset in a tuple.\n\n\n\n\n\n","category":"type"},{"location":"tutorial/#DynamicalSystemsBase.DynamicalSystem","page":"Overarching tutorial","title":"DynamicalSystemsBase.DynamicalSystem","text":"DynamicalSystem\n\nDynamicalSystem is an abstract supertype encompassing all concrete implementations of what counts as a \"dynamical system\" in the DynamicalSystems.jl library.\n\nAll concrete implementations of DynamicalSystem can be iteratively evolved in time via the step! function. Hence, most library functions that evolve the system will mutate its current state and/or parameters. See the documentation online for implications this has for parallelization.\n\nDynamicalSystem is further separated into two abstract types: ContinuousTimeDynamicalSystem, DiscreteTimeDynamicalSystem. The simplest and most common concrete implementations of a DynamicalSystem are DeterministicIteratedMap or CoupledODEs.\n\nDescription\n\nA DynamicalSystem represents the time evolution of a state in a state space. It mainly encapsulates three things:\n\nA state, typically referred to as u, with initial value u0. The space that u occupies is the state space of ds and the length of u is the dimension of ds (and of the state space).\nA dynamic rule, typically referred to as f, that dictates how the state evolves/changes with time when calling the step! function. f is typically a standard Julia function, see the online documentation for examples.\nA parameter container p that parameterizes f. p can be anything, but in general it is recommended to be a type-stable mutable container.\n\nIn sort, any set of quantities that change in time can be considered a dynamical system, however the concrete subtypes of DynamicalSystem are much more specific in their scope. Concrete subtypes typically also contain more information than the above 3 items.\n\nIn this scope dynamical systems have a known dynamic rule f. Finite measured or sampled data from a dynamical system are represented using StateSpaceSet. Such data are obtained from the trajectory function or from an experimental measurement of a dynamical system with an unknown dynamic rule.\n\nSee also the DynamicalSystems.jl tutorial online for examples making dynamical systems.\n\nIntegration with ModelingToolkit.jl\n\nDynamical systems that have been constructed from DEProblems that themselves have been constructed from ModelingToolkit.jl keep a reference to the symbolic model and all symbolic variables. Accessing a DynamicalSystem using symbolic variables is possible via the functions observe_state, set_state!, current_parameter and set_parameter!. The referenced MTK model corresponding to the dynamical system can be obtained with model = referrenced_sciml_model(ds::DynamicalSystem).\n\nSee also the DynamicalSystems.jl tutorial online for an example.\n\nwarn: ModelingToolkit.jl v9\nIn ModelingToolkit.jl v9 the default split behavior of the parameter container is true. This means that the parameter container is no longer a Vector{Float64} by default, which means that you cannot use integers to access parameters. It is recommended to keep split = true (default) and only access parameters via their symbolic parameter binding. Use structural_simplify(sys; split = false) to allow accessing parameters with integers again.\n\nAPI\n\nThe API that DynamicalSystem employs is composed of the functions listed below. Once a concrete instance of a subtype of DynamicalSystem is obtained, it can queried or altered with the following functions.\n\nThe main use of a concrete dynamical system instance is to provide it to downstream functions such as lyapunovspectrum from ChaosTools.jl or basins_of_attraction from Attractors.jl. A typical user will likely not utilize directly the following API, unless when developing new algorithm implementations that use dynamical systems.\n\nAPI - obtain information\n\nds(t) with ds an instance of DynamicalSystem: return the state of ds at time t. For continuous time systems this interpolates and extrapolates, while for discrete time systems it only works if t is the current time.\ncurrent_state\ninitial_state\nobserve_state\ncurrent_parameters\ncurrent_parameter\ninitial_parameters\nisdeterministic\nisdiscretetime\ndynamic_rule\ncurrent_time\ninitial_time\nisinplace\nsuccessful_step\nreferrenced_sciml_model\n\nAPI - alter status\n\nreinit!\nset_state!\nset_parameter!\nset_parameters!\n\n\n\n\n\n","category":"type"},{"location":"tutorial/#Dynamical-system-implementations","page":"Overarching tutorial","title":"Dynamical system implementations","text":"","category":"section"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"DeterministicIteratedMap\nCoupledODEs\nStroboscopicMap\nPoincareMap\nProjectedDynamicalSystem\nArbitrarySteppable","category":"page"},{"location":"tutorial/#DynamicalSystemsBase.DeterministicIteratedMap","page":"Overarching tutorial","title":"DynamicalSystemsBase.DeterministicIteratedMap","text":"DeterministicIteratedMap <: DynamicalSystem\nDeterministicIteratedMap(f, u0, p = nothing; t0 = 0)\n\nA deterministic discrete time dynamical system defined by an iterated map as follows:\n\nvecu_n+1 = vecf(vecu_n p n)\n\nAn alias for DeterministicIteratedMap is DiscreteDynamicalSystem.\n\nOptionally configure the parameter container p and initial time t0.\n\nFor construction instructions regarding f, u0 see the DynamicalSystems.jl tutorial.\n\n\n\n\n\n","category":"type"},{"location":"tutorial/#DynamicalSystemsBase.CoupledODEs","page":"Overarching tutorial","title":"DynamicalSystemsBase.CoupledODEs","text":"CoupledODEs <: ContinuousTimeDynamicalSystem\nCoupledODEs(f, u0 [, p]; diffeq, t0 = 0.0)\n\nA deterministic continuous time dynamical system defined by a set of coupled ordinary differential equations as follows:\n\nfracdvecudt = vecf(vecu p t)\n\nAn alias for CoupledODE is ContinuousDynamicalSystem.\n\nOptionally provide the parameter container p and initial time as keyword t0.\n\nFor construction instructions regarding f, u0 see the DynamicalSystems.jl tutorial.\n\nDifferentialEquations.jl interfacing\n\nThe ODEs are evolved via the solvers of DifferentialEquations.jl. When initializing a CoupledODEs, you can specify the solver that will integrate f in time, along with any other integration options, using the diffeq keyword. For example you could use diffeq = (abstol = 1e-9, reltol = 1e-9). If you want to specify a solver, do so by using the keyword alg, e.g.: diffeq = (alg = Tsit5(), reltol = 1e-6). This requires you to have been first using OrdinaryDiffEq to access the solvers. The default diffeq is:\n\n(alg = Tsit5(; stagelimiter! = triviallimiter!, steplimiter! = triviallimiter!, thread = static(false),), abstol = 1.0e-6, reltol = 1.0e-6)\n\ndiffeq keywords can also include callback for event handling .\n\nThe convenience constructors CoupledODEs(prob::ODEProblem [, diffeq]) and CoupledODEs(ds::CoupledODEs [, diffeq]) are also available. To integrate with ModelingToolkit.jl, the dynamical system must be created via the ODEProblem (which itself is created via ModelingToolkit.jl), see the Tutorial for an example.\n\nDev note: CoupledODEs is a light wrapper of ODEIntegrator from DifferentialEquations.jl. The integrator is available as the field integ, and the ODEProblem is integ.sol.prob. The convenience syntax ODEProblem(ds::CoupledODEs, tspan = (t0, Inf)) is available to extract the problem.\n\n\n\n\n\n","category":"type"},{"location":"tutorial/#DynamicalSystemsBase.StroboscopicMap","page":"Overarching tutorial","title":"DynamicalSystemsBase.StroboscopicMap","text":"StroboscopicMap <: DiscreteTimeDynamicalSystem\nStroboscopicMap(ds::CoupledODEs, period::Real) → smap\nStroboscopicMap(period::Real, f, u0, p = nothing; kwargs...)\n\nA discrete time dynamical system that produces iterations of a time-dependent (non-autonomous) CoupledODEs system exactly over a given period. The second signature first creates a CoupledODEs and then calls the first.\n\nStroboscopicMap follows the DynamicalSystem interface. In addition, the function set_period!(smap, period) is provided, that sets the period of the system to a new value (as if it was a parameter). As this system is in discrete time, current_time and initial_time are integers. The initial time is always 0, because current_time counts elapsed periods. Call these functions on the parent of StroboscopicMap to obtain the corresponding continuous time. In contrast, reinit! expects t0 in continuous time.\n\nThe convenience constructor\n\nStroboscopicMap(T::Real, f, u0, p = nothing; diffeq, t0 = 0) → smap\n\nis also provided.\n\nSee also PoincareMap.\n\n\n\n\n\n","category":"type"},{"location":"tutorial/#DynamicalSystemsBase.PoincareMap","page":"Overarching tutorial","title":"DynamicalSystemsBase.PoincareMap","text":"PoincareMap <: DiscreteTimeDynamicalSystem\nPoincareMap(ds::CoupledODEs, plane; kwargs...) → pmap\n\nA discrete time dynamical system that produces iterations over the Poincaré map[DatserisParlitz2022] of the given continuous time ds. This map is defined as the sequence of points on the Poincaré surface of section, which is defined by the plane argument.\n\nSee also StroboscopicMap, poincaresos.\n\nKeyword arguments\n\ndirection = -1: Only crossings with sign(direction) are considered to belong to the surface of section. Negative direction means going from less than b to greater than b.\nu0 = nothing: Specify an initial state.\nrootkw = (xrtol = 1e-6, atol = 1e-8): A NamedTuple of keyword arguments passed to find_zero from Roots.jl.\nTmax = 1e3: The argument Tmax exists so that the integrator can terminate instead of being evolved for infinite time, to avoid cases where iteration would continue forever for ill-defined hyperplanes or for convergence to fixed points, where the trajectory would never cross again the hyperplane. If during one step! the system has been evolved for more than Tmax, then step!(pmap) will terminate and error.\n\nDescription\n\nThe Poincaré surface of section is defined as sequential transversal crossings a trajectory has with any arbitrary manifold, but here the manifold must be a hyperplane. PoincareMap iterates over the crossings of the section.\n\nIf the state of ds is mathbfu = (u_1 ldots u_D) then the equation defining a hyperplane is\n\na_1u_1 + dots + a_Du_D = mathbfacdotmathbfu=b\n\nwhere mathbfa b are the parameters of the hyperplane.\n\nIn code, plane can be either:\n\nA Tuple{Int, <: Real}, like (j, r): the plane is defined as when the jth variable of the system equals the value r.\nA vector of length D+1. The first D elements of the vector correspond to mathbfa while the last element is b.\n\nPoincareMap uses ds, higher order interpolation from DifferentialEquations.jl, and root finding from Roots.jl, to create a high accuracy estimate of the section.\n\nPoincareMap follows the DynamicalSystem interface with the following adjustments:\n\ndimension(pmap) == dimension(ds), even though the Poincaré map is effectively 1 dimension less.\nLike StroboscopicMap time is discrete and counts the iterations on the surface of section. initial_time is always 0 and current_time is current iteration number.\nA new function current_crossing_time returns the real time corresponding to the latest crossing of the hyperplane, which is what the current_state(ds) corresponds to as well.\nFor the special case of plane being a Tuple{Int, <:Real}, a special reinit! method is allowed with input state of length D-1 instead of D, i.e., a reduced state already on the hyperplane that is then converted into the D dimensional state.\n\nExample\n\nusing DynamicalSystemsBase\nds = Systems.rikitake(zeros(3); μ = 0.47, α = 1.0)\npmap = poincaremap(ds, (3, 0.0))\nstep!(pmap)\nnext_state_on_psos = current_state(pmap)\n\n[DatserisParlitz2022]: Datseris & Parlitz 2022, Nonlinear Dynamics: A Concise Introduction Interlaced with Code, Springer Nature, Undergrad. Lect. Notes In Physics\n\n\n\n\n\n","category":"type"},{"location":"tutorial/#DynamicalSystemsBase.ProjectedDynamicalSystem","page":"Overarching tutorial","title":"DynamicalSystemsBase.ProjectedDynamicalSystem","text":"ProjectedDynamicalSystem <: DynamicalSystem\nProjectedDynamicalSystem(ds::DynamicalSystem, projection, complete_state)\n\nA dynamical system that represents a projection of an existing ds on a (projected) space.\n\nThe projection defines the projected space. If projection isa AbstractVector{Int}, then the projected space is simply the variable indices that projection contains. Otherwise, projection can be an arbitrary function that given the state of the original system ds, returns the state in the projected space. In this case the projected space can be equal, or even higher-dimensional, than the original.\n\ncomplete_state produces the state for the original system from the projected state. complete_state can always be a function that given the projected state returns a state in the original space. However, if projection isa AbstractVector{Int}, then complete_state can also be a vector that contains the values of the remaining variables of the system, i.e., those not contained in the projected space. In this case the projected space needs to be lower-dimensional than the original.\n\nNotice that ProjectedDynamicalSystem does not require an invertible projection, complete_state is only used during reinit!. ProjectedDynamicalSystem is in fact a rather trivial wrapper of ds which steps it as normal in the original state space and only projects as a last step, e.g., during current_state.\n\nExamples\n\nCase 1: project 5-dimensional system to its last two dimensions.\n\nds = Systems.lorenz96(5)\nprojection = [4, 5]\ncomplete_state = [0.0, 0.0, 0.0] # completed state just in the plane of last two dimensions\nprods = ProjectedDynamicalSystem(ds, projection, complete_state)\nreinit!(prods, [0.2, 0.4])\nstep!(prods)\ncurrent_state(prods)\n\nCase 2: custom projection to general functions of state.\n\nds = Systems.lorenz96(5)\nprojection(u) = [sum(u), sqrt(u[1]^2 + u[2]^2)]\ncomplete_state(y) = repeat([y[1]/5], 5)\nprods = # same as in above example...\n\n\n\n\n\n","category":"type"},{"location":"tutorial/#DynamicalSystemsBase.ArbitrarySteppable","page":"Overarching tutorial","title":"DynamicalSystemsBase.ArbitrarySteppable","text":"ArbitrarySteppable <: DiscreteTimeDynamicalSystem\nArbitrarySteppable(\n    model, step!, extract_state, extract_parameters, reset_model!;\n    isdeterministic = true, set_state = reinit!,\n)\n\nA dynamical system generated by an arbitrary \"model\" that can be stepped in-place with some function step!(model) for 1 step. The state of the model is extracted by the extract_state(model) -> u function The parameters of the model are extracted by the extract_parameters(model) -> p function. The system may be re-initialized, via reinit!, with the reset_model! user-provided function that must have the call signature\n\nreset_model!(model, u, p)\n\ngiven a (potentially new) state u and parameter container p, both of which will default to the initial ones in the reinit! call.\n\nArbitrarySteppable exists to provide the DynamicalSystems.jl interface to models from other packages that could be used within the DynamicalSystems.jl library. ArbitrarySteppable follows the DynamicalSystem interface with the following adjustments:\n\ninitial_time is always 0, as time counts the steps the model has taken since creation or last reinit! call.\nset_state! is the same as reinit! by default. If not, the keyword argument set_state is a function set_state(model, u) that sets the state of the model to u.\nThe keyword isdeterministic should be set properly, as it decides whether downstream algorithms should error or not.\n\n\n\n\n\n","category":"type"},{"location":"tutorial/#Learn-more","page":"Overarching tutorial","title":"Learn more","text":"","category":"section"},{"location":"tutorial/","page":"Overarching tutorial","title":"Overarching tutorial","text":"To learn more, you need to visit the documentation pages of the modules that compose DynamicalSystems.jl. See the contents page for more!","category":"page"}]
}
