<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Detecting &amp; Categorizing Chaos · DynamicalSystems.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/logo.ico" rel="icon" type="image/x-icon"/><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="DynamicalSystems.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">DynamicalSystems.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../../contents/">Contents</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Dynamical systems</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../ds/general/">Dynamical System Definition</a></li><li><a class="tocitem" href="../../ds/predefined/">Predefined Dynamical Systems</a></li><li><a class="tocitem" href="../../embedding/dataset/">Numerical Data</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">DelayEmbeddings</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../embedding/reconstruction/">Delay Coordinates Embedding</a></li><li><a class="tocitem" href="../../embedding/estimate/">Optimal DCE Parameters</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox" checked/><label class="tocitem" for="menuitem-5"><span class="docs-label">ChaosTools</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../orbitdiagram/">Orbit Diagrams &amp; PSOS</a></li><li><a class="tocitem" href="../lyapunovs/">Lyapunov Exponents</a></li><li class="is-active"><a class="tocitem" href>Detecting &amp; Categorizing Chaos</a><ul class="internal"><li><a class="tocitem" href="#Generalized-Alignment-Index-1"><span>Generalized Alignment Index</span></a></li><li><a class="tocitem" href="#Predictability-of-a-chaotic-system-1"><span>Predictability of a chaotic system</span></a></li><li><a class="tocitem" href="#The-0-1-test-for-chaos-1"><span>The 0-1 test for chaos</span></a></li><li><a class="tocitem" href="#Expansion-entropy-1"><span>Expansion entropy</span></a></li></ul></li><li><a class="tocitem" href="../entropies/">Entropies and Dimensions</a></li><li><a class="tocitem" href="../nlts/">Nonlinear Timeseries Analysis</a></li><li><a class="tocitem" href="../periodicity/">Periodicity &amp; Ergodicity</a></li><li><a class="tocitem" href="../choosing/">Choosing a solver</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">RecurrenceAnalysis</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../rqa/rplots/">Recurrence Plots</a></li><li><a class="tocitem" href="../../rqa/quantification/">Recurrence Quantification Analysis</a></li><li><a class="tocitem" href="../../rqa/windowed/">Windowed RQA</a></li></ul></li><li><a class="tocitem" href="../../advanced/">Advanced Documentation</a></li><li><a class="tocitem" href="../../contributors_guide/">Contributor Guide</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">ChaosTools</a></li><li class="is-active"><a href>Detecting &amp; Categorizing Chaos</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Detecting &amp; Categorizing Chaos</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDynamics/DynamicalSystems.jl/blob/master/docs/src/chaos/chaos_detection.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Detecting-and-Categorizing-Chaos-1"><a class="docs-heading-anchor" href="#Detecting-and-Categorizing-Chaos-1">Detecting &amp; Categorizing Chaos</a><a class="docs-heading-anchor-permalink" href="#Detecting-and-Categorizing-Chaos-1" title="Permalink"></a></h1><p>Being able to detect and distinguish chaotic from regular behavior is crucial in the study of dynamical systems. Most of the time a positive maximum <a href="../lyapunovs/#ChaosTools.lyapunov"><code>lyapunov</code></a> exponent and a bounded system indicate chaos.</p><p>However, the convergence of the Lyapunov exponent can be slow, or even misleading, as the types of chaotic behavior vary with respect to their predictability. There are many alternatives, some more efficient and some more accurate in characterizing chaotic and regular motion. Some of these methods are included in <strong>DynamicalSystems.jl</strong>.</p><div class="admonition is-info"><header class="admonition-header">Performance depends on the solver</header><div class="admonition-body"><p>Notice that the performance of functions that use <code>ContinuousDynamicalSystem</code>s depend crucially on the chosen solver. Please see the documentation page on <a href="../choosing/#Choosing-a-solver-1">Choosing a solver</a> for an in-depth discussion.</p></div></div><h2 id="Generalized-Alignment-Index-1"><a class="docs-heading-anchor" href="#Generalized-Alignment-Index-1">Generalized Alignment Index</a><a class="docs-heading-anchor-permalink" href="#Generalized-Alignment-Index-1" title="Permalink"></a></h2><p>&quot;GALI&quot; for sort, is a method that relies on the fact that initially orthogonal deviation vectors tend to align towards the direction of the maximum Lyapunov exponent for chaotic motion. It is one of the most recent and cheapest methods for distinguishing chaotic and regular behavior, introduced first in 2007 by Skokos, Bountis &amp; Antonopoulos.</p><article class="docstring"><header><a class="docstring-binding" id="ChaosTools.gali" href="#ChaosTools.gali"><code>ChaosTools.gali</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">gali(ds::DynamicalSystem, tmax, k::Int | Q0; kwargs...) -&gt; GALI_k, t</code></pre><p>Compute <span>$\text{GALI}_k$</span><sup class="footnote-reference"><a id="citeref-Skokos2007" href="#footnote-Skokos2007">[Skokos2007]</a></sup> for a given <code>k</code> up to time <code>tmax</code>. Return <span>$\text{GALI}_k(t)$</span> and time vector <span>$t$</span>.</p><p>The third argument, which sets the order of <code>gali</code>, can be an integer <code>k</code>, or a matrix with its columns being the deviation vectors (then <code>k = size(Q0)[2]</code>). In the first case random orthonormal vectors are chosen.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>threshold = 1e-12</code> : If <code>GALI_k</code> falls below the <code>threshold</code> iteration is terminated.</li><li><code>dt = 1</code> : Time-step between deviation vector normalizations. For continuous systems this is approximate.</li><li><code>u0</code> : Initial state for the system. Defaults to <code>get_state(ds)</code>.</li><li><code>diffeq...</code> : Keyword arguments propagated into <code>init</code> of DifferentialEquations.jl. See <a href="../../ds/general/#DynamicalSystemsBase.trajectory"><code>trajectory</code></a> for examples. Only valid for continuous systems.</li></ul><p><strong>Description</strong></p><p>The Generalized Alignment Index, <span>$\text{GALI}_k$</span>, is an efficient (and very fast) indicator of chaotic or regular behavior type in <span>$D$</span>-dimensional Hamiltonian systems (<span>$D$</span> is number of variables). The <em>asymptotic</em> behavior of <span>$\text{GALI}_k(t)$</span> depends critically on the type of orbit resulting from the initial condition. If it is a chaotic orbit, then</p><div>\[\text{GALI}_k(t) \sim
\exp\left[\sum_{j=1}^k (\lambda_1 - \lambda_j)t \right]\]</div><p>with <span>$\lambda_j$</span> being the <code>j</code>-th Lyapunov exponent (see <a href="../lyapunovs/#ChaosTools.lyapunov"><code>lyapunov</code></a>, <a href="../lyapunovs/#ChaosTools.lyapunovs"><code>lyapunovs</code></a>). If on the other hand the orbit is regular, corresponding to movement in <span>$d$</span>-dimensional torus with <span>$1 \le d \le D/2$</span> then it holds</p><div>\[\text{GALI}_k(t) \sim
    \begin{cases}
      \text{const.}, &amp; \text{if} \;\; 2 \le k \le d  \; \; \text{and}
      \; \;d &gt; 1 \\
      t^{-(k - d)}, &amp; \text{if} \;\;  d &lt; k \le D - d \\
      t^{-(2k - D)}, &amp; \text{if} \;\;  D - d &lt; k \le D
    \end{cases}\]</div><p>Traditionally, if <span>$\text{GALI}_k(t)$</span> does not become less than the <code>threshold</code> until <code>tmax</code> the given orbit is said to be chaotic, otherwise it is regular.</p><p>Our implementation is not based on the original paper, but rather in the method described in<sup class="footnote-reference"><a id="citeref-Skokos2016b" href="#footnote-Skokos2016b">[Skokos2016b]</a></sup>, which uses the product of the singular values of <span>$A$</span>, a matrix that has as <em>columns</em> the deviation vectors.</p><p><strong>Performance Notes</strong></p><p>This function uses a <a href="../../advanced/#DynamicalSystemsBase.tangent_integrator"><code>tangent_integrator</code></a>. For loops over initial conditions and/or parameter values one should use the low level method that accepts an integrator, and <code>reinit!</code> it to new initial conditions. See the &quot;advanced documentation&quot; for info on the integrator object. The low level method is</p><pre><code class="language-none">ChaosTools.gali(tinteg, tmax, dt, threshold)</code></pre><p>(section 5.3.1 and ref. [85] therein), Lecture Notes in Physics <strong>915</strong>, Springer (2016)</p></div></section></article><hr/><h3 id="Discrete-Example-1"><a class="docs-heading-anchor" href="#Discrete-Example-1">Discrete Example</a><a class="docs-heading-anchor-permalink" href="#Discrete-Example-1" title="Permalink"></a></h3><p>We will use 3 coupled standard maps as an example for a discrete system:</p><pre><code class="language-julia">using DynamicalSystems
using PyPlot
M = 3; ks = 3ones(M); Γ = 0.1;
stable = [π, π, π, 0.01, 0, 0] .+ 0.1
chaotic = rand(2M)

ds = Systems.coupledstandardmaps(M, stable; ks=ks, Γ = Γ)</code></pre><pre><code class="language-none">6-dimensional discrete dynamical system
 state:       [3.24159, 3.24159, 3.24159, 0.11, 0.1, 0.1]
 e.o.m.:      CoupledStandardMaps
 in-place?    true
 jacobian:    CoupledStandardMaps
 parameters:  [3.0, 3.0, 3.0, 0.1]</code></pre><p>First, let&#39;s see the behavior of GALI for a stable orbit</p><pre><code class="language-julia">figure(figsize = (8,4))
tr = trajectory(ds, 100000)

subplot(1,2,1)
plot(tr[:,1], tr[:,1+M], alpha = 0.5,
label=&quot;stable&quot;,marker=&quot;o&quot;, ms=1, linewidth=0)
legend()

subplot(1,2,2)
for k in [4, 5, 6]
    g, t = gali(ds, 1e5, k; threshold=1e-12)
    lt = log10.(t); lg = log10.(g)
    plot(lt, lg, label=&quot;GALI_$(k)&quot;)
end
lt = 2:0.5:5.5
plot(lt, -2(lt .- 3), label=&quot;slope -2&quot;)
plot(lt, -4(lt .- 3), label=&quot;slope -4&quot;)
plot(lt, -6(lt .- 3), label=&quot;slope -6&quot;)

xlim(2, 5.5)
ylim(-12, 2)
legend()
tight_layout()</code></pre><p><img src="../gali_discrete_stable.png" alt="gali_discrete_stable"/></p><p>Now do the same for a chaotic orbit</p><pre><code class="language-julia">figure(figsize = (8,4))
tr = trajectory(ds, 100000, chaotic)
subplot(1,2,1)
plot(tr[:,1], tr[:,1+M], alpha = 0.5,
label=&quot;chaotic&quot;,marker=&quot;o&quot;, ms=1, linewidth=0)
legend()

subplot(1,2,2)
ls = lyapunovs(ds, 100000; u0 = chaotic)
for k in [2,3,6]
    ex = sum(ls[1] - ls[j] for j in 2:k)
    g, t = gali(ds, 1000, k; u0 = chaotic)
    semilogy(t, exp.(-ex.*t), label=&quot;exp. k=$k&quot;)
    semilogy(t, g, label=&quot;GALI_$(k)&quot;)
end
legend()
xlim(0,100)
ylim(1e-12, 1)</code></pre><p><img src="../gali_discrete_chaos.png" alt="gali_discrete_chaos"/></p><h3 id="Continuous-Example-1"><a class="docs-heading-anchor" href="#Continuous-Example-1">Continuous Example</a><a class="docs-heading-anchor-permalink" href="#Continuous-Example-1" title="Permalink"></a></h3><p>As an example of a continuous system, let&#39;s see the <a href="chaos/system_definition/#DynamicalSystems.Systems.henonheiles"><code>henonheiles</code></a>:</p><pre><code class="language-julia">using DynamicalSystems
using PyPlot, OrdinaryDiffEq
sp = [0, .295456, .407308431, 0] # stable periodic orbit: 1D torus
qp = [0, .483000, .278980390, 0] # quasiperiodic orbit: 2D torus
ch = [0, -0.25, 0.42081, 0]      # chaotic orbit
ds = Systems.henonheiles(sp)</code></pre><pre><code class="language-none">4-dimensional continuous dynamical system
 state:       [0.0, 0.295456, 0.407308, 0.0]
 e.o.m.:      hheom!
 in-place?    true
 jacobian:    hhjacob!
 parameters:  nothing</code></pre><p>First, we see the behavior with a stable periodic orbit</p><pre><code class="language-julia">figure(figsize = (8,4))
subplot(1,2,1)
dt = 1.0

diffeq = (abstol=1e-9, reltol=1e-9, alg = Tsit5(), maxiters = typemax(Int))
tr = trajectory(ds, 10000.0; dt=dt, diffeq...)
plot(tr[:,1], tr[:,3], alpha = 0.5,
label=&quot;sp&quot;,marker=&quot;o&quot;,markersize=2, linewidth=0)
legend()

subplot(1,2,2)
for k in [2,3,4]
    g, t = gali(ds, 10000.0, k; dt = dt, diffeq...)
    loglog(t, g, label=&quot;GALI_$(k)&quot;)
    if k &lt; 4
        loglog(t, 100 ./ t.^(k-1), label=&quot;slope -$(k-1)&quot;)
    else
        loglog(t, 10000 ./ t.^(2k-4), label=&quot;slope -$(2k-4)&quot;)
    end
end
ylim(1e-12, 2)
legend();</code></pre><p><img src="../gali_cont_stable.png" alt="gali_cont_stable"/></p><p>Next, let&#39;s see what happens with a quasi-periodic orbit. Don&#39;t forget to change the <code>u0</code> arguments!</p><pre><code class="language-julia">figure(figsize = (8,4))
subplot(1,2,1)
tr = trajectory(ds, 10000.0, qp; dt=dt, diffeq...)
plot(tr[:,1], tr[:,3], alpha = 0.5,
label=&quot;qp&quot;,marker=&quot;o&quot;,markersize=2, linewidth=0)
legend()

subplot(1,2,2)
for k in [2,3,4]
    g, t = gali(ds, 10000.0, k; u0 = qp, dt = dt, diffeq...)
    loglog(t, g, label=&quot;GALI_$(k)&quot;)
    if k == 2
        loglog(t, 1 ./ t.^(2k-4), label=&quot;slope -$(2k-4)&quot;)
    else
        loglog(t, 100 ./ t.^(2k-4), label=&quot;slope -$(2k-4)&quot;)
    end
end
ylim(1e-12, 2)
legend()
tight_layout()</code></pre><p><img src="../gali_cont_quasi.png" alt="gali_cont_quasi"/></p><p>Finally, here is GALI of a continuous system with a chaotic orbit</p><pre><code class="language-julia">figure(figsize = (8,4))
tr = trajectory(ds, 10000.0, ch; dt=dt, diffeq...)
subplot(1,2,1)
plot(tr[:,1], tr[:,3], alpha = 0.5,
label=&quot;ch&quot;,marker=&quot;o&quot;,markersize=2, linewidth=0)
legend()

subplot(1,2,2)
ls = lyapunovs(ds, 5000.0; dt=dt, u0 = ch, diffeq...)
for k in [2,3,4]
    ex = sum(ls[1] - ls[j] for j in 2:k)
    g, t = gali(ds, 1000, k; u0 = ch, dt = dt, diffeq...)
    semilogy(t, exp.(-ex.*t), label=&quot;exp. k=$k&quot;)
    semilogy(t, g, label=&quot;GALI_$(k)&quot;)
end
legend()
ylim(1e-16, 1)
tight_layout()</code></pre><p><img src="../gali_cont_chaos.png" alt="gali_cont_chaos"/></p><p>As you can see, the results of both discrete and continuous systems match very well the theory described in <a href="#ChaosTools.gali"><code>gali</code></a>.</p><h3 id="Using-GALI-1"><a class="docs-heading-anchor" href="#Using-GALI-1">Using GALI</a><a class="docs-heading-anchor-permalink" href="#Using-GALI-1" title="Permalink"></a></h3><p>No-one in their right mind would try to fit power-laws in order to distinguish between chaotic and regular behavior, like the above examples. These were just proofs that the method works as expected in all cases.</p><p>The most common usage of <span>$\text{GALI}_k$</span> is to define a (sufficiently) small amount of time and a (sufficiently) small threshold and see whether <span>$\text{GALI}_k$</span> stays below it, for a (sufficiently) big <span>$k$</span>.</p><p>The following is an example of advanced usage (see <a href="../../advanced/#Advanced-documentation-1">Advanced documentation</a>):</p><pre><code class="language-julia">using DynamicalSystems, PyPlot

function main(k)
# Measure of chaoticity: final time of gali_2
dens = 201
chaoticity = zeros(Int, dens, dens)

θs = ps = range(0, stop = 2π, length = dens+1)
ds = Systems.standardmap(k = k)

tinteg = tangent_integrator(ds, 2)

for (i, θ) ∈ enumerate(θs[1:dens])
    println(&quot;i = $(i)&quot;)
    for (j, p) ∈ enumerate(ps[1:dens])

        # new initial state is the system initial state
        u0 = SVector{2}(θ, p)
        reinit!(tinteg, u0, orthonormal(2,2))

        # Low-level call signature of gali:
        #  gali(tinteg, tmax, dt, threshold)
        chaoticity[i, j] = gali(tinteg, 500, 1, 1e-12)[2][end]
    end
end
figure()
pcolormesh(θs .- (θs[2] - θs[1])/2, ps .- (ps[2] - ps[1])/2,
chaoticity&#39;)
colorbar()
xlabel(&quot;\$\\theta\$&quot;)
ylabel(&quot;\$p\$&quot;)
return
end

main(0.9);</code></pre><p><img src="https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/chaos/gali_standardmap.png?raw=true" alt/></p><h3 id="Regular-orbits-in-the-Henon-Heiles-system-1"><a class="docs-heading-anchor" href="#Regular-orbits-in-the-Henon-Heiles-system-1">Regular orbits in the Henon-Heiles system</a><a class="docs-heading-anchor-permalink" href="#Regular-orbits-in-the-Henon-Heiles-system-1" title="Permalink"></a></h3><p>In this example we use the <a href="../orbitdiagram/#ChaosTools.poincaresos"><code>poincaresos</code></a> function to produce surfaces of section of the <a href="../../ds/predefined/#DynamicalSystemsBase.Systems.henonheiles"><code>Systems.henonheiles</code></a> system at different energies. At each energy <a href="#ChaosTools.gali"><code>gali</code></a> is used to color-code each initial condition according to how chaotic/regular it is, i.e. how much time does it need to exceed the <code>threshold</code> of <a href="#ChaosTools.gali"><code>gali</code></a>.</p><p>&lt;video width=&quot;100%&quot; height=&quot;auto&quot; controls&gt; &lt;source src=&quot;https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/chaos/gali<em>psos</em>henonhelies.mp4?raw=true&quot; type=&quot;video/mp4&quot;&gt; &lt;/video&gt;</p><p>You can download the video using <a href="https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/chaos/gali_psos_henonhelies.mp4?raw=true">this link</a>.</p><p>You can find the script that produced this animation in <code>DynamicalSystems/docs/coolanimations/gali_psos_henonhelies.jl</code>.</p><h2 id="Predictability-of-a-chaotic-system-1"><a class="docs-heading-anchor" href="#Predictability-of-a-chaotic-system-1">Predictability of a chaotic system</a><a class="docs-heading-anchor-permalink" href="#Predictability-of-a-chaotic-system-1" title="Permalink"></a></h2><p>Even if a system is &quot;formally&quot; chaotic, it can still be in phases where it is very predictable, because the correlation coefficient between nearby trajectories vanishes very slowly with time. <a href="https://www.nature.com/articles/s41598-017-01083-x">Wernecke, Sándor &amp; Gros</a> have developed an algorithm that allows one to classify a dynamical system to one of three categories: strongly chaotic, partially predictable chaos or regular (called <em>laminar</em> in their paper).</p><p>We have implemented their algorithm in the function <a href="#ChaosTools.predictability"><code>predictability</code></a>. <strong>Note</strong> that we set up the implementation to always return regular behavior for negative Lyapunov exponent. You may want to override this for research purposes.</p><article class="docstring"><header><a class="docstring-binding" id="ChaosTools.predictability" href="#ChaosTools.predictability"><code>ChaosTools.predictability</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">predictability(ds::DynamicalSystem; kwargs...) -&gt; chaos_type, ν, C</code></pre><p>Determine whether <code>ds</code> displays strongly chaotic, partially-predictable chaotic or regular behaviour, using the method by Wernecke et al. described in<sup class="footnote-reference"><a id="citeref-Wernecke2017" href="#footnote-Wernecke2017">[Wernecke2017]</a></sup>.</p><p>Return the type of the behavior, the cross-distance scaling coefficient <code>ν</code> and the correlation coefficient <code>C</code>. Typical values for <code>ν</code>, <code>C</code> and <code>chaos_type</code> are given in Table 2 of<sup class="footnote-reference"><a id="citeref-Wernecke2017" href="#footnote-Wernecke2017">[Wernecke2017]</a></sup>:</p><table><tr><th style="text-align: right"><code>chaos_type</code></th><th style="text-align: right"><code>ν</code></th><th style="text-align: right"><code>C</code></th></tr><tr><td style="text-align: right"><code>:SC</code></td><td style="text-align: right">0</td><td style="text-align: right">0</td></tr><tr><td style="text-align: right"><code>:PPC</code></td><td style="text-align: right">0</td><td style="text-align: right">1</td></tr><tr><td style="text-align: right"><code>:REG</code></td><td style="text-align: right">1</td><td style="text-align: right">1</td></tr></table><p><strong>Keyword Arguments</strong></p><ul><li><code>Ttr = 200</code> : Extra &quot;transient&quot; time to evolve the system before sampling from  the trajectory. Should be <code>Int</code> for discrete systems.</li><li><code>T_sample = 1e4</code> : Time to evolve the system for taking samples. Should be <code>Int</code> for discrete systems.</li><li><code>n_samples = 500</code> : Number of samples to take for use in calculating statistics.</li><li><code>λ_max = lyapunov(ds, 5000)</code> : Value to use for largest Lyapunov exponent for finding the Lyapunov prediction time. If it is less than zero a regular result is returned immediatelly.</li><li><code>d_tol = 1e-3</code> : tolerance distance to use for calculating Lyapunov prediction time.</li><li><code>T_multiplier = 10</code> : Multiplier from the Lyapunov prediction time to the evaluation time.</li><li><code>T_max = Inf</code> : Maximum time at which to evaluate trajectory distance. If the internally  computed evaluation time is larger than <code>T_max</code>, stop at <code>T_max</code> instead.</li><li><code>δ_range = 10.0 .^ (-9:-6)</code> : Range of initial condition perturbation distances  to use to determine scaling <code>ν</code>.</li><li><code>diffeq...</code> : Keyword arguments propagated into <code>init</code> of DifferentialEquations.jl. See <a href="../../ds/general/#DynamicalSystemsBase.trajectory"><code>trajectory</code></a> for examples. Only valid for continuous systems.</li></ul><p><strong>Description</strong></p><p>Samples points from a trajectory of the system to be used as initial conditions. Each of these initial conditions is randomly perturbed by a distance <code>δ</code>, and the trajectories for both the original and perturbed initial conditions are computed to the &#39;evaluation time&#39; <code>T</code>.</p><p>The average (over the samples) distance and cross-correlation coefficient of the state at time <code>T</code> is computed. This is repeated for a range of <code>δ</code> (defined by <code>δ_range</code>), and linear regression is used to determine how the distance and cross-correlation scale with <code>δ</code>, allowing for identification of chaos type.</p><p>The evaluation time <code>T</code> is calculated as <code>T = T_multiplier*Tλ</code>, where the Lyapunov prediction time <code>Tλ = log(d_tol/δ)/λ_max</code>. This may be very large if the <code>λ_max</code> is small, e.g. when the system is regular, so this internally computed time <code>T</code> can be overridden by a smaller <code>T_max</code> set by the user.</p><p><strong>Performance Notes</strong></p><p>For continuous systems, it is likely that the <code>maxiters</code> used by the integrators needs to be increased, e.g. to 1e9. This is part of the <code>diffeq</code> kwargs. In addition, be aware that this function does a <em>lot</em> of internal computations. It is operating in a different speed than e.g. <a href="../lyapunovs/#ChaosTools.lyapunov"><code>lyapunov</code></a>.</p></div></section></article><h3 id="Example-Hénon-Map-1"><a class="docs-heading-anchor" href="#Example-Hénon-Map-1">Example Hénon Map</a><a class="docs-heading-anchor-permalink" href="#Example-Hénon-Map-1" title="Permalink"></a></h3><p>We will create something similar to figure 2 of the paper, but for the Hénon map.</p><pre><code class="language-julia">figure()
he = Systems.henon()
as = 0.8:0.01:1.225
od = orbitdiagram(he, 1, 1, as; n = 2000, Ttr = 2000)
colors = Dict(:REG =&gt; &quot;b&quot;, :PPC =&gt; &quot;g&quot;, :SC =&gt; &quot;r&quot;)
for (i, a) in enumerate(as)
    set_parameter!(he, 1, a)
    chaos_type, ν, C = predictability(he; T_max = 400000, Ttr = 2000)
    scatter(a .* ones(length(od[i])), od[i], c = colors[chaos_type], s = 2,
    alpha = 0.05)
end
xlabel(&quot;\$a\$&quot;); ylabel(&quot;\$x\$&quot;)
title(&quot;predictability of Hénon map&quot;); tight_layout()</code></pre><p><img src="../partial_henon.png" alt="partial_henon"/></p><h2 id="The-0-1-test-for-chaos-1"><a class="docs-heading-anchor" href="#The-0-1-test-for-chaos-1">The 0-1 test for chaos</a><a class="docs-heading-anchor-permalink" href="#The-0-1-test-for-chaos-1" title="Permalink"></a></h2><p>The methods mentioned in this page so far require a <code>DynamicalSystem</code> instance. But of course this is not always the case. The so-called &quot;0 to 1&quot; test for chaos, by Gottwald &amp; Melbourne, takes as an input a timeseries and outputs a boolean <code>true</code> if the timeseries is chaotic or <code>false</code> if it is not.</p><p>Notice that the method does have a lot of caveats, so you should read the review paper before using.</p><article class="docstring"><header><a class="docstring-binding" id="ChaosTools.testchaos01" href="#ChaosTools.testchaos01"><code>ChaosTools.testchaos01</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">testchaos01(φ::Vector [, cs, N0]) -&gt; chaotic?</code></pre><p>Perform the so called &quot;0-1&quot; test for chaos introduced by Gottwald and Melbourne<sup class="footnote-reference"><a id="citeref-Gottwald2016" href="#footnote-Gottwald2016">[Gottwald2016]</a></sup> on the timeseries <code>φ</code>. Return <code>true</code> if <code>φ</code> is chaotic, <code>false</code> otherwise.</p><p><strong>Description</strong></p><p>This method tests if the given timeseries is chaotic or not by transforming it into a two-dimensional diffusive process. If the timeseries is chaotic, the mean square displacement of the process grows as <code>sqrt(length(φ))</code>, while it stays constant if the timeseries is regular. The implementation here computes <code>K</code>, the correlation coefficient (median of <code>Kc for c ∈ cs</code>), and simply checks if <code>K &gt; 0.5</code>.</p><p>If you want to access the various <code>Kc</code> you should call the method <code>testchaos01(φ, c::Real, N0)</code> which returns <code>Kc</code>.</p><p><code>cs</code> defaults to <code>3π/5*rand(10) + π/4</code> and <code>N0</code>, the length of the two-dimensional process, is <code>N0 = length(φ)/10</code>.</p><p>Notice that for data sampled from continous dynamical systems, some care must be taken regarding the values of <code>cs</code>, see [1].</p></div></section></article><h2 id="Expansion-entropy-1"><a class="docs-heading-anchor" href="#Expansion-entropy-1">Expansion entropy</a><a class="docs-heading-anchor-permalink" href="#Expansion-entropy-1" title="Permalink"></a></h2><p>The expansion entropy is a quantity that is suggested by B. Hunt and E. Ott as a measure that can define chaos (so far no widely accepted definition of chaos exists). Positive expansion entropy means chaos.</p><article class="docstring"><header><a class="docstring-binding" id="ChaosTools.expansionentropy" href="#ChaosTools.expansionentropy"><code>ChaosTools.expansionentropy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">expansionentropy(ds::DynamicalSystem, sampler, restraining; kwargs...)</code></pre><p>Calculate the expansion entropy<sup class="footnote-reference"><a id="citeref-Hunt2015" href="#footnote-Hunt2015">[Hunt2015]</a></sup> of <code>ds</code>, in the restraining region <span>$S$</span> defined by <code>restraining</code>, by estimating the slope of the biggest linear region of the curve <span>$\log E_{t0+T, t0}(f, S)$</span> versus <span>$T$</span> (using <a href="../entropies/#ChaosTools.linear_region"><code>linear_region</code></a>). This is an approximation of the expansion entropy <span>$H_0$</span>, according to<sup class="footnote-reference"><a id="citeref-Hunt2015" href="#footnote-Hunt2015">[Hunt2015]</a></sup>.</p><p><code>sampler</code> is a 0-argument function that generates a random initial condition (a sample) of <code>ds</code>. <code>restraining</code> is a 1-argument function <code>restraining(u)</code> that given the state <code>u</code> it returns <code>true</code> if the state is inside the restraining region <span>$S$</span>.</p><p>Use <a href="#ChaosTools.boxregion"><code>boxregion</code></a> for an easy way to define <code>sampler</code> and <code>restraining</code> on a multidimension box.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>N = 1000</code> : Number of samples taken at each batch (same as <span>$N$</span> of [1]).</li><li><code>steps = 40</code> : The maximal steps for which the system will be run.</li><li><code>Ttr = 0</code> : Transient time to evolve each initial condition before starting to comute <span>$E$</span>. This is <code>t0</code> of [1] and of the following notation.</li><li><code>batches = 100</code> : Number of batches to run the calculation, see below.</li><li><code>diffeq...</code> : Other keywords are propagated to the solvers of DifferentialEquations.jl.</li></ul><p><strong>Description</strong></p><p><code>N</code> samples are initialized and propagated forwards in time (along with their tangent space). At every time <span>$t$</span> in <code>[t0+dt, t0+2dt, ... t0+steps*dt]</code> we calculate <span>$H$</span>:</p><div>\[H[t] = \log E_{t0+T, t0}(f, S),\]</div><p>with</p><div>\[E_{t0+T, t0}(f, S) = \frac 1 N \sum_{i&#39;} G(Df_{t0+t, t0}(x_i))\]</div><p>(using same notation as <sup class="footnote-reference"><a id="citeref-Hunt2015" href="#footnote-Hunt2015">[Hunt2015]</a></sup>). In principle <span>$E$</span> is the average largest possible growth ratio within the restraining region (sampled by the initial conditions). The summation is only over <span>$x_i$</span> that stay inside the region <span>$S$</span> defined by the boolean function <code>restraining</code>. This process is done by the <a href="#ChaosTools.expansionentropy_sample"><code>expansionentropy_sample</code></a> function.</p><p>Then, this is repeated for <code>batches</code> amount of times, as recommended in<sup class="footnote-reference"><a id="citeref-Hunt2015" href="#footnote-Hunt2015">[Hunt2015]</a></sup>. From all these batches, the mean and std of <span>$H$</span> is computed at every time point. This is done by the <a href="#ChaosTools.expansionentropy_batch"><code>expansionentropy_batch</code></a> function. When plotted versus <span>$t$</span>, these create the curves and error bars of e.g. Figs 2, 3 of [1].</p><p>This function <code>expansionentropy</code> simply returns the slope of the biggest linear region of the curve <span>$H$</span> versus <span>$t$</span>, which approximates the expansion entropy <span>$H_0$</span>. It is therefore <em>recommended</em> to use <a href="#ChaosTools.expansionentropy_batch"><code>expansionentropy_batch</code></a> directly and evaluate the result yourself, as this step is known to be inaccurate for non-chaotic systems (where <span>$H$</span> fluctuates strongly around 0).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ChaosTools.boxregion" href="#ChaosTools.boxregion"><code>ChaosTools.boxregion</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">boxregion(as, bs) -&gt; sampler, restraining</code></pre><p>Define a box in <span>$\mathbb{R}^d$</span> with edges the <code>as</code> and <code>bs</code> and then return two functions: <code>sampler</code>, which generates a random initial condition in that box and <code>restraining</code> that returns <code>true</code> if a given state is in the box.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ChaosTools.expansionentropy_sample" href="#ChaosTools.expansionentropy_sample"><code>ChaosTools.expansionentropy_sample</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">expansionentropy_sample(ds, sampler, restraining; kwargs...)</code></pre><p>Return <code>times, H</code> for one sample of <code>ds</code> (see <a href="#ChaosTools.expansionentropy"><code>expansionentropy</code></a>). Accepts the same argumets as <code>expansionentropy</code>, besides <code>batches</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ChaosTools.expansionentropy_batch" href="#ChaosTools.expansionentropy_batch"><code>ChaosTools.expansionentropy_batch</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">expansionentropy_batch(ds, sampler, restraining; kwargs...)</code></pre><p>Run <a href="#ChaosTools.expansionentropy_sample"><code>expansionentropy_sample</code></a> <code>batch</code> times, and return <code>times, mean(H), std(H)</code> for all resulting <code>H</code>, see <a href="#ChaosTools.expansionentropy"><code>expansionentropy</code></a>.</p><p>Accepts the same arguments as <code>expansionentropy</code>.</p></div></section></article><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-Skokos2007"><a class="tag is-link" href="#citeref-Skokos2007">Skokos2007</a>Skokos, C. H. <em>et al.</em>, Physica D <strong>231</strong>, pp 30–54 (2007)</li><li class="footnote" id="footnote-Skokos2016b"><a class="tag is-link" href="#citeref-Skokos2016b">Skokos2016b</a>Skokos, C. H. <em>et al.</em>, <em>Chaos Detection and Predictability</em> - Chapter 5</li><li class="footnote" id="footnote-Wernecke2017"><a class="tag is-link" href="#citeref-Wernecke2017">Wernecke2017</a>Wernecke, H., Sándor, B. &amp; Gros, C. <em>How to test for partially predictable chaos</em>. <a href="https://www.nature.com/articles/s41598-017-01083-x">Scientific Reports <strong>7</strong>, (2017)</a>.</li><li class="footnote" id="footnote-Gottwald2016"><a class="tag is-link" href="#citeref-Gottwald2016">Gottwald2016</a>Gottwald &amp; Melbourne, “The 0-1 test for chaos: A review” <a href="chaos/www.doi.org/10.1007/978-3-662-48410-4_7">Lect. Notes Phys., vol. 915, pp. 221–247, 2016.</a></li><li class="footnote" id="footnote-Hunt2015"><a class="tag is-link" href="#citeref-Hunt2015">Hunt2015</a>B. Hunt &amp; E. Ott, ‘Defining Chaos’, <a href="https://doi.org/10/gdtkcf">Chaos 25.9 (2015)</a></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../lyapunovs/">« Lyapunov Exponents</a><a class="docs-footer-nextpage" href="../entropies/">Entropies and Dimensions »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 16 November 2020 00:41">Monday 16 November 2020</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
