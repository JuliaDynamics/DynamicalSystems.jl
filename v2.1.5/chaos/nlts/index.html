<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Nonlinear Timeseries Analysis · DynamicalSystems.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/logo.ico" rel="icon" type="image/x-icon"/><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="DynamicalSystems.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DynamicalSystems.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../../contents/">Contents</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Dynamical systems</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../ds/general/">Dynamical System Definition</a></li><li><a class="tocitem" href="../../ds/predefined/">Predefined Dynamical Systems</a></li><li><a class="tocitem" href="../../embedding/dataset/">Numerical Data</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Entropies</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../entropies/api/">Entropies &amp; Probabilities</a></li><li><a class="tocitem" href="../../entropies/estimators/">Probabilities Estimators</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">DelayEmbeddings</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../embedding/reconstruction/">Delay Coordinates Embedding</a></li><li><a class="tocitem" href="../../embedding/traditional/">Traditional Optimal Embedding</a></li><li><a class="tocitem" href="../../embedding/unified/">Unified Optimal Embedding</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox" checked/><label class="tocitem" for="menuitem-6"><span class="docs-label">ChaosTools</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../orbitdiagram/">Orbit Diagrams &amp; PSOS</a></li><li><a class="tocitem" href="../lyapunovs/">Lyapunov Exponents</a></li><li><a class="tocitem" href="../chaos_detection/">Detecting &amp; Categorizing Chaos</a></li><li><a class="tocitem" href="../fractaldim/">Fractal Dimension</a></li><li class="is-active"><a class="tocitem" href>Nonlinear Timeseries Analysis</a><ul class="internal"><li><a class="tocitem" href="#Broomhead-King-Coordinates"><span>Broomhead-King Coordinates</span></a></li><li><a class="tocitem" href="#DyCA-Dynamical-Component-Analysis"><span>DyCA - Dynamical Component Analysis</span></a></li><li><a class="tocitem" href="#Return-time-statistics"><span>Return time statistics</span></a></li><li><a class="tocitem" href="#Nearest-Neighbor-Prediction"><span>Nearest Neighbor Prediction</span></a></li></ul></li><li><a class="tocitem" href="../periodicity/">Fixed points &amp; Periodicity</a></li><li><a class="tocitem" href="../basins/">Attractor Basins, Tipping Points</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">RecurrenceAnalysis</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../rqa/rplots/">Recurrence Plots</a></li><li><a class="tocitem" href="../../rqa/quantification/">Recurrence Quantification Analysis</a></li><li><a class="tocitem" href="../../rqa/windowed/">Windowed RQA</a></li><li><a class="tocitem" href="../../rqa/networks/">Recurrence Networks</a></li></ul></li><li><a class="tocitem" href="../../advanced/">Advanced Documentation</a></li><li><a class="tocitem" href="../../contributors_guide/">Contributor Guide</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">ChaosTools</a></li><li class="is-active"><a href>Nonlinear Timeseries Analysis</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Nonlinear Timeseries Analysis</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDynamics/DynamicalSystems.jl/blob/master/docs/src/chaos/nlts.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Nonlinear-Timeseries-Analysis"><a class="docs-heading-anchor" href="#Nonlinear-Timeseries-Analysis">Nonlinear Timeseries Analysis</a><a id="Nonlinear-Timeseries-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Nonlinear-Timeseries-Analysis" title="Permalink"></a></h1><h2 id="Broomhead-King-Coordinates"><a class="docs-heading-anchor" href="#Broomhead-King-Coordinates">Broomhead-King Coordinates</a><a id="Broomhead-King-Coordinates-1"></a><a class="docs-heading-anchor-permalink" href="#Broomhead-King-Coordinates" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ChaosTools.broomhead_king" href="#ChaosTools.broomhead_king"><code>ChaosTools.broomhead_king</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">broomhead_king(s::AbstractVector, d::Int) -&gt; U, S, Vtr</code></pre><p>Return the Broomhead-King coordinates of a timeseries <code>s</code> by performing <code>svd</code> on high-dimensional embedding if <code>s</code> with dimension <code>d</code> with minimum delay.</p><p><strong>Description</strong></p><p>Broomhead and King coordinates is an approach proposed in <sup class="footnote-reference"><a id="citeref-Broomhead1987" href="#footnote-Broomhead1987">[Broomhead1987]</a></sup> that applies the Karhunen–Loève theorem to delay coordinates embedding with smallest possible delay.</p><p>The function performs singular value decomposition on the <code>d</code>-dimensional matrix <span>$X$</span> of <span>$s$</span>,</p><p class="math-container">\[X = \frac{1}{\sqrt{N}}\left(
\begin{array}{cccc}
x_1 &amp; x_2 &amp; \ldots &amp; x_d \\
x_2 &amp; x_3 &amp; \ldots &amp; x_{d+1}\\
\vdots &amp; \vdots &amp; \vdots &amp; \vdots \\
x_{N-d+1} &amp; x_{N-d+2} &amp;\ldots &amp; x_N
\end{array}
\right) = U\cdot S \cdot V^{tr}.\]</p><p>where <span>$x := s - \bar{s}$</span>. The columns of <span>$U$</span> can then be used as a new coordinate system, and by considering the values of the singular values <span>$S$</span> you can decide how many columns of <span>$U$</span> are &quot;important&quot;. See the documentation page for example application.</p></div></section></article><hr/><p>This alternative/improvement of the traditional delay coordinates can be a very powerful tool. An example where it shines is noisy data where there is the effect of superficial dimensions due to noise.</p><p>Take the following example where we produce noisy data from a system and then use Broomhead-King coordinates as an alternative to &quot;vanilla&quot; delay coordinates:</p><pre><code class="language-julia hljs">using DynamicalSystems, PyPlot

ds = Systems.gissinger()
data = trajectory(ds, 1000.0, Δt = 0.05)
x = data[:, 1]

L = length(x)
s = x .+ 0.5rand(L) #add noise

U, S = broomhead_king(s, 40)
summary(U)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&quot;19962×40 Matrix{Float64}&quot;</code></pre><p>Now let&#39;s simply compare the above result with the one you get from doing a &quot;standard&quot; call to <a href="../../embedding/reconstruction/#DelayEmbeddings.embed"><code>embed</code></a>:</p><pre><code class="language-julia hljs">fig=figure(figsize= (10,6))
subplot(1,2,1)
plot(U[:, 1], U[:, 2])
title(&quot;Broomhead-King of s&quot;)

subplot(1,2,2)
R = embed(s, 2, 30)
plot(columns(R)...; color = &quot;C3&quot;)
title(&quot;2D embedding of s&quot;)
fig.tight_layout(pad=0.3)</code></pre><p>we have used the same system as in the <a href="../../embedding/reconstruction/#Delay-Coordinates-Embedding">Delay Coordinates Embedding</a> example, and picked the optimal delay time of <code>τ = 30</code> (for same <code>Δt = 0.05</code>). Regardless, the vanilla delay coordinates is much worse than the Broomhead-King coordinates.</p><h2 id="DyCA-Dynamical-Component-Analysis"><a class="docs-heading-anchor" href="#DyCA-Dynamical-Component-Analysis">DyCA - Dynamical Component Analysis</a><a id="DyCA-Dynamical-Component-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#DyCA-Dynamical-Component-Analysis" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ChaosTools.dyca" href="#ChaosTools.dyca"><code>ChaosTools.dyca</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dyca(data, eig_thresold) -&gt; eigenvalues, proj_mat, projected_data</code></pre><p>Compute the Dynamical Component analysis (DyCA) of the given <code>data</code> <sup class="footnote-reference"><a id="citeref-Uhl2018" href="#footnote-Uhl2018">[Uhl2018]</a></sup> used for dimensionality reduction.</p><p>Return the eigenvalues, projection matrix, and reduced-dimension data (which are just <code>data*proj_mat</code>).</p><p><strong>Keyword Arguments</strong></p><ul><li>norm_eigenvectors=false : if true, normalize the eigenvectors</li></ul><p><strong>Description</strong></p><p>Dynamical Component Analysis (DyCA) is a method to detect projection vectors to reduce the dimensionality of multi-variate, high-dimensional deterministic datasets. Unlike methods like PCA or ICA that make a stochasticity assumption, DyCA relies on a determinacy assumption on the time-series and is based on the solution of a generalized eigenvalue problem. After choosing an appropriate eigenvalue threshold and solving the eigenvalue problem, the obtained eigenvectors are used to project the high-dimensional dataset onto a lower dimension. The obtained eigenvalues measure the quality of the assumption of linear determinism for the investigated data. Furthermore, the number of the generalized eigenvalues with a value of approximately 1.0 are a measure of the number of linear equations contained in the dataset. This property is useful in detecting regions with highly deterministic parts in the time-series and also as a preprocessing step for reservoir computing of high-dimensional spatio-temporal data. </p><p>The generalised eigenvalue problem we solve is:</p><p class="math-container">\[C_1 C_0^{-1} C_1^{\top} \bar{u} = \lambda C_2 \bar{u}
\]</p><p>where <span>$C_0$</span> is the correlation matrix of the data with itself, <span>$C_1$</span> the correlation matrix of the data with its derivative, and <span>$C_2$</span> the correlation matrix of the derivative of the data with itself. The eigenvectors <span>$\bar{u}$</span> with eigenvalues approximately 1 and their <span>$C_1^{-1} C_2 u$</span> counterpart, form the space where the data is projected onto.</p></div></section></article><h2 id="Return-time-statistics"><a class="docs-heading-anchor" href="#Return-time-statistics">Return time statistics</a><a id="Return-time-statistics-1"></a><a class="docs-heading-anchor-permalink" href="#Return-time-statistics" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ChaosTools.mean_return_times" href="#ChaosTools.mean_return_times"><code>ChaosTools.mean_return_times</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mean_return_times(ds::DynamicalSystem, u₀, εs, T; kwargs...) → τ, c</code></pre><p>Return the mean return times <code>τ</code>, as well as the amount of returns <code>c</code>, for subsets of the state space of <code>ds</code> defined by <code>u₀, εs</code>. The <code>ds</code> is evolved for a maximum of <code>T</code> time. This function behaves similarly to <a href="#ChaosTools.exit_entry_times"><code>exit_entry_times</code></a> and thus see that one for the meaning of <code>u₀</code> and <code>εs</code>.</p><p>This function supports both discrete and continuous systems, however the optimizations done in discrete systems (where all nested <code>ε</code>-sets are checked at the same time), are not done here yet, which leads to disproportionally lower performance since each <code>ε</code>-related set is checked individually from start.</p><p>Continuous systems allow for the following keywords:</p><ul><li><code>i=10</code> How many points to interpolate the trajectory in-between steps to find candidate crossing regions.</li><li><code>dmin</code> If the trajectory is at least <code>dmin</code> distance away from <code>u0</code>, the algorithm that checks for crossings of the <code>ε</code>-set is not initiated. By default obtains the a value 4 times as large as the radius of the maximum ε-set.</li><li><code>diffeq...</code> All extra keywords are propagated to solvers of DifferentialEquations.jl, see <a href="../../ds/general/#DynamicalSystemsBase.trajectory"><code>trajectory</code></a>. It is strongly recommended to use high accuracy keywords here, e.g. <code>alg = Vern9(), reltol = 1e-12, abstol = 1e-12, maxiters = typemax(Int)</code>.</li></ul><p>For continuous systems <code>T, i, dmin</code> can be vectors with same size as <code>εs</code>, to help increase accuracy of small <code>ε</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ChaosTools.exit_entry_times" href="#ChaosTools.exit_entry_times"><code>ChaosTools.exit_entry_times</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">exit_entry_times(ds, u₀, εs, T; diffeq...) → exits, entries</code></pre><p>Collect exit and entry times for a ball/box centered at <code>u₀</code> with radii <code>εs</code> (see below), in the state space of the given discrete dynamical system (function not yet available for continuous systems). Return the exit and (re-)entry return times to the set(s), where each of these is a vector containing all collected times for the respective <code>ε</code>-radius set, for <code>ε ∈ εs</code>.</p><p>Use <code>transit_return(exits, entries)</code> to transform the output into transit and return times, and see also <a href="#ChaosTools.mean_return_times"><code>mean_return_times</code></a> for both continuous and discrete systems.</p><p><strong>Description</strong></p><p>Transit time statistics are important for the transport properties of dynamical systems<sup class="footnote-reference"><a id="citeref-Meiss1997" href="#footnote-Meiss1997">[Meiss1997]</a></sup> and can even be connected with the fractal dimension of chaotic sets<sup class="footnote-reference"><a id="citeref-Boev2014" href="#footnote-Boev2014">[Boev2014]</a></sup>.</p><p>The current algorithm collects exit and re-entry times to given sets in the state space, which are centered at <code>u₀</code> (<strong>algorithm always starts at <code>u₀</code></strong> and the initial state of <code>ds</code> is irrelevant). <code>εs</code> is always a <code>Vector</code>.</p><p>The sets around <code>u₀</code> are nested hyper-spheres of radius <code>ε ∈ εs</code>, if each entry of <code>εs</code> is a real number. The sets can also be hyper-rectangles (boxes), if each entry of <code>εs</code> is a vector itself. Then, the <code>i</code>-th box is defined by the space covered by <code>u0 .± εs[i]</code> (thus the actual box size is <code>2εs[i]</code>!).</p><p>The reason to input multiple <code>εs</code> at once is purely for performance.</p><p>For discrete systems, exit time is recorded immediatelly after exitting of the set, and re-entry is recorded immediatelly on re-entry. This means that if an orbit needs 1 step to leave the set and then it re-enters immediatelly on the next step, the return time is 1. For continuous systems high-order interpolation is done to accurately record the time of exactly crossing the <code>ε</code>-ball/box.</p></div></section></article><h2 id="Nearest-Neighbor-Prediction"><a class="docs-heading-anchor" href="#Nearest-Neighbor-Prediction">Nearest Neighbor Prediction</a><a id="Nearest-Neighbor-Prediction-1"></a><a class="docs-heading-anchor-permalink" href="#Nearest-Neighbor-Prediction" title="Permalink"></a></h2><p>Nearest neighbor timeseries prediction is a method commonly listed under nonlinear timeseries analysis. This is not part of DynamicalSystems.jl, because in JuliaDynamics we have a dedicated package for this, <a href="https://juliadynamics.github.io/TimeseriesPrediction.jl/dev/">TimeseriesPrediction.jl</a>.</p><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-Broomhead1987"><a class="tag is-link" href="#citeref-Broomhead1987">Broomhead1987</a>D. S. Broomhead, R. Jones and G. P. King, J. Phys. A <strong>20</strong>, 9, pp L563 (1987)</li><li class="footnote" id="footnote-Uhl2018"><a class="tag is-link" href="#citeref-Uhl2018">Uhl2018</a>B Seifert, K Korn, S Hartmann, C Uhl, <em>Dynamical Component Analysis (DYCA): Dimensionality Reduction for High-Dimensional Deterministic Time-Series</em>, 10.1109/mlsp.2018.8517024, 2018 IEEE 28th International Workshop on Machine Learning for Signal Processing (MLSP)</li><li class="footnote" id="footnote-Meiss1997"><a class="tag is-link" href="#citeref-Meiss1997">Meiss1997</a>Meiss, J. D. <em>Average exit time for volume-preserving maps</em>, Chaos (1997)](https://doi.org/10.1063/1.166245)</li><li class="footnote" id="footnote-Boev2014"><a class="tag is-link" href="#citeref-Boev2014">Boev2014</a>Boev, Vadivasova, &amp; Anishchenko, <em>Poincaré recurrence statistics as an indicator of chaos synchronization</em>, Chaos (2014)](https://doi.org/10.1063/1.4873721)</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../fractaldim/">« Fractal Dimension</a><a class="docs-footer-nextpage" href="../periodicity/">Fixed points &amp; Periodicity »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Sunday 12 December 2021 14:57">Sunday 12 December 2021</span>. Using Julia version 1.7.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
