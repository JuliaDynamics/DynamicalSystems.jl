<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Integrators · DynamicalSystems.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/logo.ico" rel="icon" type="image/x-icon"/><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="DynamicalSystems.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DynamicalSystems.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../../contents/">Contents</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3"><span class="docs-label">Dynamical systems</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../general/">Dynamical System Definition</a></li><li><a class="tocitem" href="../predefined/">Predefined Dynamical Systems</a></li><li><a class="tocitem" href="../../embedding/dataset/">Numerical Data</a></li><li class="is-active"><a class="tocitem" href>Integrators</a><ul class="internal"><li><a class="tocitem" href="#Available-integrators"><span>Available integrators</span></a></li><li><a class="tocitem" href="#Integrator-API"><span>Integrator API</span></a></li><li><a class="tocitem" href="#Using-callbacks-with-integrators"><span>Using callbacks with integrators</span></a></li><li><a class="tocitem" href="#Choosing-a-solver"><span>Choosing a solver</span></a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">DelayEmbeddings</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../embedding/reconstruction/">Delay Coordinates Embedding</a></li><li><a class="tocitem" href="../../embedding/traditional/">Traditional Optimal Embedding</a></li><li><a class="tocitem" href="../../embedding/unified/">Unified Optimal Embedding</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Entropies</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../entropies/api/">Entropies &amp; Probabilities</a></li><li><a class="tocitem" href="../../entropies/estimators/">Probabilities Estimators</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">ChaosTools</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../chaos/orbitdiagram/">Orbit Diagrams &amp; PSOS</a></li><li><a class="tocitem" href="../../chaos/lyapunovs/">Lyapunov Exponents</a></li><li><a class="tocitem" href="../../chaos/chaos_detection/">Detecting &amp; Categorizing Chaos</a></li><li><a class="tocitem" href="../../chaos/fractaldim/">Fractal Dimension</a></li><li><a class="tocitem" href="../../chaos/nlts/">Nonlinear Timeseries Analysis</a></li><li><a class="tocitem" href="../../chaos/periodicity/">Fixed points &amp; Periodicity</a></li><li><a class="tocitem" href="../../chaos/basins/">Attractors, Basins, Tipping Points</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">RecurrenceAnalysis</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../rqa/rplots/">Recurrence Plots</a></li><li><a class="tocitem" href="../../rqa/quantification/">Recurrence Quantification Analysis</a></li><li><a class="tocitem" href="../../rqa/windowed/">Windowed RQA</a></li><li><a class="tocitem" href="../../rqa/networks/">Recurrence Networks</a></li></ul></li><li><a class="tocitem" href="../../dynamicalsystems_interactive/">Interactive GUIs</a></li><li><a class="tocitem" href="../../contributors_guide/">Contributor Guide</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Dynamical systems</a></li><li class="is-active"><a href>Integrators</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Integrators</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDynamics/DynamicalSystems.jl/blob/main/docs/src/ds/integrators.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Integrators"><a class="docs-heading-anchor" href="#Integrators">Integrators</a><a id="Integrators-1"></a><a class="docs-heading-anchor-permalink" href="#Integrators" title="Permalink"></a></h1><p>When writing algorithms for nonlinear dynamics in code, it is almost always more convenient to work with integrators. DynamicalSystems.jl provides several different integrators of dynamical systems and a unified API to treat all of them. The API is based on the same API that DifferentialEquations.jl uses.</p><h2 id="Available-integrators"><a class="docs-heading-anchor" href="#Available-integrators">Available integrators</a><a id="Available-integrators-1"></a><a class="docs-heading-anchor-permalink" href="#Available-integrators" title="Permalink"></a></h2><ul><li><a href="#DynamicalSystemsBase.integrator"><code>integrator</code></a></li><li><a href="#DynamicalSystemsBase.parallel_integrator"><code>parallel_integrator</code></a></li><li><a href="#DynamicalSystemsBase.tangent_integrator"><code>tangent_integrator</code></a></li><li><a href="#DynamicalSystemsBase.projected_integrator"><code>projected_integrator</code></a></li><li><a href="#DynamicalSystemsBase.stroboscopicmap"><code>stroboscopicmap</code></a></li><li><a href="#ChaosTools.poincaremap"><code>poincaremap</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="DynamicalSystemsBase.integrator" href="#DynamicalSystemsBase.integrator"><code>DynamicalSystemsBase.integrator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">integrator(ds::DynamicalSystem [, u0]; diffeq) -&gt; integ</code></pre><p>Return an integrator object that can be used to evolve a system interactively using <code>step!(integ [, Δt])</code>. Optionally specify an initial state <code>u0</code>.</p><p>The state of this integrator is a vector.</p><ul><li><code>diffeq</code> is a <code>NamedTuple</code> (or <code>Dict</code>) of keyword arguments propagated into <code>init</code> of DifferentialEquations.jl. See <a href="../general/#DynamicalSystemsBase.trajectory"><code>trajectory</code></a> for examples. Only valid for continuous systems.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicalSystemsBase.parallel_integrator" href="#DynamicalSystemsBase.parallel_integrator"><code>DynamicalSystemsBase.parallel_integrator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">parallel_integrator(ds::DynamicalSystem, states; kwargs...)</code></pre><p>Return an integrator object that can be used to evolve many <code>states</code> of a system in parallel at the <em>exact same times</em>, using <code>step!(integ [, Δt])</code>.</p><p><code>states</code> are expected as vectors of vectors.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>diffeq</code> is a <code>NamedTuple</code> (or <code>Dict</code>) of keyword arguments propagated into <code>init</code> of DifferentialEquations.jl. See <a href="../general/#DynamicalSystemsBase.trajectory"><code>trajectory</code></a> for examples. Only valid for continuous systems.</li></ul><p>It is <em>heavily</em> advised to use the functions <a href="#DynamicalSystemsBase.get_state"><code>get_state</code></a> and <a href="ds/@ref"><code>set_state!</code></a> to manipulate the integrator. Provide <code>i</code> as a second argument to change the <code>i</code>-th state.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicalSystemsBase.tangent_integrator" href="#DynamicalSystemsBase.tangent_integrator"><code>DynamicalSystemsBase.tangent_integrator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">tangent_integrator(ds::DynamicalSystem, Q0 | k::Int; kwargs...)</code></pre><p>Return an integrator object that evolves in parallel both the system as well as deviation vectors living on the tangent space, also called linearized space.</p><p><code>Q0</code> is a <em>matrix</em> whose columns are initial values for deviation vectors. If instead of a matrix <code>Q0</code> an integer <code>k</code> is given, then <code>k</code> random orthonormal vectors are choosen as initial conditions.</p><p>It is <em>heavily</em> advised to use the functions <a href="#DynamicalSystemsBase.get_state"><code>get_state</code></a>, <a href="#DynamicalSystemsBase.get_deviations"><code>get_deviations</code></a>, <a href="ds/@ref"><code>set_state!</code></a>, <a href="#DynamicalSystemsBase.set_deviations!"><code>set_deviations!</code></a> to manipulate the integrator.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>u0</code> : Optional different initial state.</li><li><code>diffeq</code> is a <code>NamedTuple</code> (or <code>Dict</code>) of keyword arguments propagated into <code>init</code> of DifferentialEquations.jl. See <a href="../general/#DynamicalSystemsBase.trajectory"><code>trajectory</code></a> for examples. Only valid for continuous systems.</li></ul><p><strong>Description</strong></p><p>If <span>$J$</span> is the jacobian of the system then the <em>tangent dynamics</em> are the equations that evolve in parallel the system as well as a deviation vector (or matrix) <span>$w$</span>:</p><p class="math-container">\[\begin{aligned}
\dot{u} &amp;= f(u, p, t) \\
\dot{w} &amp;= J(u, p, t) \times w
\end{aligned}\]</p><p>with <span>$f$</span> being the equations of motion and <span>$u$</span> the system state. Similar equations hold for the discrete case.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicalSystemsBase.projected_integrator" href="#DynamicalSystemsBase.projected_integrator"><code>DynamicalSystemsBase.projected_integrator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">projected_integrator(ds::DynamicalSystem, projection, complete_state; kwargs...) → integ</code></pre><p>Return an integrator that produces iterations of the dynamical system <code>ds</code> on a projected state space. See <a href="#Integrator-API">Integrator API</a> for handling integrators.</p><p>The <code>projection</code> defines the projected space. If <code>projection isa AbstractVector{Int}</code>, then the projected space is simply the variable indices that <code>projection</code> contains. Otherwise, <code>projection</code> can be an arbitrary function that given the state of the original system, returns the state in the projected space. In this case the projected space can be equal, or even higher-dimensional than the original.</p><p><code>complete_state</code> produces the state for the original system from the projected state. <code>complete_state</code> can always be a function that given the projected state returns the full state. However, if <code>projection isa AbstractVector{Int}</code>, then <code>complete_state</code> can also be a vector that contains the values of the <em>remaining</em> variables of the system, i.e., those <em>not</em> contained in the projected space. Obviously in this case the projected space needs to be lower-dimensional than the original.</p><p>Notice that <code>projected_integrator</code> does not require an invertible projection, <code>complete_state</code> is only used during <a href="#SciMLBase.reinit!-Tuple{DynamicalSystem}"><code>reinit!</code></a>. Of course the internal integrator operates in the full state space, where the dynamic rule has been defined. The projection always happens as a last step, e.g., during <a href="#DynamicalSystemsBase.get_state"><code>get_state</code></a>.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>u0</code>: initial state</li><li><code>diffeq</code> is a <code>NamedTuple</code> (or <code>Dict</code>) of keyword arguments propagated into <code>init</code> of DifferentialEquations.jl.</li></ul><p><strong>Examples</strong></p><p>Case 1: project 5-dimensional system to its last two dimensions.</p><pre><code class="language-julia hljs">ds = Systems.lorenz96(5)
projection = [4, 5]
complete_state = [0.0, 0.0, 0.0] # completed state just in the plane of last two dimensions
pinteg = projected_integrator(ds, projection, complete_state)
reinit!(pinteg, [0.2, 0.4])
step!(pinteg)
get_state(pinteg)</code></pre><p>Case 2: custom projection to general functions of state. <code>julia ds = Systems.lorenz96(5) projection(u) = [sum(u), sqrt(u[1]^2 + u[2]^2)] complete_state(y) = repeat(y[1]/5, 5) pinteg = # same as in above example...</code>`</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicalSystemsBase.stroboscopicmap" href="#DynamicalSystemsBase.stroboscopicmap"><code>DynamicalSystemsBase.stroboscopicmap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">stroboscopicmap(ds::ContinuousDynamicalSystem, T; kwargs...)  → smap</code></pre><p>Return a map (integrator) that produces iterations over a period <code>T</code> of the <code>ds</code>, known as a stroboscopic map. See <a href="#Integrator-API">Integrator API</a> for handling integrators.</p><p>See also <a href="ds/@ref"><code>poincaremap</code></a>.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>u0</code>: initial state</li><li><code>diffeq</code> is a <code>NamedTuple</code> (or <code>Dict</code>) of keyword arguments propagated into <code>init</code> of DifferentialEquations.jl.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">f = 0.27; ω = 0.1
ds = Systems.duffing(zeros(2); ω, f, d = 0.15, β = -1)
smap = stroboscopicmap(ds, 2π/ω; diffeq = (;reltol = 1e-8))
reinit!(smap, [1.0, 1.0])
u = step!(smap)
u = step!(smap, 4) # step 4 iterations forward</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ChaosTools.poincaremap" href="#ChaosTools.poincaremap"><code>ChaosTools.poincaremap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">poincaremap(ds::ContinuousDynamicalSystem, plane, Tmax=1e3; kwargs...) → pmap</code></pre><p>Return a map (integrator) that produces iterations over the Poincaré map of <code>ds</code>. This map is defined as the sequence of points on the Poincaré surface of section. See <a href="../../chaos/orbitdiagram/#ChaosTools.poincaresos"><code>poincaresos</code></a> for details on <code>plane</code> and all other <code>kwargs</code>. Keyword <code>idxs</code> does not apply to <code>poincaremap</code>, as it doesn&#39;t save any states.</p><p>Notice that while in theory the Poincaré map has one less dimension than <code>ds</code>, in code the map operates on the full <code>D</code>-dimensional state of <code>ds</code> because that is the only way to accommodate planes with generic orientation.</p><p>The output <code>pmap</code> follows the <a href="#Integrator-API">Integrator API</a>, i.e., <code>step!</code> and <code>reinit!</code>. <code>current_time(pmap)</code> returns the time of the last crossing. For the special case of <code>plane</code> being a <code>Tuple{Int, &lt;:Real}</code>, a special <code>reinit!</code> method is allowed with input state with length <code>D-1</code> instead of <code>D</code>, i.e., a reduced state already on the hyperplane that is then converted into the <code>D</code> dimensional state.</p><p><strong>Notice</strong>: The argument <code>Tmax</code> exists so that the integrator can terminate instead of being evolved for infinite time, to avoid cases where iteration would continue forever for ill-defined hyperplanes or for convergence to fixed points. If during one <code>step!</code> the system has been evolved for more than <code>Tmax</code>, then <code>step!(pmap)</code> will terminate and return <code>nothing</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">ds = Systems.rikitake([0.,0.,0.], μ = 0.47, α = 1.0)
pmap = poincaremap(ds, (3, 0.0))
next_state_on_psos = step!(pmap)
# Change initial condition
reinit!(pmap, [1.0, 0]) # 3rd variable gets value 0 from the plane
next_state_on_psos = step!(pmap)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicalSystemsBase.GeneralizedDynamicalSystem" href="#DynamicalSystemsBase.GeneralizedDynamicalSystem"><code>DynamicalSystemsBase.GeneralizedDynamicalSystem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GeneralizedDynamicalSystem</code></pre><p>An umbrella term that includes any instance of <a href="../general/#DynamicalSystemsBase.DynamicalSystem"><code>DynamicalSystem</code></a> but also <a href="#DynamicalSystemsBase.stroboscopicmap"><code>stroboscopicmap</code></a>, <a href="ds/@ref"><code>poincaremap</code></a> and <a href="ds/@ref"><code>projeted_integrator</code></a>.</p><p>It is used as type declaration in functions that work for any conceivable system type, such as <a href="../general/#DynamicalSystemsBase.trajectory"><code>trajectory</code></a> or <a href="ds/@ref"><code>AttractorMapper</code></a>.</p></div></section></article><h2 id="Integrator-API"><a class="docs-heading-anchor" href="#Integrator-API">Integrator API</a><a id="Integrator-API-1"></a><a class="docs-heading-anchor-permalink" href="#Integrator-API" title="Permalink"></a></h2><p>After you have initialized any integrator, you can use the same functions to handle them. The most important function is <a href="#SciMLBase.step!-Tuple{DynamicalSystem}"><code>step!</code></a>, that will simply progress the integrator. <a href="#DynamicalSystemsBase.get_state"><code>get_state</code></a> will return its current state. <a href="#SciMLBase.reinit!-Tuple{DynamicalSystem}"><code>reinit!</code></a> can be used to re-start the integrator at a possibly different new state. <a href="#DynamicalSystemsBase.current_time"><code>current_time</code></a> returns the time the integrator is currently at.</p><p>Especially for the <a href="#DynamicalSystemsBase.tangent_integrator"><code>tangent_integrator</code></a>, there are also two more functions: <a href="#DynamicalSystemsBase.get_deviations"><code>get_deviations</code></a>, <a href="ds/@ref"><code>set_deviations</code></a>.</p><article class="docstring"><header><a class="docstring-binding" id="SciMLBase.step!-Tuple{DynamicalSystem}" href="#SciMLBase.step!-Tuple{DynamicalSystem}"><code>SciMLBase.step!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">step!(discrete_integ [, dt::Int])</code></pre><p>Progress the discrete-time integrator for 1 or <code>dt</code> steps.</p><pre><code class="nohighlight hljs">step!(continuous_integ, [, dt [, stop_at_tdt]])</code></pre><p>Progress the continuous-time integrator for one step.</p><p>Alternative, if a <code>dt</code> is given, then <code>step!</code> the integrator until there is a temporal difference <code>≥ dt</code> (so, step <em>at least</em> for <code>dt</code> time).</p><p>When <code>true</code> is passed to the optional third argument, the integrator advances for exactly <code>dt</code> time.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicalSystemsBase.get_state" href="#DynamicalSystemsBase.get_state"><code>DynamicalSystemsBase.get_state</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_state(ds::DynamicalSystem)</code></pre><p>Return the state of <code>ds</code>.</p><pre><code class="nohighlight hljs">get_state(integ [, i::Int = 1])</code></pre><p>Return the state of the integrator, in the sense of the state of the dynamical system. This function works for any integrator of the library.</p><p>If the integrator is a <a href="#DynamicalSystemsBase.parallel_integrator"><code>parallel_integrator</code></a>, passing <code>i</code> will return the <code>i</code>-th state. The function also correctly returns the true state of the system for tangent integrators.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="SciMLBase.reinit!-Tuple{DynamicalSystem}" href="#SciMLBase.reinit!-Tuple{DynamicalSystem}"><code>SciMLBase.reinit!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reinit!(integ [, state])</code></pre><p>Re-initialize the integrator to the new given <code>state</code>. The <code>state</code> type should match the integrator type. Specifically:</p><ul><li><code>integrator, stroboscopicmap, poincaremap</code>: it needs to be a vector of size the same as the dimension of the dynamical system that produced the integrator.</li><li><code>projected_integrator</code>: it needs to be a vector of same size as the projected space.</li><li><code>parallel_integrator</code>: it needs to be a vector of vectors of size the same as the dimension of the dynamical system that produced the integrator.</li><li><code>tangent_integrator</code>: there the special signature <code>reinit!(integ, state, Q0::AbstractMatrix)</code> should be used, with <code>Q0</code> containing the deviation vectors. Alternatively, use <a href="#DynamicalSystemsBase.set_deviations!"><code>set_deviations!</code></a> if you only want to change the deviation vectors.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicalSystemsBase.current_time" href="#DynamicalSystemsBase.current_time"><code>DynamicalSystemsBase.current_time</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">current_time(integ) → t</code></pre><p>Return the current time of the integrator.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicalSystemsBase.get_deviations" href="#DynamicalSystemsBase.get_deviations"><code>DynamicalSystemsBase.get_deviations</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_deviations(tang_integ)</code></pre><p>Return the deviation vectors of the <a href="#DynamicalSystemsBase.tangent_integrator"><code>tangent_integrator</code></a> in a form of a matrix with columns the vectors.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicalSystemsBase.set_deviations!" href="#DynamicalSystemsBase.set_deviations!"><code>DynamicalSystemsBase.set_deviations!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_deviations!(tang_integ, Q)</code></pre><p>Set the deviation vectors of the <a href="#DynamicalSystemsBase.tangent_integrator"><code>tangent_integrator</code></a> to <code>Q</code>, which must be a matrix with each column being a deviation vector.</p><p>Automatically does <code>u_modified!(tang_integ, true)</code>.</p></div></section></article><h3 id="Re-initializing-an-integrator"><a class="docs-heading-anchor" href="#Re-initializing-an-integrator">Re-initializing an integrator</a><a id="Re-initializing-an-integrator-1"></a><a class="docs-heading-anchor-permalink" href="#Re-initializing-an-integrator" title="Permalink"></a></h3><p>It is more efficient to re-initialize an integrator using <code>reinit!</code> than to create a new one. This can be very helpful when looping over initial conditions and/or parameter values.</p><p>All high-level functions from <code>ChaosTools</code> have a set-up part that creates an integrator, and a low-level part that does the computation. The low level part is your friend! Use it! See the <a href="../../chaos/chaos_detection/#Using-GALI">Using GALI</a> page for an example as well as the section below.</p><h4 id="Example:-Re-init-of-continuous-tangent-integrator"><a class="docs-heading-anchor" href="#Example:-Re-init-of-continuous-tangent-integrator">Example: Re-init of continuous tangent integrator</a><a id="Example:-Re-init-of-continuous-tangent-integrator-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-Re-init-of-continuous-tangent-integrator" title="Permalink"></a></h4><p>Here we compute the <a href="../../chaos/lyapunovs/#ChaosTools.lyapunovspectrum"><code>lyapunovspectrum</code></a> for many different initial conditions.</p><pre><code class="language-julia hljs">ds = Systems.lorenz()
tinteg = tangent_integrator(ds, 2)
ics = [rand(3) for i in 1:100]
for ic in ics
  reinit!(tinteg, ic, orthonormal(3, 2))
  λ = lyapunovspectrum(tinteg, 1000, 0.1, 10.0)
  # reminder: lyapunovspectrum(tinteg, N, Δt::Real, Ttr::Real = 0.0)
end</code></pre><h2 id="Using-callbacks-with-integrators"><a class="docs-heading-anchor" href="#Using-callbacks-with-integrators">Using callbacks with integrators</a><a id="Using-callbacks-with-integrators-1"></a><a class="docs-heading-anchor-permalink" href="#Using-callbacks-with-integrators" title="Permalink"></a></h2><p>For the case of continuous systems you can add callbacks from the event handling of <strong>DifferentialEquations.jl</strong>. This is done simply as a keyword argument to the initializers.</p><p>In this example we use a simple <code>SavingCallback</code> to save the distance between the two states of a <a href="#DynamicalSystemsBase.parallel_integrator"><code>parallel_integrator</code></a>.</p><pre><code class="language-julia hljs">using DynamicalSystems, DiffEqCallbacks
using LinearAlgebra: norm

ds = Systems.lorenz()
d0 = 1e-9
T = 100.0

save_func(u, t, integrator) = norm(u[1] - u[2])
saved_values = SavedValues(eltype(ds.t0), eltype(get_state(ds)))
cb = SavingCallback(save_func, saved_values)

diffeq = (abstol=1e-14, reltol=1e-14, maxiters=1e9, callback = cb)

u0 = get_state(ds)
pinteg = parallel_integrator(ds, [u0, u0 + rand(SVector{3})*d0*√3]; diffeq)
step!(pinteg, T)
t = saved_values.t
n = saved_values.saveval</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Float64[]</code></pre><p>As expected you can see that the recorded distance between two states is increasing.</p><h2 id="Choosing-a-solver"><a class="docs-heading-anchor" href="#Choosing-a-solver">Choosing a solver</a><a id="Choosing-a-solver-1"></a><a class="docs-heading-anchor-permalink" href="#Choosing-a-solver" title="Permalink"></a></h2><p><code>ContinuousDynamicalSystem</code>s are evolved using solvers from <a href="http://docs.juliadiffeq.org/latest/">DifferentialEquations.jl</a>. In this page we discuss the importance of which solver to choose.</p><h3 id="Default-Solver"><a class="docs-heading-anchor" href="#Default-Solver">Default Solver</a><a id="Default-Solver-1"></a><a class="docs-heading-anchor-permalink" href="#Default-Solver" title="Permalink"></a></h3><p>The default solver is:</p><pre><code class="language-julia hljs">using DynamicalSystems
DynamicalSystemsBase.DEFAULT_SOLVER</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">SimpleATsit5()</code></pre><p>which is a Runge-Kutta-like solver. The number in the solver&#39;s name is the &quot;order&quot; of the solver.</p><h3 id="Speed-of-a-solver"><a class="docs-heading-anchor" href="#Speed-of-a-solver">Speed of a solver</a><a id="Speed-of-a-solver-1"></a><a class="docs-heading-anchor-permalink" href="#Speed-of-a-solver" title="Permalink"></a></h3><p>Estimating a given solver&#39;s performance for a particular problem is not trivial. The following are general rules of thumb:</p><ol><li>Higher order solvers call the equations of motion function more times per step.</li><li>Higher order solvers can cover larger timespans per step.</li><li>Higher order solvers do better at small tolerances.</li></ol><p>This means that there is a delicate balance between how expensive is your function and how large of a step a solver can take while it is still efficient. In general you want to strike a point of taking large steps but also not calling the function exceedingly often.</p><h3 id="How-do-I-pick?"><a class="docs-heading-anchor" href="#How-do-I-pick?">How do I pick?</a><a id="How-do-I-pick?-1"></a><a class="docs-heading-anchor-permalink" href="#How-do-I-pick?" title="Permalink"></a></h3><p>The answer to this question is easy: <strong>benchmarks!</strong></p><p>Here is a simple case: let&#39;s compute the Lyapunov spectrum of the Lorenz system using <a href="../../chaos/lyapunovs/#ChaosTools.lyapunovspectrum"><code>lyapunovspectrum</code></a>:</p><pre><code class="language-julia hljs">ds = Systems.lorenz()
tols = (abstol = 1e-6, reltol = 1e-6)
lyapunovspectrum(ds, 2000; Ttr = 100.0, diffeq = tols)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Float64}:
   0.9138290308099412
   0.00020584718966332785
 -14.580623290765311</code></pre><p>The above uses the default solver. Let&#39;s now benchmark using two different solvers, <code>SimpleATsit5</code> and <code>Vern9</code>. Since the <code>SimpleATsit5</code> case is of lower order, naively one might think it is faster because it makes less function calls. This argument is not necessarily true though.</p><p>It is important to understand that when calling <code>lyapunovspectrum(ds, 2000)</code> you want the system (and the tangent space) to be evolved so that it reaches a total time of <code>2000*Δt</code>, which by default is <code>2000.0</code> units of time. Even though <code>SimpleATsit5</code> requires less function calls per step, <code>Vern9</code> can cover larger timespans per step.</p><p>Here are the numbers:</p><pre><code class="language-julia hljs">using BenchmarkTools, OrdinaryDiffEq, SimpleDiffEq, Statistics
b1 = @benchmark lyapunovspectrum(ds, 2000; diffeq = (alg = SimpleATsit5(), tols...), Ttr = 100.0);
b2 = @benchmark lyapunovspectrum(ds, 2000; diffeq = (alg = Vern9(), tols...), Ttr = 100.0);
println(&quot;Timing for SimpleATsit5:&quot;)
println(mean(b1))
println(&quot;Timing for Vern9:&quot;)
println(mean(b2))</code></pre><pre><code class="nohighlight hljs">Timing for SimpleATsit5:
TrialEstimate(53.517 ms)
Timing for Vern9:
TrialEstimate(27.511 ms)</code></pre><p>As you can see <code>Vern9</code> is faster in doing the <em>entire</em> computation! Of course this does not have to be universally true. It is true for the Lorenz system, but for your specific system you should do dedicated benchmarks!</p><h3 id="DifferentialEquations.jl"><a class="docs-heading-anchor" href="#DifferentialEquations.jl">DifferentialEquations.jl</a><a id="DifferentialEquations.jl-1"></a><a class="docs-heading-anchor-permalink" href="#DifferentialEquations.jl" title="Permalink"></a></h3><p>For more info about the possible solvers be sure to head over to the documentation of <a href="https://diffeq.sciml.ai/latest/">DifferentialEquations.jl</a>!</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../embedding/dataset/">« Numerical Data</a><a class="docs-footer-nextpage" href="../../embedding/reconstruction/">Delay Coordinates Embedding »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Thursday 10 November 2022 20:40">Thursday 10 November 2022</span>. Using Julia version 1.8.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
