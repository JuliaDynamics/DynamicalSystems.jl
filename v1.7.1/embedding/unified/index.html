<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Unified Optimal Embedding · DynamicalSystems.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/logo.ico" rel="icon" type="image/x-icon"/><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="DynamicalSystems.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">DynamicalSystems.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../../contents/">Contents</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Dynamical systems</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../ds/general/">Dynamical System Definition</a></li><li><a class="tocitem" href="../../ds/predefined/">Predefined Dynamical Systems</a></li><li><a class="tocitem" href="../dataset/">Numerical Data</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Entropies</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../entropies/api/">Entropies &amp; Probabilities</a></li><li><a class="tocitem" href="../../entropies/estimators/">Probabilities Estimators</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox" checked/><label class="tocitem" for="menuitem-5"><span class="docs-label">DelayEmbeddings</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../reconstruction/">Delay Coordinates Embedding</a></li><li><a class="tocitem" href="../traditional/">Traditional Optimal Embedding</a></li><li class="is-active"><a class="tocitem" href>Unified Optimal Embedding</a><ul class="internal"><li><a class="tocitem" href="#An-example"><span>An example</span></a></li><li><a class="tocitem" href="#All-unified-algorithms"><span>All unified algorithms</span></a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">ChaosTools</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../chaos/orbitdiagram/">Orbit Diagrams &amp; PSOS</a></li><li><a class="tocitem" href="../../chaos/lyapunovs/">Lyapunov Exponents</a></li><li><a class="tocitem" href="../../chaos/chaos_detection/">Detecting &amp; Categorizing Chaos</a></li><li><a class="tocitem" href="../../chaos/fractaldim/">Fractal Dimension</a></li><li><a class="tocitem" href="../../chaos/nlts/">Nonlinear Timeseries Analysis</a></li><li><a class="tocitem" href="../../chaos/periodicity/">Periodicity &amp; Ergodicity</a></li><li><a class="tocitem" href="../../chaos/choosing/">Choosing a solver</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">RecurrenceAnalysis</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../rqa/rplots/">Recurrence Plots</a></li><li><a class="tocitem" href="../../rqa/quantification/">Recurrence Quantification Analysis</a></li><li><a class="tocitem" href="../../rqa/windowed/">Windowed RQA</a></li></ul></li><li><a class="tocitem" href="../../advanced/">Advanced Documentation</a></li><li><a class="tocitem" href="../../contributors_guide/">Contributor Guide</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">DelayEmbeddings</a></li><li class="is-active"><a href>Unified Optimal Embedding</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Unified Optimal Embedding</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDynamics/DynamicalSystems.jl/blob/master/docs/src/embedding/unified.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Unified-Optimal-Embedding"><a class="docs-heading-anchor" href="#Unified-Optimal-Embedding">Unified Optimal Embedding</a><a id="Unified-Optimal-Embedding-1"></a><a class="docs-heading-anchor-permalink" href="#Unified-Optimal-Embedding" title="Permalink"></a></h1><p>Unified approaches try to create an optimal embedding by in parallel optimizing what combination of delay times and embedding dimensions suits best.</p><p>In addition, the unified approaches are the only ones that can accommodate multi-variate inputs. This means that if you have multiple measured input timeseries, you should be able to take advantage of all of them for the best possible embedding of the dynamical system&#39;s set.</p><h2 id="An-example"><a class="docs-heading-anchor" href="#An-example">An example</a><a id="An-example-1"></a><a class="docs-heading-anchor-permalink" href="#An-example" title="Permalink"></a></h2><p>In following we illustrate the the most recent unified optimal embedding method, called PECUZAL, on three examples. We start with a univariate case, i.e. we only feed in one time series, here the <em>x</em>-component of the Lorenz system.  </p><pre><code class="language-julia">using DynamicalSystems

lo = Systems.lorenz([1.0, 1.0, 50.0])
tr = trajectory(lo, 100; dt = 0.01, Ttr = 10)

s = vec(tr[:, 1]) # input timeseries = x component of lorenz
theiler = estimate_delay(s, &quot;mi_min&quot;) # estimate a Theiler window
Tmax = 100 # maximum possible delay

Y, τ_vals, ts_vals, Ls , εs = pecuzal_embedding(s; τs = 0:Tmax , w = theiler)

println(τ_vals)
println(ts_vals)
println(Ls)</code></pre><pre class="documenter-example-output">Algorithm stopped due to minimum L-value reached. VALID embedding achieved ✓.
[0, 18, 9]
[1, 1, 1]
[-2.8725894723648135, -2.9978353120801096, -2.9458665448810084]</pre><p>The output reveals that PECUZAL suggests a 3-dimensional embedding out of the un-lagged time series as the 1st component of the reconstruction, the time series lagged by 18 samples as the 2nd component and the time series lagged by 9 samples as the 3rd component. The minimum obtained <em>L</em>-value in the 3rd embedding cycle has been ~-2.63, after which the algorithm breaks.</p><pre><code class="language-julia">using PyPlot

figure(figsize=(14., 8.))
subplot(1,2,1, projection=&quot;3d&quot;)
plot3D(Y[:,1], Y[:,2], Y[:,3],&quot;gray&quot;)
title(&quot;PECUZAL reconstructed x-component of Lorenz System&quot;)
xlabel(&quot;x(t+$(τ_vals[1]))&quot;)
ylabel(&quot;x(t+$(τ_vals[2]))&quot;)
zlabel(&quot;x(t+$(τ_vals[3]))&quot;)
grid()

subplot(1,2,2, projection=&quot;3d&quot;)
plot3D(tr[:,1], tr[:,2], tr[:,3],&quot;gray&quot;)
title(&quot;Original Lorenz System&quot;)
xlabel(&quot;x(t)&quot;)
ylabel(&quot;y(t)&quot;)
zlabel(&quot;z(t)&quot;)
grid()

tight_layout()</code></pre><p><img src="../pecuzal_uni.png" alt/></p><p>We can also look at the output of the low-level function leading to the results, here the <em>continuity statistic</em>.</p><pre><code class="language-julia">using PyPlot

figure(figsize=(8., 5.))
plot(εs[:,1], label=&quot;1st embedding cycle&quot;)
scatter([τ_vals[2]], [εs[τ_vals[2],1]])
plot(εs[:,2], label=&quot;2nd embedding cycle&quot;)
scatter([τ_vals[3]], [εs[τ_vals[3],2]])
plot(εs[:,3], label=&quot;3rd embedding cycle&quot;)
title(&quot;Continuity statistics for PECUZAL embedding of Lorenz x-component&quot;)
xlabel(&quot;delay τ&quot;)
ylabel(&quot;⟨ε⋆⟩&quot;)
legend(loc=&quot;upper left&quot;)
grid()</code></pre><p><img src="../continuity_uni.png" alt/></p><p>Similar to the approach in the preceding example, we now highlight the capability of the PECUZAL embedding method for a multivariate input. The idea is now to feed in all three time series to the algorithm, even though this is a very far-from-reality example. We already have an adequate representation of the system we want to reconstruct, namely the three time series from the numerical integration. But let us see what PECUZAL suggests for a reconstruction.</p><pre><code class="language-julia"># compute Theiler window
w1 = estimate_delay(tr[:,1], &quot;mi_min&quot;)
w2 = estimate_delay(tr[:,2], &quot;mi_min&quot;)
w3 = estimate_delay(tr[:,3], &quot;mi_min&quot;)
w = maximum(hcat(w1,w2,w3))
Y_m, τ_vals_m, ts_vals_m, Ls_m , εs_m = pecuzal_embedding(tr; τs = 0:Tmax , w = theiler)

println(τ_vals_m)
println(ts_vals_m)
println(Ls_m)</code></pre><pre class="documenter-example-output">Algorithm stopped due to minimum L-value reached. VALID embedding achieved ✓.
[0, 12, 0]
[3, 1, 1]
[-2.5231456900201734, -2.8548327001280525, -2.813549538642902]</pre><p>PECUZAL offers a 3-dimensional embedding using the un-lagged <em>z</em>- and <em>x</em>-component as 1st and 3rd component of the reconstruction vectors, as well as the <em>x</em>-component lagged by 12 samples.</p><pre><code class="language-julia">ts_str = [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]

figure(figsize=(14., 8.))
subplot(1,2,1, projection=&quot;3d&quot;)
plot3D(Y_m[:,1], Y_m[:,2], Y_m[:,3],&quot;gray&quot;)
title(&quot;PECUZAL reconstructed Lorenz System&quot;)
xlabel(&quot;$(ts_str[ts_vals_m[1]])(t+$(τ_vals_m[1]))&quot;)
ylabel(&quot;$(ts_str[ts_vals_m[2]])(t+$(τ_vals_m[2]))&quot;)
zlabel(&quot;$(ts_str[ts_vals_m[3]])(t+$(τ_vals_m[3]))&quot;)
grid()

subplot(1,2,2, projection=&quot;3d&quot;)
plot3D(tr[:,1], tr[:,2], tr[:,3],&quot;gray&quot;)
title(&quot;Original Lorenz System&quot;)
xlabel(&quot;x(t)&quot;)
ylabel(&quot;y(t)&quot;)
zlabel(&quot;z(t)&quot;)
grid()

tight_layout()</code></pre><p><img src="../pecuzal_multi.png" alt/></p><p>Finally we show what PECUZAL does with a non-deterministic source:</p><pre><code class="language-julia">using Random

# Dummy input
d1 = randn(1000)
d2 = rand(1000)
Tmax = 100
dummy_set = Dataset(hcat(d1,d2))

w1 = estimate_delay(d1, &quot;mi_min&quot;)
w2 = estimate_delay(d2, &quot;mi_min&quot;)
theiler = minimum(hcat(w1,w2))

Y_d, τ_vals_d, ts_vals_d, Ls_d , ε★_d = pecuzal_embedding(dummy_set; τs = 0:Tmax , w = theiler)

size(Y_d)</code></pre><pre class="documenter-example-output">(1000,)</pre><p>So, no (proper) embedding is done.</p><h2 id="All-unified-algorithms"><a class="docs-heading-anchor" href="#All-unified-algorithms">All unified algorithms</a><a id="All-unified-algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#All-unified-algorithms" title="Permalink"></a></h2><p>Several algorithms have been created to implement a unified approach to delay coordinates embedding. You can find some implementations below:</p><article class="docstring"><header><a class="docstring-binding" id="DelayEmbeddings.pecora" href="#DelayEmbeddings.pecora"><code>DelayEmbeddings.pecora</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">pecora(s, τs, js; kwargs...) → ⟨ε★⟩, ⟨Γ⟩</code></pre><p>Compute the (average) continuity statistic <code>⟨ε★⟩</code> and undersampling statistic <code>⟨Γ⟩</code> according to Pecora et al.<sup class="footnote-reference"><a id="citeref-Pecoral2007" href="#footnote-Pecoral2007">[Pecoral2007]</a></sup> (A unified approach to attractor reconstruction), for a given input <code>s</code> (timeseries or <code>Dataset</code>) and input generalized embedding defined by <code>(τs, js)</code>, according to <a href="../reconstruction/#DelayEmbeddings.genembed"><code>genembed</code></a>. The continuity statistic represents functional independence between the components of the existing embedding and one additional timeseries. The returned results are <em>matrices</em> with size <code>T</code>x<code>J</code>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>delays = 0:50</code>: Possible time delay values <code>delays</code> (in sampling time units). For each of the <code>τ</code>&#39;s in <code>delays</code> the continuity-statistic <code>⟨ε★⟩</code> gets computed. If <code>undersampling = true</code> (see further down), also the undersampling statistic <code>⟨Γ⟩</code> gets returned for all considered delay values.</li><li><code>J = 1:dimension(s)</code>: calculate for all timeseries indices in <code>J</code>. If input <code>s</code> is a timeseries, this is always just 1.</li><li><code>samplesize::Real = 0.1</code>: determine the fraction of all phase space points (=<code>length(s)</code>) to be considered (fiducial points v) to average ε★ to produce <code>⟨ε★⟩, ⟨Γ⟩</code></li><li><code>K::Int = 13</code>: the amount of nearest neighbors in the δ-ball (read algorithm description). Must be at least 8 (in order to gurantee a valid statistic). <code>⟨ε★⟩</code> is computed taking the minimum result over all <code>k ∈ K</code>.</li><li><code>metric = Chebyshev()</code>: metrix with which to find nearest neigbhors in the input embedding (ℝᵈ space, <code>d = length(τs)</code>).</li><li><code>w = 1</code>: Theiler window (neighbors in time with index <code>w</code> close to the point, that are excluded from being true neighbors). <code>w=0</code> means to exclude only the point itself, and no temporal neighbors.</li><li><code>undersampling = false</code> : whether to calculate the undersampling statistic or not (if not, zeros are returned for <code>⟨Γ⟩</code>). Calculating <code>⟨Γ⟩</code> is thousands of times slower than <code>⟨ε★⟩</code>.</li><li><code>db::Int = 100</code>: Amount of bins used into calculating the histograms of each timeseries (for the undersampling statistic).</li><li><code>α::Real = 0.05</code>: The significance level for obtaining the continuity statistic</li><li><code>p::Real = 0.5</code>: The p-parameter for the binomial distribution used for the computation of the continuity statistic.</li></ul><p><strong>Description</strong></p><p>Notice that the full algorithm is too large to discuss here, and is written in detail (several pages!) in the source code of <code>pecora</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="DelayEmbeddings.uzal_cost" href="#DelayEmbeddings.uzal_cost"><code>DelayEmbeddings.uzal_cost</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">uzal_cost(Y::Dataset; kwargs...) → L</code></pre><p>Compute the L-statistic <code>L</code> for input dataset <code>Y</code> according to Uzal et al.<sup class="footnote-reference"><a id="citeref-Uzal2011" href="#footnote-Uzal2011">[Uzal2011]</a></sup>, based on theoretical arguments on noise amplification, the complexity of the reconstructed attractor and a direct measure of local stretch which constitutes an irrelevance measure. It serves as a cost function of a state space trajectory/embedding and therefore allows to estimate a &quot;goodness of a embedding&quot; and also to choose proper embedding parameters, while minimizing <code>L</code> over the parameter space. For receiving the local cost function <code>L_local</code> (for each point in state space - not averaged), use <code>uzal_cost_local(...)</code>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>samplesize = 0.5</code>: Number of considered fiducial points v as a fraction of input state space trajectory <code>Y</code>&#39;s length, in order to average the conditional variances and neighborhood sizes (read algorithm description) to produce <code>L</code>.</li><li><code>K = 3</code>: the amount of nearest neighbors considered, in order to compute σ_k^2 (read algorithm description). If given a vector, minimum result over all <code>k ∈ K</code> is returned.</li><li><code>metric = Euclidean()</code>: metric used for finding nearest neigbhors in the input state space trajectory `Y.</li><li><code>w = 1</code>: Theiler window (neighbors in time with index <code>w</code> close to the point, that are excluded from being true neighbors). <code>w=0</code> means to exclude only the point itself, and no temporal neighbors.</li><li><code>Tw = 40</code>: The time horizon (in sampling units) up to which E_k^2 gets computed and averaged over (read algorithm description).</li></ul><p><strong>Description</strong></p><p>The <code>L</code>-statistic is based on theoretical arguments on noise amplification, the complexity of the reconstructed attractor and a direct measure of local stretch which constitutes an irrelevance measure. Technically, it is the logarithm of the product of <code>σ</code>-statistic and a normalization statistic <code>α</code>:</p><p>L = log10(σ*α)</p><p>The <code>σ</code>-statistic is computed as follows. <code>σ = √σ² = √(E²/ϵ²)</code>. <code>E²</code> approximates the conditional variance at each point in state space and for a time horizon <code>T ∈ Tw</code>, using <code>K</code> nearest neighbors. For each reference point of the state space trajectory, the neighborhood consists of the reference point itself and its <code>K+1</code> nearest neighbors. <code>E²</code> measures how strong a neighborhood expands during <code>T</code> time steps. <code>E²</code> is averaged over many time horizons <code>T = 1:Tw</code>. Consequently, <code>ϵ²</code> is the size of the neighborhood at the reference point itself and is defined as the mean pairwise distance of the neighborhood. Finally, <code>σ²</code> gets averaged over a range of reference points on the attractor, which is controlled by <code>samplesize</code>. This is just for performance reasons and the most accurate result will obviously be gained when setting <code>samplesize=1.0</code></p><p>The <code>α</code>-statistic is a normalization factor, such that <code>σ</code>&#39;s from different embeddings can be compared. <code>α²</code> is defined as the inverse of the sum of the inverse of all <code>ϵ²</code>&#39;s for all considered reference points.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="DelayEmbeddings.garcia_almeida_embedding" href="#DelayEmbeddings.garcia_almeida_embedding"><code>DelayEmbeddings.garcia_almeida_embedding</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">garcia_almeida_embedding(s; kwargs...) → Y, τ_vals, ts_vals, FNNs ,NS</code></pre><p>A unified approach to properly embed a time series (<code>Vector</code> type) or a set of time series (<code>Dataset</code> type) based on the papers of Garcia &amp; Almeida <sup class="footnote-reference"><a id="citeref-Garcia2005a" href="#footnote-Garcia2005a">[Garcia2005a]</a></sup>,<sup class="footnote-reference"><a id="citeref-Garcia2005b" href="#footnote-Garcia2005b">[Garcia2005b]</a></sup>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>τs= 0:50</code>: Possible delay values <code>τs</code> (in sampling time units). For each of the <code>τs</code>&#39;s the N-statistic gets computed.</li><li><code>w::Int = 1</code>: Theiler window (neighbors in time with index <code>w</code> close to the point, that are excluded from being true neighbors). <code>w=0</code> means to exclude only the point itself, and no temporal neighbors.</li><li><code>r1 = 10</code>: The threshold, which defines the factor of tolerable stretching for the d_E1-statistic.</li><li><code>r2 = 2</code>: The threshold for the tolerable relative increase of the distance between the nearest neighbors, when increasing the embedding dimension.</li><li><code>fnn_thres= 0.05</code>: A threshold value defining a sufficiently small fraction of false nearest neighbors, in order to the let algorithm terminate and stop the embedding procedure (`0 ≤ fnn_thres &lt; 1).</li><li><code>T::Int = 1</code>: The forward time step (in sampling units) in order to compute the <code>d_E2</code>-statistic (see algorithm description). Note that in the paper this is not a free parameter and always set to <code>T=1</code>.</li><li><code>metric = Euclidean()</code>: metric used for finding nearest neigbhors in the input phase space trajectory <code>Y</code>.</li><li><code>max_num_of_cycles = 50</code>: The algorithm will stop after that many cycles no matter what.</li></ul><p><strong>Description</strong></p><p>The method works iteratively and gradually builds the final embedding vectors <code>Y</code>. Based on the <code>N</code>-statistic the algorithm picks an optimal delay value <code>τ</code> for each embedding cycle as the first local minimum of <code>N</code>. In case of multivariate embedding, i.e. when embedding a set of time series (<code>s::Dataset</code>), the optimal delay value <code>τ</code> is chosen as the first minimum from all minimum&#39;s of all considered <code>N</code>-statistics for each embedding cycle. The range of considered delay values is determined in <code>τs</code> and for the nearest neighbor search we respect the Theiler window <code>w</code>. After each embedding cycle the FNN-statistic <code>FNNs</code> <sup class="footnote-reference"><a id="citeref-Hegger1999" href="#footnote-Hegger1999">[Hegger1999]</a></sup><sup class="footnote-reference"><a id="citeref-Kennel1992" href="#footnote-Kennel1992">[Kennel1992]</a></sup> is being checked and as soon as this statistic drops below the threshold <code>fnn_thres</code>, the algorithm breaks. In order to increase the  practability of the method the algorithm also breaks, when the FNN-statistic <code>FNNs</code> increases . The final embedding vector is stored in <code>Y</code> (<code>Dataset</code>). The chosen delay values for each embedding cycle are stored in the <code>τ_vals</code> and the according time series number chosen for the according delay value in <code>τ_vals</code> is stored in <code>ts_vals</code>. For univariate embedding (<code>s::Vector</code>) <code>ts_vals</code> is a vector of ones of length <code>τ_vals</code>, because there is simply just one time series to choose from. The function also returns the <code>N</code>-statistic <code>NS</code> for each embedding cycle as an <code>Array</code> of <code>Vector</code>s.</p><p>Notice that we were <em>not</em> able to reproduce the figures from the papers with our implementation (which nevertheless we believe is the correct one).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="DelayEmbeddings.mdop_embedding" href="#DelayEmbeddings.mdop_embedding"><code>DelayEmbeddings.mdop_embedding</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">mdop_embedding(s::Vector; kwargs...) → Y, τ_vals, ts_vals, FNNs, βS</code></pre><p>MDOP (for &quot;maximizing derivatives on projection&quot;) is a unified approach to properly embed a timeseries or a set of timeseries (<code>Dataset</code>) based on the paper of Chetan Nichkawde <sup class="footnote-reference"><a id="citeref-Nichkawde2013" href="#footnote-Nichkawde2013">[Nichkawde2013]</a></sup>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>τs= 0:50</code>: Possible delay values <code>τs</code>. For each of the <code>τs</code>&#39;s the β-statistic gets computed.</li><li><code>w::Int = 1</code>: Theiler window (neighbors in time with index <code>w</code> close to the point, that are excluded from being true neighbors). <code>w=0</code> means to exclude only the point itself, and no temporal neighbors.</li><li><code>fnn_thres::Real= 0.05</code>: A threshold value defining a sufficiently small fraction of false nearest neighbors, in order to the let algorithm terminate and stop the embedding procedure (`0 ≤ fnn_thres &lt; 1).</li><li><code>r::Real = 2</code>: The threshold for the tolerable relative increase of the distance between the nearest neighbors, when increasing the embedding dimension.</li><li><code>max_num_of_cycles = 50</code>: The algorithm will stop after that many cycles no matter what.</li></ul><p><strong>Description</strong></p><p>The method works iteratively and gradually builds the final embedding <code>Y</code>. Based on the <a href="#DelayEmbeddings.beta_statistic"><code>beta_statistic</code></a> the algorithm picks an optimal delay value <code>τ</code> for each embedding cycle as the global maximum of <code>β</code>. In case of multivariate embedding, i.e. when embedding a set of time series (<code>s::Dataset</code>), the optimal delay value <code>τ</code> is chosen as the maximum from all maxima&#39;s of all considered <code>β</code>-statistics for each possible timeseries. The range of considered delay values is determined in <code>τs</code> and for the nearest neighbor search we respect the Theiler window <code>w</code>.</p><p>After each embedding cycle the FNN-statistic <code>FNNs</code> <sup class="footnote-reference"><a id="citeref-Hegger1999" href="#footnote-Hegger1999">[Hegger1999]</a></sup><sup class="footnote-reference"><a id="citeref-Kennel1992" href="#footnote-Kennel1992">[Kennel1992]</a></sup> is being checked and as soon as this statistic drops below the threshold <code>fnn_thres</code>, the algorithm terminates. In order to increase the practability of the method the algorithm also terminates when the FNN-statistic <code>FNNs</code> increases.</p><p>The final embedding is returned as <code>Y</code>. The chosen delay values for each embedding cycle are stored in the <code>τ_vals</code> and the according timeseries index chosen for the the respective according delay value in <code>τ_vals</code> is stored in <code>ts_vals</code>. <code>βS, FNNs</code> are returned for clarity and double-checking, since they are computed anyway. In case of multivariate embedding, <code>βS</code> will store all <code>β</code>-statistics for all available time series in each embedding cycle. To double-check the actual used <code>β</code>-statistics in an embedding cycle &#39;k&#39;, simply <code>βS[k][:,ts_vals[k+1]]</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="DelayEmbeddings.pecuzal_embedding" href="#DelayEmbeddings.pecuzal_embedding"><code>DelayEmbeddings.pecuzal_embedding</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">pecuzal_embedding(s; kwargs...) → 𝒟, τ_vals, ts_vals, Ls, ⟨ε★⟩</code></pre><p>A unified approach to properly embed a time series or a set of time series (<code>Dataset</code>) based on the ideas of Pecora et al. <sup class="footnote-reference"><a id="citeref-Pecoral2007" href="#footnote-Pecoral2007">[Pecoral2007]</a></sup> and Uzal et al. <sup class="footnote-reference"><a id="citeref-Uzal2011" href="#footnote-Uzal2011">[Uzal2011]</a></sup>. For a detailled description of the algorithm see Kraemer et al. <sup class="footnote-reference"><a id="citeref-Kraemer2020" href="#footnote-Kraemer2020">[Kraemer2020]</a></sup>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>τs = 0:50</code>: Possible delay values <code>τs</code> (in sampling time units). For each of the <code>τs</code>&#39;s the continuity statistic ⟨ε★⟩ gets computed and further processed in order to find optimal delays <code>τᵢ</code> for each embedding cycle <code>i</code> (read algorithm description).</li><li><code>w::Int = 1</code>: Theiler window (neighbors in time with index <code>w</code> close to the point, that are excluded from being true neighbors). <code>w=0</code> means to exclude only the point itself, and no temporal neighbors.</li><li><code>samplesize::Real = 1</code>: determine the fraction of all phase space points (=<code>length(s)</code>) to be considered (fiducial points v) to average ε★, in order to produce <code>⟨ε★⟩</code>.</li><li><code>K::Int = 13</code>: the amount of nearest neighbors in the δ-ball (read algorithm description). Must be at least 8 (in order to gurantee a valid statistic). <code>⟨ε★⟩</code> is computed taking the minimum result over all <code>k ∈ K</code>.</li><li><code>KNN::Int = 3</code>: the amount of nearest neighbors considered, in order to compute σ². If given a vector, the minimum result over all <code>knn ∈ KNN</code> is returned.</li><li><code>Tw::Int = 4*w</code>: the maximal considered time horizon for obtaining σ² (read  algorithm description.</li><li><code>α::Real = 0.05</code>: The significance level for obtaining the continuity statistic</li><li><code>p::Real = 0.5</code>: The p-parameter for the binomial distribution used for the computation of the continuity statistic ⟨ε★⟩.</li><li><code>max_cycles = 50</code>: The algorithm will stop after that many cycles no matter what.</li></ul><p><strong>Description</strong></p><p>The method works iteratively and gradually builds the final embedding vectors <code>𝒟</code>. Based on the <code>⟨ε★⟩</code>-statistic <a href="#DelayEmbeddings.pecora"><code>pecora</code></a> the algorithm picks an optimal delay value <code>τᵢ</code> for each embedding cycle i. For achieving that, we take the inpute time series <code>s</code> and compute the continuity statistic <code>⟨ε★⟩</code>. 1. Each local maxima in <code>⟨ε★⟩</code> is used for constructing a candidate embedding trajectory <code>𝒟_trial</code> with a delay corresponding to that specific peak in <code>⟨ε★⟩</code>. 2. We then compute the <code>L</code>-statistic <a href="#DelayEmbeddings.uzal_cost"><code>uzal_cost</code></a> for <code>𝒟_trial</code>. 3. We pick the peak/<code>τ</code>-value, for which <code>L</code> is minimal and construct the actual embedding trajectory <code>𝒟_actual</code> (steps 1.-3. correspond to an embedding cycle). 4. We repeat steps 1.-3. with <code>𝒟_actual</code> as input and stop the algorithm when <code>L</code> can not be reduced anymore. <code>𝒟_actual</code> -&gt; <code>𝒟</code>.</p><p>In case of multivariate embedding, i.e. when embedding a set of M time series (<code>s::Dataset</code>), in each embedding cycle the continuity statistic <code>⟨ε★⟩</code> gets computed for all M time series available. The optimal delay value <code>τ</code> in each embedding cycle is chosen as the peak/<code>τ</code>-value for which <code>L</code> is minimal under all available peaks and under all M <code>⟨ε★⟩</code>&#39;s. In the first embedding cycle there will be M² different <code>⟨ε★⟩</code>&#39;s to consider, since it is not clear a priori which time series of the input should consitute the first component of the embedding vector and form <code>𝒟_actual</code>.</p><p>The range of considered delay values is determined in <code>τs</code> and for the nearest neighbor search we respect the Theiler window <code>w</code>. The final embedding vector is stored in <code>𝒟</code> (<code>Dataset</code>). The chosen delay values for each embedding cycle are stored in <code>τ_vals</code> and the according time series numbers chosen for each delay value in <code>τ_vals</code> are stored in <code>ts_vals</code>. For univariate embedding (<code>s::Vector</code>) <code>ts_vals</code> is a vector of ones of length <code>τ_vals</code>, because there is simply just one time series to choose from. The function also returns the <code>L</code>-statistic <code>Ls</code> for each embedding cycle and the continuity statistic <code>⟨ε★⟩</code> as an <code>Array</code> of <code>Vector</code>s.</p><p>For distance computations the Euclidean norm is used.</p></div></section></article><h3 id="Low-level-functions-of-unified-approach"><a class="docs-heading-anchor" href="#Low-level-functions-of-unified-approach">Low-level functions of unified approach</a><a id="Low-level-functions-of-unified-approach-1"></a><a class="docs-heading-anchor-permalink" href="#Low-level-functions-of-unified-approach" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="DelayEmbeddings.n_statistic" href="#DelayEmbeddings.n_statistic"><code>DelayEmbeddings.n_statistic</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">n_statistic(Y, s; kwargs...) → N, d_E1</code></pre><p>Perform one embedding cycle according to the method proposed in <sup class="footnote-reference"><a id="citeref-Garcia2005a" href="#footnote-Garcia2005a">[Garcia2005a]</a></sup> for a given phase space trajectory <code>Y</code> (of type <code>Dataset</code>) and a time series <code>s (of type</code>Vector<code>). Return the proposed N-Statistic</code>N<code>and all nearest neighbor distances</code>d_E1<code>for each point of the input phase space trajectory</code>Y<code>. Note that</code>Y` is a single time series in case of the first embedding cycle.</p><p><strong>Keyword arguments</strong></p><ul><li><code>τs= 0:50</code>: Considered delay values <code>τs</code> (in sampling time units). For each of the <code>τs</code>&#39;s the N-statistic gets computed.</li><li><code>r = 10</code>: The threshold, which defines the factor of tolerable stretching for the d_E1-statistic (see algorithm description).</li><li><code>T::Int = 1</code>: The forward time step (in sampling units) in order to compute the <code>d_E2</code>-statistic (see algorithm description). Note that in the paper this is not a free parameter and always set to <code>T=1</code>.</li><li><code>w::Int = 0</code>: Theiler window (neighbors in time with index <code>w</code> close to the point, that are excluded from being true neighbors). <code>w=0</code> means to exclude only the point itself, and no temporal neighbors. Note that in the paper this is not a free parameter and always <code>w=0</code>.</li><li><code>metric = Euclidean()</code>: metric used for finding nearest neigbhors in the input phase space trajectory <code>Y</code>.</li></ul><p><strong>Description</strong></p><p>For a range of possible delay values <code>τs</code> one constructs a temporary embedding matrix. That is, one concatenates the input phase space trajectory <code>Y</code> with the <code>τ</code>-lagged input time series <code>s</code>. For each point on the temporary trajectory one computes its nearest neighbor, which is denoted as the <code>d_E1</code>-statistic for a specific <code>τ</code>. Now one considers the distance between the reference point and its nearest neighbor <code>T</code> sampling units ahead and calls this statistic <code>d_E2</code>. <sup class="footnote-reference"><a id="citeref-Garcia2005a" href="#footnote-Garcia2005a">[Garcia2005a]</a></sup> strictly use <code>T=1</code>, so they forward each reference point and its corresponding nearest neighbor just by one (!) sampling unit. Here it is a free parameter.</p><p>The <code>N</code>-statistic is then the fraction of <code>d_E2</code>/<code>d_E1</code>-pairs which exceed a threshold <code>r</code>.</p><p>Plotted vs. the considered <code>τs</code>-values it is proposed to pick the <code>τ</code>-value for this embedding cycle as the value, where <code>N</code> has its first local minimum.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="DelayEmbeddings.beta_statistic" href="#DelayEmbeddings.beta_statistic"><code>DelayEmbeddings.beta_statistic</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">beta_statistic(Y::Dataset, s::Vector) [, τs, w]) → β</code></pre><p>Compute the β-statistic <code>β</code> for input state space trajectory <code>Y</code> and a timeseries <code>s</code> according to Nichkawde <sup class="footnote-reference"><a id="citeref-Nichkawde2013" href="#footnote-Nichkawde2013">[Nichkawde2013]</a></sup>, based on estimating derivatives on a projected manifold. For a range of delay values <code>τs</code>, <code>β</code> gets computed and its maximum over all considered <code>τs</code> serves as the optimal delay considered in this embedding cycle.</p><p>Arguments <code>τs, w</code> as in <a href="#DelayEmbeddings.mdop_embedding"><code>mdop_embedding</code></a>.</p><p><strong>Description</strong></p><p>The <code>β</code>-statistic is based on the geometrical idea of maximal unfolding of the reconstructed attractor and is tightly related to the False Nearest Neighbor method (<sup class="footnote-reference"><a id="citeref-Kennel1992" href="#footnote-Kennel1992">[Kennel1992]</a></sup>). In fact the method eliminates the maximum amount of false nearest neighbors in each embedding cycle. The idea is to estimate the absolute value of the directional derivative with respect to a possible new dimension in the reconstruction process, and with respect to the nearest neighbor, for all points of the state space trajectory:</p><p>ϕ&#39;(τ) = Δϕ<em>d(τ) / Δx</em>d</p><p>Δx<em>d is simply the Euclidean nearest neighbor distance for a reference point with respect to the given Theiler window <code>w</code>. Δϕ</em>d(τ) is the distance of the reference point to its nearest neighbor in the one dimensional time series <code>s</code>, for the specific τ. Δϕ_d(τ) = |s(i+τ)-s(j+τ)|, with i being the index of the considered reference point and j the index of its nearest neighbor.</p><p>Finally,</p><p><code>β</code> = log β(τ) = ⟨log₁₀ ϕ&#39;(τ)⟩ ,</p><p>with ⟨.⟩ being the mean over all reference points. When one chooses the maximum of <code>β</code> over all considered τ&#39;s, one obtains the optimal delay value for this embedding cycle. Note that in the first embedding cycle, the input state space trajectory <code>Y</code> can also be just a univariate time series.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="DelayEmbeddings.mdop_maximum_delay" href="#DelayEmbeddings.mdop_maximum_delay"><code>DelayEmbeddings.mdop_maximum_delay</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">mdop_maximum_delay(s, tw = 1:50, samplesize = 1.0)) -&gt; τ_max, L</code></pre><p>Compute an upper bound for the search of optimal delays, when using <code>mdop_embedding</code> <a href="#DelayEmbeddings.mdop_embedding"><code>mdop_embedding</code></a> or <code>beta_statistic</code> <a href="#DelayEmbeddings.beta_statistic"><code>beta_statistic</code></a>.</p><p><strong>Description</strong></p><p>The input time series <code>s</code> gets embedded with unit lag and increasing dimension, for dimensions (or time windows) <code>tw</code> (<code>RangeObject</code>). For each of such a time window the <code>L</code>-statistic from Uzal et al. <sup class="footnote-reference"><a id="citeref-Uzal2011" href="#footnote-Uzal2011">[Uzal2011]</a></sup> will be computed. <code>samplesize</code> determines the fraction of points to be considered in the computation of <code>L</code> (see <a href="#DelayEmbeddings.uzal_cost"><code>uzal_cost</code></a>). When this statistic reaches its global minimum the maximum delay value <code>τ_max</code> gets returned. When <code>s</code> is a multivariate <code>Dataset</code>, <code>τ_max</code> will becomputed for all timeseries of that Dataset and the maximum value will be returned. The returned <code>L</code>-statistic has size <code>(length(tw), size(s,2))</code>.</p></div></section></article><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-Pecora2007"><a class="tag is-link" href="#citeref-Pecora2007">Pecora2007</a>Pecora, L. M., Moniz, L., Nichols, J., &amp; Carroll, T. L. (2007). <a href="https://doi.org/10.1063/1.2430294">A unified approach to attractor reconstruction. Chaos 17(1)</a>.</li><li class="footnote" id="footnote-Uzal2011"><a class="tag is-link" href="#citeref-Uzal2011">Uzal2011</a>Uzal, L. C., Grinblat, G. L., Verdes, P. F. (2011). <a href="https://doi.org/10.1103/PhysRevE.84.016223">Optimal reconstruction of dynamical systems: A noise amplification approach. Physical Review E 84, 016223</a>.</li><li class="footnote" id="footnote-Garcia2005a"><a class="tag is-link" href="#citeref-Garcia2005a">Garcia2005a</a>Garcia, S. P., Almeida, J. S. (2005). <a href="https://doi.org/10.1103/PhysRevE.71.037204">Nearest neighbor embedding with different time delays. Physical Review E 71, 037204</a>.</li><li class="footnote" id="footnote-Garcia2005b"><a class="tag is-link" href="#citeref-Garcia2005b">Garcia2005b</a>Garcia, S. P., Almeida, J. S. (2005). <a href="https://doi.org/10.1103/PhysRevE.72.027205">Multivariate phase space reconstruction by nearest neighbor embedding with different time delays. Physical Review E 72, 027205</a>.</li><li class="footnote" id="footnote-Nichkawde2013"><a class="tag is-link" href="#citeref-Nichkawde2013">Nichkawde2013</a>Nichkawde, Chetan (2013). <a href="https://doi.org/10.1103/PhysRevE.87.022905">Optimal state-space reconstruction using derivatives on projected manifold. Physical Review E 87, 022905</a>.</li><li class="footnote" id="footnote-Hegger1999"><a class="tag is-link" href="#citeref-Hegger1999">Hegger1999</a>Hegger, Rainer and Kantz, Holger (1999). <a href="https://doi.org/10.1103/PhysRevE.60.4970">Improved false nearest neighbor method to detect determinism in time series data. Physical Review E 60, 4970</a>.</li><li class="footnote" id="footnote-Kennel1992"><a class="tag is-link" href="#citeref-Kennel1992">Kennel1992</a>Kennel, M. B., Brown, R., Abarbanel, H. D. I. (1992). <a href="https://doi.org/10.1103/PhysRevA.45.3403">Determining embedding dimension for state-space reconstruction using a geometrical construction. Phys. Rev. A 45, 3403</a>.</li><li class="footnote" id="footnote-Pecora2007"><a class="tag is-link" href="#citeref-Pecora2007">Pecora2007</a>Pecora, L. M., Moniz, L., Nichols, J., &amp; Carroll, T. L. (2007). <a href="https://doi.org/10.1063/1.2430294">A unified approach to attractor reconstruction. Chaos 17(1)</a>.</li><li class="footnote" id="footnote-Uzal2011"><a class="tag is-link" href="#citeref-Uzal2011">Uzal2011</a>Uzal, L. C., Grinblat, G. L., Verdes, P. F. (2011). <a href="https://doi.org/10.1103/PhysRevE.84.016223">Optimal reconstruction of dynamical systems: A noise amplification approach. Physical Review E 84, 016223</a>.</li><li class="footnote" id="footnote-Kraemer2020"><a class="tag is-link" href="#citeref-Kraemer2020">Kraemer2020</a>Kraemer, K.H., Datseris, G., Kurths, J., Kiss, I.Z., Ocampo-Espindola, Marwan, N. (2020). <a href="https://arxiv.org/abs/2011.07040">A unified and automated approach to attractor reconstruction. arXiv:2011.07040</a>.</li><li class="footnote" id="footnote-Garcia2005a"><a class="tag is-link" href="#citeref-Garcia2005a">Garcia2005a</a>Garcia, S. P., Almeida, J. S. (2005). <a href="https://doi.org/10.1103/PhysRevE.71.037204">Nearest neighbor embedding with different time delays. Physical Review E 71, 037204</a>.</li><li class="footnote" id="footnote-Nichkawde2013"><a class="tag is-link" href="#citeref-Nichkawde2013">Nichkawde2013</a>Nichkawde, Chetan (2013). <a href="https://doi.org/10.1103/PhysRevE.87.022905">Optimal state-space reconstruction using derivatives on projected manifold. Physical Review E 87, 022905</a>.</li><li class="footnote" id="footnote-Kennel1992"><a class="tag is-link" href="#citeref-Kennel1992">Kennel1992</a>Kennel, M. B., Brown, R., Abarbanel, H. D. I. (1992). <a href="https://doi.org/10.1103/PhysRevA.45.3403">Determining embedding dimension for state-space reconstruction using a geometrical construction. Phys. Rev. A 45, 3403</a>.</li><li class="footnote" id="footnote-Nichkawde2013"><a class="tag is-link" href="#citeref-Nichkawde2013">Nichkawde2013</a>Nichkawde, Chetan (2013). <a href="https://doi.org/10.1103/PhysRevE.87.022905">Optimal state-space reconstruction using derivatives on projected manifold. Physical Review E 87, 022905</a>.</li><li class="footnote" id="footnote-Uzal2011"><a class="tag is-link" href="#citeref-Uzal2011">Uzal2011</a>Uzal, L. C., Grinblat, G. L., Verdes, P. F. (2011). <a href="https://doi.org/10.1103/PhysRevE.84.016223">Optimal reconstruction of dynamical systems: A noise amplification approach. Physical Review E 84, 016223</a>.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../traditional/">« Traditional Optimal Embedding</a><a class="docs-footer-nextpage" href="../../chaos/orbitdiagram/">Orbit Diagrams &amp; PSOS »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 16 December 2020 11:29">Wednesday 16 December 2020</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
