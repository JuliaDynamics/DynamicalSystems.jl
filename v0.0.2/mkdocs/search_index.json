{
    "docs": [
        {
            "location": "/", 
            "text": "DynamicalSystems.jl\n is a Julia package for the exploration of continuous and discrete dynamical systems. it aims to be a useful and powerful companion for students and scientists treading on the field of Chaos, nonlinear dynamics and dynamical systems in general. The package treats discrete and continuous systems of the forms:\n\n\n\n\n\n\\frac{d\\vec{u}}{dt} = \\vec{f}(\\vec{u}) \\quad \\text{or}\\quad \\vec{x}_{n+1} = \\vec{f}(\\vec{x}_n)\n\n\n\n\n\nas well as numerical data.\n\n\nOne of a major goals of this package is to be completely transparent as to what is going on \"under the hood\". In scientific research, you never want to use \nblack boxes\n, e.g. functions that give a result without telling you how it was calculated. To this end, \nalmost every documentation string\n gives direct references to the original papers where the algorithm is taken from. For example, the documentation string of \n?lyapunovs\n will cite:\n\n\n[1] : A.M. Lyapunov, The General Problem of the Stability of Motion, Taylor \n Francis (1992)\n\n[2] : K. Geist et al, Progr. Theor. Phys. 83, pp 875 (1990)\n\n\n\n\n\nwhere the first reference introduces the concept of Lyapunov exponents and the second contains a plethora of methods for their computation (including the method used in the aforementioned function.\n\n\n\n\nContents\n\n\nThis is the (non-final) list of what this package aims to offer:\n\n\n\n\nIntuitive, consistent APIs for the definition of dynamical systems, see \nSystem Definition\n.\n\n\nAutomatic \"completion\" of the dynamics of the system with numerically computed Jacobians, in case they are not provided by the user, see \nSystem Definition\n.\n\n\nLyapunov exponent estimation, see \nLyapunov Exponents\n.\n\n\nEntropy estimation, see \nEntropies and Dimensions\n.\n\n\nAttractor dimension estimation, see \nEntropies and Dimensions\n.\n\n\nEntropy/Attractor dimension/Lyapunov exponents for \nnumerical data\n, see \nLyapunov Exponents\n and \nEntropies and Dimensions\n.\n\n\nChaos control, TBA.\n\n\nOther stuff I have not yet decided upon, since this is like a pre-alpha version.\n\n\nSuggest or Contribute more stuff! (see \ncontributors guide\n).", 
            "title": "Introduction"
        }, 
        {
            "location": "/#contents", 
            "text": "This is the (non-final) list of what this package aims to offer:   Intuitive, consistent APIs for the definition of dynamical systems, see  System Definition .  Automatic \"completion\" of the dynamics of the system with numerically computed Jacobians, in case they are not provided by the user, see  System Definition .  Lyapunov exponent estimation, see  Lyapunov Exponents .  Entropy estimation, see  Entropies and Dimensions .  Attractor dimension estimation, see  Entropies and Dimensions .  Entropy/Attractor dimension/Lyapunov exponents for  numerical data , see  Lyapunov Exponents  and  Entropies and Dimensions .  Chaos control, TBA.  Other stuff I have not yet decided upon, since this is like a pre-alpha version.  Suggest or Contribute more stuff! (see  contributors guide ).", 
            "title": "Contents"
        }, 
        {
            "location": "/system_definition/", 
            "text": "System Definition\n\n\nFor \nDynamicalSystems.jl\n a system is simple a structure that contains the system's state, the equations of motion and the Jacobian. The last two are \nfunctions\n that take as an input a state.\n\n\nThis of course stands for systems where one already \nknows the equations of motion\n. if instead, your \"system\" is in the form of \nnumerical data\n, then see the appropriate section.\n\n\nBy taking advantage of the package \nForwardDiff.jl\n an automated Jacobian function can always be supplemented by the package. More details are enclosed in the individual sections, however the documentation strings of all the constructors are also self-contained.\n\n\n\n\nNon-autonomous systems\n\n\nThis package does \nnot\n accept non-autonomous systems. To use such systems with this package increase the dimensionality of your system by 1, by introducing an additional variable $\\tau$ such that $d\\tau/dt = 1$ (or $\\tau_{n+1} = \\tau_n + 1$). This additional variable will serve as the \"time\" in your equations of motion.\n\n\n\n\n\n\nUser-defined Jacobian\n\n\nProviding a user-defined Jacobian to the system constructors is faster than using the one generated from \nForwardDiff.jl\n, albeit slightly. Currently, the only function that uses the Jacobian is \nlyapunovs\n, therefore it is advised to provided a user-defined one if you want to use it.\n\n\n\n\n\n\nDiscrete Systems\n\n\nDiscrete systems are of the form:\n\n\n\n\n\n\\vec{x}_{n+1} = \\vec{f}(\\vec{x}_n).\n\n\n\n\n\nThe Type representing such systems for dimensionality \nD \u2264 10\n is called \nDiscreteDS\n.\n\n\nThe constructor is:\n\n\nDiscreteDS\n(\nstate\n,\n \neom\n \n[,\n \njacob\n])\n\n\n\n\n\n\nThe documentation string of the constructor is perfectly self-contained, but for the sake of clarity we will go through all the steps in the following.\n\n\nstate\n is simply the state the system starts (a.k.a. initial conditions) and \neom\n is a \nfunction\n that takes a \nstate\n as an input and returns the next state as an output.\n\n\nThe \njacob\n is also a \nfunction\n that takes a \nstate\n as an input and returns the Jacobian matrix of the system (at this state). This however is optional and if not provided by the user, will be calculated automatically using the package \nForwardDiff.jl\n.\n\n\n\n\nReturn form of the \neom\n function for small \nD\n\n\nIt is \nheavily\n advised that the equations of motion \neom\n function returns an \nSVector\n from the julia package \nStaticArrays.jl\n and similarly the \njacob\n function returns an \nSMatrix\n. \nNumerous benchmarks\n have been made in order to deduce the most efficient possible way to define a system, and this way was proved to be the best when the system's dimension is small.\n\n\n\n\nFor example, let's create one of the \nPredefined Systems\n offered by this package, the H\u00e9non map:\n\n\nusing\n \nDynamicalSystems\n\n\nusing\n \nStaticArrays\n \n#only necessary when defining a system\n\n\n\neom_henon\n(\nx\n)\n \n=\n \nSVector\n{\n2\n}(\n1.0\n \n-\n \na\n*\nx\n[\n1\n]\n^\n2\n \n+\n \nx\n[\n2\n],\n \nb\n*\nx\n[\n1\n])\n\n\njacob_henon\n(\nx\n)\n \n=\n \n@SMatrix\n \n[\n-\n2\n*\na\n*\nx\n[\n1\n]\n \n1.0\n;\n \nb\n \n0.0\n]\n\n\n\nds\n \n=\n \nDiscreteDS\n(\nrand\n(\n2\n),\n \neom_henon\n,\n \njacob_henon\n)\n\n\n\n\n\n\nIf we did not want to write a Jacobian (due to e.g. unending laziness), we could\n\n\nds_nojac\n \n=\n \nDiscreteDS\n(\nrand\n(\n2\n),\n \neom_henon\n)\n\n\n\n\n\n\nand the Jacobian function would be created automatically.\n\n\n\n\nLarge Discrete Systems\n\n\nTBA\n\n\n\n\n1-dimensional Discrete Systems\n\n\nIn the case of maps, there a special structure for one-dimensional systems, since they are commonly used in scientific research. The syntax is \nDiscreteDS1D(state, eom [, deriv])\n. In this one-dimensional case, you don't need to worry about \nStaticArrays.jl\n because everything is in plain numbers. For example:\n\n\nusing\n \nDynamicalSystems\n\n\n\n@inline\n \neom_logistic\n(\nr\n)\n \n=\n \n(\nx\n)\n \n-\n \nr\n*\nx\n*\n(\n1\n-\nx\n)\n  \n# this is a closure\n\n\n@inline\n \nderiv_logistic\n(\nr\n)\n \n=\n \n(\nx\n)\n \n-\n \nr\n*\n(\n1\n-\n2\nx\n)\n \n# this is a closure\n\n\nr\n \n=\n \n3.7\n\n\nlogistic\n \n=\n \nDiscreteDS1D\n(\nrand\n(),\n \neom_logistic\n(\nr\n),\n \nderiv_logistic\n(\nr\n))\n\n\n\n\n\n\nOnce again, if you skip the derivative functions it will be calculated automatically using \nForwardDiff.jl\n.\n\n\n\n\nContinuous Systems\n\n\nContinuous systems of the form\n\n\n\n\n\n\\frac{d\\vec{u}}{dt} = \\vec{f}(\\vec{u}),\n\n\n\n\n\nare defined almost identically with the discrete systems. The documentation string of the constructor \nContinuousDS\n has all the necessary information:\n\n\n#\n\n\nDynamicalSystems.ContinuousDS\n \n \nType\n.\n\n\nContinuousDS(state, eom [, jacob]) \n: DynamicalSystem\n\n\n\n\n\nD\n-dimensional continuous dynamical system (used for \nD \u2264 10\n).\n\n\nFields:\n\n\n\n\nstate::SVector{D}\n : Current state-vector of the system, stored in the data format of \nStaticArray\n's \nSVector\n.\n\n\neom::F\n (function) : The function that represents the system's equations of motion (also called vector field). The function is of the format: \neom(u) -\n SVector\n which means that given a state-vector \nu\n it returns an \nSVector\n containing the derivatives \ndu\n at the current state.\n\n\njacob::J\n (function) : A function that calculates the system's jacobian matrix, based on the format: \njacob(u) -\n SMatrix\n which means that given a state-vector \nu\n it returns an \nSMatrix\n containing the Jacobian at that state. If the \njacob\n is not provided by the user, it is created with \ntremendous\n efficiency using the module \nForwardDiff\n. Most of the time, for low dimensional systems, this Jacobian is within a few % of speed of a user-defined one.\n\n\n\n\nsource\n\n\nOnce again, using \nStaticArrays\n is preferred.\n\n\nFor example, the continuous R\u00f6ssler system can be defined as:\n\n\neom_roessler\n(\nu\n)\n \n=\n\n\nSVector\n{\n3\n}(\n-\nu\n[\n2\n]\n-\nu\n[\n3\n],\n \nu\n[\n1\n]\n \n+\n \na\n*\nu\n[\n2\n],\n \nb\n \n+\n \nu\n[\n3\n]\n*\n(\nu\n[\n1\n]\n \n-\n \nc\n))\n\n\n\nfunction\n \njacob_roessler\n(\nu\n)\n\n  \ni\n \n=\n \none\n(\neltype\n(\nu\n))\n\n  \no\n \n=\n \nzero\n(\neltype\n(\nu\n))\n\n  \n@SMatrix\n \n[\no\n     \n-\ni\n      \n-\ni\n;\n\n            \ni\n      \na\n       \no\n;\n\n            \nu\n[\n3\n]\n   \no\n       \nu\n[\n1\n]\n \n-\n \nc\n]\n\n\nend\n\n\n\nros\n \n=\n \nContinuousDS\n(\nrand\n(\n3\n),\n \neom_roessler\n,\n \njacob_roessler\n)\n\n\n\n\n\n\n\n\nSystem evolution\n\n\nDynamicalSystems.jl\n provides convenient interfaces for the evolution of systems. In general, these are the functions you want to use:\n\n\n#\n\n\nDynamicalSystems.evolve\n \n \nFunction\n.\n\n\nevolve\n([\nstate\n,\n \n]\n \nds\n::\nDynamicalSystem\n,\n \nT\n=\n1\n;\n \ndiff_eq_kwargs\n \n=\n \nDict\n())\n \n-\n \nnew_state\n\n\n\n\n\n\nEvolve a \nstate\n (or the system's state) under the dynamics of \nds\n for total \"time\" \nT\n. For discrete systems \nT\n corresponds to steps and thus it must be integer. Returns the final state after evolution.\n\n\nThe \nkeyword\n argument \ndiff_eq_kwargs\n is dictionary \nDict{Symbol, ANY}\n of keyword arguments passed into the \nsolve\n of the \nDifferentialEquations.jl\n package, for example \nDict(:abstol =\n 1e-9)\n. It is applicable only in \nContinuousDS\n. If you want to specify a solver, do so by using the symbol \n:solver\n, e.g.: \nDict(:solver =\n DP5(), :maxiters =\n 1e9)\n. This requires you to have been first \nusing OrdinaryDiffEq\n or \nusing DifferentialEquations\n to access the solvers.\n\n\nThis function \ndoes not store\n any information about intermediate steps. Use \ntimeseries\n if you want to produce timeseries of the system.\n\n\nsource\n\n\n#\n\n\nDynamicalSystems.timeseries\n \n \nFunction\n.\n\n\ntimeseries\n(\nds\n::\nDynamicalSystem\n,\n \nT\n;\n \nkwargs\n...\n)\n\n\n\n\n\n\nCreate a matrix that will contain the timeseries of the sytem, after evolving it for time \nT\n (\nD\n is the system dimensionality). \nEach column corresponds to one dynamic variable.\n\n\nFor the discrete case, \nT\n is an integer and a \nT\u00d7D\n matrix is returned. For the continuous case, a \nK\u00d7D\n matrix is returned, with \nK = length(0:dt:T)\n with \n0:dt:T\n representing the time vector.\n\n\nKeywords:\n\n\n\n\nmutate = true\n : whether to update the dynamical system's state with the final state of the timeseries.\n\n\ndt = 0.05\n : (only for continuous) Time step of value output during the solving of the continuous system.\n\n\ndiff_eq_kwargs = Dict()\n : (only for continuous) A dictionary \nDict{Symbol, ANY}\n of keyword arguments passed into the \nsolve\n of the \nDifferentialEquations.jl\n package, for example \nDict(:abstol =\n 1e-9)\n. If you want to specify a solver, do so by using the symbol \n:solver\n, e.g.: \nDict(:solver =\n DP5(), :maxiters =\n 1e9)\n. This requires you to have been first \nusing OrdinaryDiffEq\n to access the solvers.\n\n\n\n\nsource\n\n\n#\n\n\nDiffEqBase.ODEProblem\n \n \nType\n.\n\n\nODEProblem\n(\nds\n::\nContinuousDS\n,\n \nt\n)\n\n\n\n\n\n\nReturn a type \nODEProblem\n with the given system information (t0 is zero). This can be passed directly into \nsolve\n from \nDifferentialEquations\n.\n\n\nsource\n\n\n#\n\n\nDynamicalSystems.evolve!\n \n \nFunction\n.\n\n\nevolve!\n(\nds\n::\nDynamicalSystem\n,\n \nT\n;\n \ndiff_eq_kwargs\n \n=\n \nDict\n())\n \n-\n \nds\n\n\n\n\n\n\nEvolve (in-place) a dynamical system for total \"time\" \nT\n, setting the final state as the system's state.\n\n\nsource\n\n\nevolve!\n(\nprob\n::\nODEProblem\n \n[,\n \nt\n::\nReal\n,\n \ndiff_eq_kwargs\n::\nDict\n])\n \n-\n \nfinal_state\n\n\n\n\n\n\nEvolve the problem using the solvers of \nDifferentialEquations\n, update the problem's state as the final state of the solution and return that state.\n\n\nIf \nt\n is given, the problem is evolved for that much time (else the existing \ntspan\n is used). Notice that in this function, \ndiff_eq_kwargs\n is \nnot\n a keyword argument.\n\n\nsource\n\n\nEspecially in the continuous case, an interface is provided to the module \nDifferentialEquations.jl\n, with an approach that fits more the structuring of the present package (e.g. time is never passed to the equations of motion). Also, the function \ntimeseries\n is the only one that stores the actual time-series of the system. All the other functions only keep the final state.\n\n\n\n\nNumerical Data\n\n\nIn the most general case, the numerical data representing the evolution of a system are in the form of time-series. \nDynamicalSystems.jl\n accepts two forms of numerical data in the most common function calls:\n\n\nfoo\n(\ndataset\n)\n\n\nbar\n(\nvectors\n...\n)\n\n\n\n\n\n\nwhere the \ndataset\n is an \nN\u00d7D\n matrix that contains \nN\n data points of a \nD\n dimensional system. The \nvectors... = v1, v2, ..., vD\n are simply the individual columns of the \ndataset\n (each column corresponds to a dynamic variable), so that \ndataset \u2261 hcat(vectors...)\n.\n\n\n\n\nPredefined Systems\n\n\nPredefined systems exist in the \nSystems\n submodule exported by \nDynamicalSystems.jl\n, in the form of functions that return a \nDynamicalSystem\n.\n\n\nAll of these functions have very similar documentation strings:\n\n\n\n\nCall signature (parameters of the system are always passed as keyword arguments).\n\n\nIntroductory text about what this system is and who introduced it first.\n\n\nCouple of sentences that contain cool science info about the system.\n\n\nReference to the original papers.\n\n\n\n\nFor example, the documentation of the \nLorenz system\n reads:\n\n\n#\n\n\nDynamicalSystems.Systems.lorenz\n \n \nFunction\n.\n\n\nlorenz(u0=[0.0, 10.0, 0.0]; \u03c3 = 10.0, \u03c1 = 28.0, \u03b2 = 8/3)\n\n\n\n\n\nThe famous three dimensional system due to Lorenz [1], shown to exhibit so-called \"deterministic nonperiodic flow\". It was originally invented to study a simplified form of atmospheric convection.\n\n\nCurrently, it is most famous for its strange attractor (occuring at the default parameters), which resembles a butterfly. For the same reason it is also associated with the term \"butterfly effect\" (a term which Lorenz himself disliked) even though the effect applies generally to dynamical systems.\n\n\nDefault values are the ones used in the original paper.\n\n\n[1] E. N. Lorenz, J. atmos. Sci. \n20\n, pp 130 (1963)\n\n\nsource\n\n\nSo far, the predefined systems that exist in the \nSystems\n sub-module are:\n\n\n#\n\n\nDynamicalSystems.Systems.henon\n \n \nFunction\n.\n\n\nhenon(u0=zeros(2); a = 1.4, b = 0.3)\n\n\n\n\n\nThe H\u00e9non map is a two-dimensional mapping due to H\u00e9non [1] that can display a strange attractor (at the default parameters). In addition, it also displays many other aspects of chaos, like period doubling or intermittency, for other parameters.\n\n\nAccording to the author, it is a system displaying all the properties of the Lorentz system (1963) while being as simple as possible.\n\n\nDefault values are the ones used in the original paper.\n\n\n[1] : M. H\u00e9non, Commun.Math. Phys. \n50\n, pp 69 (1976)\n\n\nsource\n\n\n#\n\n\nDynamicalSystems.Systems.logistic\n \n \nFunction\n.\n\n\nlogistic(x0 = rand(); r = 4.0)\n\n\n\n\n\nThe logistic map is an one dimensional unimodal mapping due to May [1] and is used by many as the archetypal example of how chaos can arise from very simple equations.\n\n\nOriginally intentend to be a discretized model of polulation dynamics, it is now famous for its bifurcation diagram, an immensly complex graph that that was shown be universal by Feigenbaum [2].\n\n\n[1] : R. M. May, Nature \n261\n, pp 459 (1976)\n\n\n[2] : M. J. Feigenbaum, J. Stat. Phys. \n19\n, pp 25 (1978)\n\n\nsource\n\n\n#\n\n\nDynamicalSystems.Systems.lorenz\n \n \nFunction\n.\n\n\nlorenz(u0=[0.0, 10.0, 0.0]; \u03c3 = 10.0, \u03c1 = 28.0, \u03b2 = 8/3)\n\n\n\n\n\nThe famous three dimensional system due to Lorenz [1], shown to exhibit so-called \"deterministic nonperiodic flow\". It was originally invented to study a simplified form of atmospheric convection.\n\n\nCurrently, it is most famous for its strange attractor (occuring at the default parameters), which resembles a butterfly. For the same reason it is also associated with the term \"butterfly effect\" (a term which Lorenz himself disliked) even though the effect applies generally to dynamical systems.\n\n\nDefault values are the ones used in the original paper.\n\n\n[1] E. N. Lorenz, J. atmos. Sci. \n20\n, pp 130 (1963)\n\n\nsource\n\n\n#\n\n\nDynamicalSystems.Systems.roessler\n \n \nFunction\n.\n\n\nroessler\n(\nu0\n=\nrand\n(\n3\n);\n \na\n \n=\n \n0.2\n,\n \nb\n \n=\n \n0.2\n,\n \nc\n \n=\n \n5.7\n)\n\n\n\n\n\n\nThis three-dimensional continuous system is due to R\u00f6ssler [1]. It is a system that by-design behaves similarly to the \nlorenz\n system and displays a (fractal) strange attractor. However, it is easier to analyze qualitatively, as for example the attractor is composed of a single manifold.\n\n\nDefault values are the same as the original paper.\n\n\n[1] O. E. R\u00f6ssler, Phys. Lett. \n57A\n, pp 397 (1976)\n\n\nsource\n\n\n#\n\n\nDynamicalSystems.Systems.standardmap\n \n \nFunction\n.\n\n\nstandardmap(u0=0.001rand(2); k = 0.971635)\n\n\n\n\n\nThe standard map (also known as Chirikov standard map) is a two dimensional, area-preserving chaotic mapping due to Chirikov [1]. It is one of the most studied chaotic systems and by far the most studied Hamiltonian (area-preserving) mapping.\n\n\nThe map corresponds to the  Poincar\u00e9's surface of section of the kicked rotor system. Changing the non-linearity parameter \nk\n transitions the system from completely periodic motion, to quasi-periodic, to local chaos (mixed phase-space) and finally to global chaos.\n\n\nThe default parameter \nk\n is the critical parameter where the golden-ratio torous is destroyed, as was calculated by Greene [2]. The e.o.m. considers the angle variable \n\u03b8\n to be the first, and the angular momentum \np\n to be the second variable, while both variables are always taken modulo 2\u03c0 (the mapping is on the [0,2\u03c0)\u00b2 torus).\n\n\n[1] : B. V. Chirikov, Preprint N. \n267\n, Institute of Nuclear Physics Novosibirsk (1969)\n\n\n[2] : J. M. Greene, J. Math. Phys. \n20\n, pp 1183 (1979)\n\n\nsource\n\n\n#\n\n\nDynamicalSystems.Systems.towel\n \n \nFunction\n.\n\n\ntowel(u0 = [0.085, -0.121, 0.075])\n\n\n\n\n\nThe folded-towel map is a hyperchaotic mapping due to R\u00f6ssler [1]. It is famous for being a mapping that has the smallest possible dimensions necessary for hyperchaos, having two positive and one negative lyapunov exponent.\n\n\nThe name comes from the fact that when plotted looks like a folded towel, in every projection.\n\n\nDefault values are the ones used in the original paper.\n\n\n[1] : O. E. R\u00f6ssler, Phys. Lett. \n71A\n, pp 155 (1979)\n\n\nsource", 
            "title": "System Definition"
        }, 
        {
            "location": "/system_definition/#system-definition", 
            "text": "For  DynamicalSystems.jl  a system is simple a structure that contains the system's state, the equations of motion and the Jacobian. The last two are  functions  that take as an input a state.  This of course stands for systems where one already  knows the equations of motion . if instead, your \"system\" is in the form of  numerical data , then see the appropriate section.  By taking advantage of the package  ForwardDiff.jl  an automated Jacobian function can always be supplemented by the package. More details are enclosed in the individual sections, however the documentation strings of all the constructors are also self-contained.   Non-autonomous systems  This package does  not  accept non-autonomous systems. To use such systems with this package increase the dimensionality of your system by 1, by introducing an additional variable $\\tau$ such that $d\\tau/dt = 1$ (or $\\tau_{n+1} = \\tau_n + 1$). This additional variable will serve as the \"time\" in your equations of motion.    User-defined Jacobian  Providing a user-defined Jacobian to the system constructors is faster than using the one generated from  ForwardDiff.jl , albeit slightly. Currently, the only function that uses the Jacobian is  lyapunovs , therefore it is advised to provided a user-defined one if you want to use it.", 
            "title": "System Definition"
        }, 
        {
            "location": "/system_definition/#discrete-systems", 
            "text": "Discrete systems are of the form:   \n\\vec{x}_{n+1} = \\vec{f}(\\vec{x}_n).   The Type representing such systems for dimensionality  D \u2264 10  is called  DiscreteDS .  The constructor is:  DiscreteDS ( state ,   eom   [,   jacob ])   The documentation string of the constructor is perfectly self-contained, but for the sake of clarity we will go through all the steps in the following.  state  is simply the state the system starts (a.k.a. initial conditions) and  eom  is a  function  that takes a  state  as an input and returns the next state as an output.  The  jacob  is also a  function  that takes a  state  as an input and returns the Jacobian matrix of the system (at this state). This however is optional and if not provided by the user, will be calculated automatically using the package  ForwardDiff.jl .   Return form of the  eom  function for small  D  It is  heavily  advised that the equations of motion  eom  function returns an  SVector  from the julia package  StaticArrays.jl  and similarly the  jacob  function returns an  SMatrix .  Numerous benchmarks  have been made in order to deduce the most efficient possible way to define a system, and this way was proved to be the best when the system's dimension is small.   For example, let's create one of the  Predefined Systems  offered by this package, the H\u00e9non map:  using   DynamicalSystems  using   StaticArrays   #only necessary when defining a system  eom_henon ( x )   =   SVector { 2 }( 1.0   -   a * x [ 1 ] ^ 2   +   x [ 2 ],   b * x [ 1 ])  jacob_henon ( x )   =   @SMatrix   [ - 2 * a * x [ 1 ]   1.0 ;   b   0.0 ]  ds   =   DiscreteDS ( rand ( 2 ),   eom_henon ,   jacob_henon )   If we did not want to write a Jacobian (due to e.g. unending laziness), we could  ds_nojac   =   DiscreteDS ( rand ( 2 ),   eom_henon )   and the Jacobian function would be created automatically.", 
            "title": "Discrete Systems"
        }, 
        {
            "location": "/system_definition/#large-discrete-systems", 
            "text": "TBA", 
            "title": "Large Discrete Systems"
        }, 
        {
            "location": "/system_definition/#1-dimensional-discrete-systems", 
            "text": "In the case of maps, there a special structure for one-dimensional systems, since they are commonly used in scientific research. The syntax is  DiscreteDS1D(state, eom [, deriv]) . In this one-dimensional case, you don't need to worry about  StaticArrays.jl  because everything is in plain numbers. For example:  using   DynamicalSystems  @inline   eom_logistic ( r )   =   ( x )   -   r * x * ( 1 - x )    # this is a closure  @inline   deriv_logistic ( r )   =   ( x )   -   r * ( 1 - 2 x )   # this is a closure  r   =   3.7  logistic   =   DiscreteDS1D ( rand (),   eom_logistic ( r ),   deriv_logistic ( r ))   Once again, if you skip the derivative functions it will be calculated automatically using  ForwardDiff.jl .", 
            "title": "1-dimensional Discrete Systems"
        }, 
        {
            "location": "/system_definition/#continuous-systems", 
            "text": "Continuous systems of the form   \n\\frac{d\\vec{u}}{dt} = \\vec{f}(\\vec{u}),   are defined almost identically with the discrete systems. The documentation string of the constructor  ContinuousDS  has all the necessary information:  #  DynamicalSystems.ContinuousDS     Type .  ContinuousDS(state, eom [, jacob])  : DynamicalSystem  D -dimensional continuous dynamical system (used for  D \u2264 10 ).  Fields:   state::SVector{D}  : Current state-vector of the system, stored in the data format of  StaticArray 's  SVector .  eom::F  (function) : The function that represents the system's equations of motion (also called vector field). The function is of the format:  eom(u) -  SVector  which means that given a state-vector  u  it returns an  SVector  containing the derivatives  du  at the current state.  jacob::J  (function) : A function that calculates the system's jacobian matrix, based on the format:  jacob(u) -  SMatrix  which means that given a state-vector  u  it returns an  SMatrix  containing the Jacobian at that state. If the  jacob  is not provided by the user, it is created with  tremendous  efficiency using the module  ForwardDiff . Most of the time, for low dimensional systems, this Jacobian is within a few % of speed of a user-defined one.   source  Once again, using  StaticArrays  is preferred.  For example, the continuous R\u00f6ssler system can be defined as:  eom_roessler ( u )   =  SVector { 3 }( - u [ 2 ] - u [ 3 ],   u [ 1 ]   +   a * u [ 2 ],   b   +   u [ 3 ] * ( u [ 1 ]   -   c ))  function   jacob_roessler ( u ) \n   i   =   one ( eltype ( u )) \n   o   =   zero ( eltype ( u )) \n   @SMatrix   [ o       - i        - i ; \n             i        a         o ; \n             u [ 3 ]     o         u [ 1 ]   -   c ]  end  ros   =   ContinuousDS ( rand ( 3 ),   eom_roessler ,   jacob_roessler )", 
            "title": "Continuous Systems"
        }, 
        {
            "location": "/system_definition/#system-evolution", 
            "text": "DynamicalSystems.jl  provides convenient interfaces for the evolution of systems. In general, these are the functions you want to use:  #  DynamicalSystems.evolve     Function .  evolve ([ state ,   ]   ds :: DynamicalSystem ,   T = 1 ;   diff_eq_kwargs   =   Dict ())   -   new_state   Evolve a  state  (or the system's state) under the dynamics of  ds  for total \"time\"  T . For discrete systems  T  corresponds to steps and thus it must be integer. Returns the final state after evolution.  The  keyword  argument  diff_eq_kwargs  is dictionary  Dict{Symbol, ANY}  of keyword arguments passed into the  solve  of the  DifferentialEquations.jl  package, for example  Dict(:abstol =  1e-9) . It is applicable only in  ContinuousDS . If you want to specify a solver, do so by using the symbol  :solver , e.g.:  Dict(:solver =  DP5(), :maxiters =  1e9) . This requires you to have been first  using OrdinaryDiffEq  or  using DifferentialEquations  to access the solvers.  This function  does not store  any information about intermediate steps. Use  timeseries  if you want to produce timeseries of the system.  source  #  DynamicalSystems.timeseries     Function .  timeseries ( ds :: DynamicalSystem ,   T ;   kwargs ... )   Create a matrix that will contain the timeseries of the sytem, after evolving it for time  T  ( D  is the system dimensionality).  Each column corresponds to one dynamic variable.  For the discrete case,  T  is an integer and a  T\u00d7D  matrix is returned. For the continuous case, a  K\u00d7D  matrix is returned, with  K = length(0:dt:T)  with  0:dt:T  representing the time vector.  Keywords:   mutate = true  : whether to update the dynamical system's state with the final state of the timeseries.  dt = 0.05  : (only for continuous) Time step of value output during the solving of the continuous system.  diff_eq_kwargs = Dict()  : (only for continuous) A dictionary  Dict{Symbol, ANY}  of keyword arguments passed into the  solve  of the  DifferentialEquations.jl  package, for example  Dict(:abstol =  1e-9) . If you want to specify a solver, do so by using the symbol  :solver , e.g.:  Dict(:solver =  DP5(), :maxiters =  1e9) . This requires you to have been first  using OrdinaryDiffEq  to access the solvers.   source  #  DiffEqBase.ODEProblem     Type .  ODEProblem ( ds :: ContinuousDS ,   t )   Return a type  ODEProblem  with the given system information (t0 is zero). This can be passed directly into  solve  from  DifferentialEquations .  source  #  DynamicalSystems.evolve!     Function .  evolve! ( ds :: DynamicalSystem ,   T ;   diff_eq_kwargs   =   Dict ())   -   ds   Evolve (in-place) a dynamical system for total \"time\"  T , setting the final state as the system's state.  source  evolve! ( prob :: ODEProblem   [,   t :: Real ,   diff_eq_kwargs :: Dict ])   -   final_state   Evolve the problem using the solvers of  DifferentialEquations , update the problem's state as the final state of the solution and return that state.  If  t  is given, the problem is evolved for that much time (else the existing  tspan  is used). Notice that in this function,  diff_eq_kwargs  is  not  a keyword argument.  source  Especially in the continuous case, an interface is provided to the module  DifferentialEquations.jl , with an approach that fits more the structuring of the present package (e.g. time is never passed to the equations of motion). Also, the function  timeseries  is the only one that stores the actual time-series of the system. All the other functions only keep the final state.", 
            "title": "System evolution"
        }, 
        {
            "location": "/system_definition/#numerical-data", 
            "text": "In the most general case, the numerical data representing the evolution of a system are in the form of time-series.  DynamicalSystems.jl  accepts two forms of numerical data in the most common function calls:  foo ( dataset )  bar ( vectors ... )   where the  dataset  is an  N\u00d7D  matrix that contains  N  data points of a  D  dimensional system. The  vectors... = v1, v2, ..., vD  are simply the individual columns of the  dataset  (each column corresponds to a dynamic variable), so that  dataset \u2261 hcat(vectors...) .", 
            "title": "Numerical Data"
        }, 
        {
            "location": "/system_definition/#predefined-systems", 
            "text": "Predefined systems exist in the  Systems  submodule exported by  DynamicalSystems.jl , in the form of functions that return a  DynamicalSystem .  All of these functions have very similar documentation strings:   Call signature (parameters of the system are always passed as keyword arguments).  Introductory text about what this system is and who introduced it first.  Couple of sentences that contain cool science info about the system.  Reference to the original papers.   For example, the documentation of the  Lorenz system  reads:  #  DynamicalSystems.Systems.lorenz     Function .  lorenz(u0=[0.0, 10.0, 0.0]; \u03c3 = 10.0, \u03c1 = 28.0, \u03b2 = 8/3)  The famous three dimensional system due to Lorenz [1], shown to exhibit so-called \"deterministic nonperiodic flow\". It was originally invented to study a simplified form of atmospheric convection.  Currently, it is most famous for its strange attractor (occuring at the default parameters), which resembles a butterfly. For the same reason it is also associated with the term \"butterfly effect\" (a term which Lorenz himself disliked) even though the effect applies generally to dynamical systems.  Default values are the ones used in the original paper.  [1] E. N. Lorenz, J. atmos. Sci.  20 , pp 130 (1963)  source  So far, the predefined systems that exist in the  Systems  sub-module are:  #  DynamicalSystems.Systems.henon     Function .  henon(u0=zeros(2); a = 1.4, b = 0.3)  The H\u00e9non map is a two-dimensional mapping due to H\u00e9non [1] that can display a strange attractor (at the default parameters). In addition, it also displays many other aspects of chaos, like period doubling or intermittency, for other parameters.  According to the author, it is a system displaying all the properties of the Lorentz system (1963) while being as simple as possible.  Default values are the ones used in the original paper.  [1] : M. H\u00e9non, Commun.Math. Phys.  50 , pp 69 (1976)  source  #  DynamicalSystems.Systems.logistic     Function .  logistic(x0 = rand(); r = 4.0)  The logistic map is an one dimensional unimodal mapping due to May [1] and is used by many as the archetypal example of how chaos can arise from very simple equations.  Originally intentend to be a discretized model of polulation dynamics, it is now famous for its bifurcation diagram, an immensly complex graph that that was shown be universal by Feigenbaum [2].  [1] : R. M. May, Nature  261 , pp 459 (1976)  [2] : M. J. Feigenbaum, J. Stat. Phys.  19 , pp 25 (1978)  source  #  DynamicalSystems.Systems.lorenz     Function .  lorenz(u0=[0.0, 10.0, 0.0]; \u03c3 = 10.0, \u03c1 = 28.0, \u03b2 = 8/3)  The famous three dimensional system due to Lorenz [1], shown to exhibit so-called \"deterministic nonperiodic flow\". It was originally invented to study a simplified form of atmospheric convection.  Currently, it is most famous for its strange attractor (occuring at the default parameters), which resembles a butterfly. For the same reason it is also associated with the term \"butterfly effect\" (a term which Lorenz himself disliked) even though the effect applies generally to dynamical systems.  Default values are the ones used in the original paper.  [1] E. N. Lorenz, J. atmos. Sci.  20 , pp 130 (1963)  source  #  DynamicalSystems.Systems.roessler     Function .  roessler ( u0 = rand ( 3 );   a   =   0.2 ,   b   =   0.2 ,   c   =   5.7 )   This three-dimensional continuous system is due to R\u00f6ssler [1]. It is a system that by-design behaves similarly to the  lorenz  system and displays a (fractal) strange attractor. However, it is easier to analyze qualitatively, as for example the attractor is composed of a single manifold.  Default values are the same as the original paper.  [1] O. E. R\u00f6ssler, Phys. Lett.  57A , pp 397 (1976)  source  #  DynamicalSystems.Systems.standardmap     Function .  standardmap(u0=0.001rand(2); k = 0.971635)  The standard map (also known as Chirikov standard map) is a two dimensional, area-preserving chaotic mapping due to Chirikov [1]. It is one of the most studied chaotic systems and by far the most studied Hamiltonian (area-preserving) mapping.  The map corresponds to the  Poincar\u00e9's surface of section of the kicked rotor system. Changing the non-linearity parameter  k  transitions the system from completely periodic motion, to quasi-periodic, to local chaos (mixed phase-space) and finally to global chaos.  The default parameter  k  is the critical parameter where the golden-ratio torous is destroyed, as was calculated by Greene [2]. The e.o.m. considers the angle variable  \u03b8  to be the first, and the angular momentum  p  to be the second variable, while both variables are always taken modulo 2\u03c0 (the mapping is on the [0,2\u03c0)\u00b2 torus).  [1] : B. V. Chirikov, Preprint N.  267 , Institute of Nuclear Physics Novosibirsk (1969)  [2] : J. M. Greene, J. Math. Phys.  20 , pp 1183 (1979)  source  #  DynamicalSystems.Systems.towel     Function .  towel(u0 = [0.085, -0.121, 0.075])  The folded-towel map is a hyperchaotic mapping due to R\u00f6ssler [1]. It is famous for being a mapping that has the smallest possible dimensions necessary for hyperchaos, having two positive and one negative lyapunov exponent.  The name comes from the fact that when plotted looks like a folded towel, in every projection.  Default values are the ones used in the original paper.  [1] : O. E. R\u00f6ssler, Phys. Lett.  71A , pp 155 (1979)  source", 
            "title": "Predefined Systems"
        }, 
        {
            "location": "/lyapunovs/", 
            "text": "Lyapunov Exponents\n\n\nLyapunov exponents measure rates of separation of nearby trajectories in the flow of a dynamical system. The \nWikipedia\n and the \nScholarpedia\n entries have a lot of valuable information about the history and usage of these quantities.\n\n\nThe naming comes after Aleksandr M. Lyapunov [1], a Russian mathematician/physicist that had major impact on the analysis of the stability of systems.\n\n\n[1] : See e.g. A.M. Lyapunov, \nThe General Problem of the Stability of Motion\n, Taylor \n Francis (1992) and references therein.\n\n\n\n\nDynamical Systems\n\n\nFor systems where the equations of motion are known, there two functions related with the computation of lyapunov exponents: \nlyapunovs\n and \nlyapunov\n.\n\n\n\n\nLyapunov Spectrum\n\n\nThe function \nlyapunovs\n calculates the entire spectrum of the exponents of a system:\n\n\n#\n\n\nDynamicalSystems.lyapunovs\n \n \nFunction\n.\n\n\nlyapunovs\n(\nds\n::\nDynamicalSystem\n,\n \nN\n;\n \nkwargs\n...\n)\n \n-\n \n[\n\u03bb1\n,\n \n\u03bb2\n,\n \n...\n,\n \n\u03bbD\n]\n\n\n\n\n\n\nCalculate the spectrum of lyapunov exponents [1] of \nds\n by applying the QR-decomposition method \nN\n times (see method \"H2\" of [2]). Returns a vector with the \nfinal\n values of the lyapunov exponents in descending order.\n\n\nKeyword Arguments:\n\n\n\n\nTtr\n : Extra \"transient\" time to evolve the system before application of the algorithm. Should be \nInt\n for discrete systems. Defaults are system type dependent.\n\n\ndt = 1.0\n : (only for continuous) Time of individual evolutions between sucessive orthonormalization steps.\n\n\ndiff_eq_kwargs = Dict()\n : (only for continuous) Keyword arguments passed into the solvers of the \nDifferentialEquations\n package (see \nevolve\n or \ntimeseries\n for more info).\n\n\n\n\n[1] : A. M. Lyapunov, \nThe General Problem of the Stability of Motion\n, Taylor \n Francis (1992)\n\n\n[2] : K. Geist \net al\n, Progr. Theor. Phys. \n83\n, pp 875 (1990)\n\n\nsource\n\n\nAs you can see, the documentation string is detailed and self-contained. For example, the lyapunov spectrum of the \nfolded towel map\n is calculated as:\n\n\nusing\n \nDynamicalSystems\n\n\n\nds\n \n=\n \nSystems\n.\ntowel\n()\n\n\n\u03bb\u03bb\n \n=\n \nlyapunovs\n(\nds\n,\n \n10000\n)\n\n\n# result:\n\n\n[\n0.432253\n,\n \n0.371617\n,\n \n-\n3.29632\n]\n\n\n\n\n\n\nSimilarly, for a continuous system, e.g. the Lorenz system, you would do:\n\n\nusing\n \nDynamicalSystems\n\n\n\nlor\n \n=\n \nSystems\n.\nlorenz\n(\n\u03c1\n \n=\n \n32.0\n)\n \n#this is not the original parameter!\n\n\nissubtype\n(\ntypeof\n(\nds\n),\n \nContinuousDS\n)\n \n# true\n\n\n\n\u03bb\u03bb\n \n=\n \nlyapunovs\n(\nlor\n,\n \n10000\n,\n\n\ndt\n \n=\n \n0.1\n,\n \ndiff_eq_kwargs\n \n=\n \nDict\n(\n:\nabstol\n \n=\n \n1e-9\n,\n \n:\nreltol\n \n=\n \n1e-9\n))\n\n\n# result:\n\n\n[\n0.999176\n,\n \n0.000774754\n,\n \n-\n14.6666\n]\n\n\n\n\n\n\n\n\nMaximum Lyapunov Exponent\n\n\nThe function \nlyapunov\n calculates the maximum lyapunov exponent of a system, much more efficiently than \nlyapunovs[1]\n:\n\n\n#\n\n\nDynamicalSystems.lyapunov\n \n \nFunction\n.\n\n\nlyapunov\n(\nds\n::\nDynamicalSystem\n,\n \n\u03a4\n;\n \nkwargs\n...\n)\n \n-\n \n\u03bb\n\n\n\n\n\n\nCalculate the maximum lyapunov exponent using a method due to Benettin [1], which simply evolves two neighboring trajectories while constantly rescaling one of the two. \nT\n  denotes the total time of evolution (should be \nInt\n for discrete systems).\n\n\nKeyword Arguments:\n\n\n\n\nTtr\n : Extra \"transient\" time to evolve the system before application of the algorithm. Should be \nInt\n for discrete systems. Defaults are system type dependent.\n\n\nd0 = 1e-9\n : Initial \n rescaling distance between two neighboring trajectories.\n\n\nthreshold = 10^3*d0\n : Threshold to rescale the test trajectory.\n\n\ndiff_eq_kwargs = Dict()\n : (only for continuous) Keyword arguments passed into the solvers of the \nDifferentialEquations\n package (see \nevolve\n or \ntimeseries\n for more info).\n\n\ndt = 0.1\n : (only for continuous) Time of evolution between each check of distance e0xceeding the \nthreshold\n.\n\n\n\n\nWarning\n: Default values have been choosen to give accurate \n fast results for maximum lyapunov exponent expected between 0.1 to 1.0. Be sure to adjust them properly for your system. Specifically for the continuous systems, be sure that \nexp(\u03bb*dt) \n d0 - threshold\n.\n\n\n[1] : G. Benettin \net al.\n, Phys. Rev. A \n14\n, pp 2338 (1976)\n\n\nsource\n\n\nFor example:\n\n\nusing\n \nDynamicalSystems\n\n\n\nhenon\n \n=\n \nSystems\n.\nhenon\n()\n\n\n\u03bb\n \n=\n \nlyapunov\n(\nhenon\n,\n \n10000\n,\n \nd0\n \n=\n \n1e-7\n,\n \nthreshold\n \n=\n \n1e-4\n,\n \nTtr\n \n=\n \n100\n)\n\n\n# result:\n\n\n0.42011626111385747\n\n\n\n\n\n\nThe same is done for continuous systems:\n\n\nusing\n \nDynamicalSystems\n,\n \nOrdinaryDiffEq\n\n\n\nross\n \n=\n \nSystems\n.\nroessler\n(\na\n \n=\n \n0.1\n,\n \nb\n \n=\n \n0.1\n,\n \nc\n \n=\n \n14.0\n)\n \n#not original parameters\n\n\n\u03bb\n \n=\n \nlyapunov\n(\nross\n,\n \n10000\n,\n \ndt\n \n=\n \n0.5\n,\n \ndiff_eq_kwargs\n \n=\n \nDict\n(\n:\nsolver\n \n=\n \nVern8\n()))\n\n\n# result:\n\n\n0.06957484163052223\n\n\n\n\n\n\n\n\nNumerical Data\n\n\nTBA", 
            "title": "Lyapunov Exponents"
        }, 
        {
            "location": "/lyapunovs/#lyapunov-exponents", 
            "text": "Lyapunov exponents measure rates of separation of nearby trajectories in the flow of a dynamical system. The  Wikipedia  and the  Scholarpedia  entries have a lot of valuable information about the history and usage of these quantities.  The naming comes after Aleksandr M. Lyapunov [1], a Russian mathematician/physicist that had major impact on the analysis of the stability of systems.  [1] : See e.g. A.M. Lyapunov,  The General Problem of the Stability of Motion , Taylor   Francis (1992) and references therein.", 
            "title": "Lyapunov Exponents"
        }, 
        {
            "location": "/lyapunovs/#dynamical-systems", 
            "text": "For systems where the equations of motion are known, there two functions related with the computation of lyapunov exponents:  lyapunovs  and  lyapunov .", 
            "title": "Dynamical Systems"
        }, 
        {
            "location": "/lyapunovs/#lyapunov-spectrum", 
            "text": "The function  lyapunovs  calculates the entire spectrum of the exponents of a system:  #  DynamicalSystems.lyapunovs     Function .  lyapunovs ( ds :: DynamicalSystem ,   N ;   kwargs ... )   -   [ \u03bb1 ,   \u03bb2 ,   ... ,   \u03bbD ]   Calculate the spectrum of lyapunov exponents [1] of  ds  by applying the QR-decomposition method  N  times (see method \"H2\" of [2]). Returns a vector with the  final  values of the lyapunov exponents in descending order.  Keyword Arguments:   Ttr  : Extra \"transient\" time to evolve the system before application of the algorithm. Should be  Int  for discrete systems. Defaults are system type dependent.  dt = 1.0  : (only for continuous) Time of individual evolutions between sucessive orthonormalization steps.  diff_eq_kwargs = Dict()  : (only for continuous) Keyword arguments passed into the solvers of the  DifferentialEquations  package (see  evolve  or  timeseries  for more info).   [1] : A. M. Lyapunov,  The General Problem of the Stability of Motion , Taylor   Francis (1992)  [2] : K. Geist  et al , Progr. Theor. Phys.  83 , pp 875 (1990)  source  As you can see, the documentation string is detailed and self-contained. For example, the lyapunov spectrum of the  folded towel map  is calculated as:  using   DynamicalSystems  ds   =   Systems . towel ()  \u03bb\u03bb   =   lyapunovs ( ds ,   10000 )  # result:  [ 0.432253 ,   0.371617 ,   - 3.29632 ]   Similarly, for a continuous system, e.g. the Lorenz system, you would do:  using   DynamicalSystems  lor   =   Systems . lorenz ( \u03c1   =   32.0 )   #this is not the original parameter!  issubtype ( typeof ( ds ),   ContinuousDS )   # true  \u03bb\u03bb   =   lyapunovs ( lor ,   10000 ,  dt   =   0.1 ,   diff_eq_kwargs   =   Dict ( : abstol   =   1e-9 ,   : reltol   =   1e-9 ))  # result:  [ 0.999176 ,   0.000774754 ,   - 14.6666 ]", 
            "title": "Lyapunov Spectrum"
        }, 
        {
            "location": "/lyapunovs/#maximum-lyapunov-exponent", 
            "text": "The function  lyapunov  calculates the maximum lyapunov exponent of a system, much more efficiently than  lyapunovs[1] :  #  DynamicalSystems.lyapunov     Function .  lyapunov ( ds :: DynamicalSystem ,   \u03a4 ;   kwargs ... )   -   \u03bb   Calculate the maximum lyapunov exponent using a method due to Benettin [1], which simply evolves two neighboring trajectories while constantly rescaling one of the two.  T   denotes the total time of evolution (should be  Int  for discrete systems).  Keyword Arguments:   Ttr  : Extra \"transient\" time to evolve the system before application of the algorithm. Should be  Int  for discrete systems. Defaults are system type dependent.  d0 = 1e-9  : Initial   rescaling distance between two neighboring trajectories.  threshold = 10^3*d0  : Threshold to rescale the test trajectory.  diff_eq_kwargs = Dict()  : (only for continuous) Keyword arguments passed into the solvers of the  DifferentialEquations  package (see  evolve  or  timeseries  for more info).  dt = 0.1  : (only for continuous) Time of evolution between each check of distance e0xceeding the  threshold .   Warning : Default values have been choosen to give accurate   fast results for maximum lyapunov exponent expected between 0.1 to 1.0. Be sure to adjust them properly for your system. Specifically for the continuous systems, be sure that  exp(\u03bb*dt)   d0 - threshold .  [1] : G. Benettin  et al. , Phys. Rev. A  14 , pp 2338 (1976)  source  For example:  using   DynamicalSystems  henon   =   Systems . henon ()  \u03bb   =   lyapunov ( henon ,   10000 ,   d0   =   1e-7 ,   threshold   =   1e-4 ,   Ttr   =   100 )  # result:  0.42011626111385747   The same is done for continuous systems:  using   DynamicalSystems ,   OrdinaryDiffEq  ross   =   Systems . roessler ( a   =   0.1 ,   b   =   0.1 ,   c   =   14.0 )   #not original parameters  \u03bb   =   lyapunov ( ross ,   10000 ,   dt   =   0.5 ,   diff_eq_kwargs   =   Dict ( : solver   =   Vern8 ()))  # result:  0.06957484163052223", 
            "title": "Maximum Lyapunov Exponent"
        }, 
        {
            "location": "/lyapunovs/#numerical-data", 
            "text": "TBA", 
            "title": "Numerical Data"
        }
    ]
}